<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git最佳实践</title>
    <link href="/posts/61413.html"/>
    <url>/posts/61413.html</url>
    
    <content type="html"><![CDATA[<h1 id="Be-a-better-developer-with-these-Git-good-practices"><a href="#Be-a-better-developer-with-these-Git-good-practices" class="headerlink" title="Be a better developer with these Git good practices"></a>Be a better developer with these Git good practices</h1><p><a href="https://dev.to/t/git">#git</a><a href="https://dev.to/t/github">#github</a><a href="https://dev.to/t/webdev">#webdev</a><a href="https://dev.to/t/beginners">#beginners</a></p><p>If you’re a developer, you probably use the versioning system called Git on a daily basis. The use of this tool is crucial for the development process of an application, whether working in a team or individually. However, it’s common to encounter messy repositories, commits with unclear messages that don’t convey useful information, and misuse of branches, among other issues. Knowing how to use Git correctly and following good practices is essential for those who want to excel in the job market.</p><hr><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><ol><li><a href="https://dev.to/basementdevs/be-a-better-developer-with-these-git-good-practices-2dim#naming-conventions">Naming Conventions for Git Branches</a></li><li><a href="https://dev.to/basementdevs/be-a-better-developer-with-these-git-good-practices-2dim#branch-names">Branch Names Convention Prefixes</a></li><li><a href="https://dev.to/basementdevs/be-a-better-developer-with-these-git-good-practices-2dim#commit-message">Commit Message</a></li><li><a href="https://dev.to/basementdevs/be-a-better-developer-with-these-git-good-practices-2dim#conventional-commits">Conventional Commit’s</a></li></ol><hr><h2 id="Naming-Conventions-for-Git-Branches"><a href="#Naming-Conventions-for-Git-Branches" class="headerlink" title="Naming Conventions for Git Branches"></a>Naming Conventions for Git Branches</h2><p>When we’re working with code versioning, one of the main good practices that we should follow is using clear and descriptive names for branches, commits, pull requests, etc. Ensuring a concise workflow for all team members is essential. In addition to gaining productivity, documenting the development process of the project historically simplifies teamwork. By following these practices, you’ll see benefits soon.</p><p>Based on it, the community created a branch naming convention that you can follow in your project. The use of the following items below is optional, but they can help improve your development skills.</p><p><strong>1. Lowercase:</strong> Don’t use uppercase letters in the branch name, stick to lowercase;</p><p><strong>2. Hyphen separated:</strong> If your branch name consists of more than one word, separate them with a hyphen. following the kebab-case convention. Avoid PascalCase, camelCase, or snake_case;</p><p><strong>3. (a-z, 0-9):</strong> Use only alphanumeric characters and hyphens in your branch name. Avoid any non-alphanumeric character;</p><p><strong>4. Please, don’t use continuous hyphens (–).</strong> This practice can be confusing. For example, if you have branch types (such as a feature, bugfix, hotfix, etc.), use a slash (&#x2F;) instead;</p><p><strong>5. Avoid ending your branch name with a hyphen</strong>. It does not make sense because a hyphen separates words, and there’s no word to separate at the end;</p><p><strong>6. This practice is the most important:</strong> Use descriptive, concise, and clear names that explain what was done on the branch;</p><p><strong>Wrong branch names</strong></p><ul><li><code>fixSidebar</code></li><li><code>feature-new-sidebar-</code></li><li><code>FeatureNewSidebar</code></li><li><code>feat_add_sidebar</code></li></ul><p><strong>Good branch names</strong></p><ul><li>feature&#x2F;new-sidebar</li><li>add-new-sidebar</li><li>hotfix&#x2F;interval-query-param-on-get-historical-data</li></ul><hr><h2 id="Branch-Names-Convention-Prefixes"><a href="#Branch-Names-Convention-Prefixes" class="headerlink" title="Branch Names Convention Prefixes"></a>Branch Names Convention Prefixes</h2><p>Sometimes the purpose of a branch isn’t clear. It could be a new feature, a bug fix, documentation updates, or anything else. To address this, it’s a common practice to use a prefix on the branch name to quickly explain the purpose of the branch.</p><ul><li><p><strong>feature:</strong> It conveys a new feature that will be developed. For example, <code>feature/add-filters</code>;</p></li><li><p><strong>release:</strong> Used to prepare a new release. The prefix <code>release/</code> is commonly used to do tasks such as last touched and revisions before merging the new updates from the branch master to create a release. For example, <code>release/v3.3.1-beta</code>;</p></li><li><p><strong>bugfix:</strong> It conveys that you’re solving a bug in the code and it’s usually related to an issue. For instance, <code>bugfix/sign-in-flow</code>;</p></li><li><p><strong>hotfix:</strong> Similar to bugfix, but it is related to fixing a critical bug present in the production environment. For example, <code>hotfix/cors-error</code>;</p></li><li><p><strong>docs:</strong> To write some documentation. For example, <code>docs/quick-start</code>;</p></li></ul><p>If you’re working in a workflow with task management, like Jira, Trello, ClickUp, or any similar tool that can create User Stories, each card has a number associated. So, is commonly use these card numbers on the prefix of branch names. For example:</p><ul><li><code>feature/T-531-add-sidebar</code></li><li><code>docs/T-789-update-readme</code></li><li><code>hotfix/T-142-security-path</code></li></ul><hr><h2 id="Commit-Message"><a href="#Commit-Message" class="headerlink" title="Commit Message"></a>Commit Message</h2><p>Let’s go talk about commit messages. Unfortunately, is so easy to find projects with commit messages like “added a lot of things” or “Pikachu, I choose you”… Yeah, I once found a project where the commit messages were related to a Pokémon fight.</p><p>Commit messages are really important in the development process. Creating a good history will help you a lot of times in your journey. Like branches, commits also have conventions created by the community, which you can learn about below:</p><ul><li><p>A commit message has three important sections: Subject, Description, and Footer. The subject of a commit is required and defines the purpose of a commit. The description (body) is used to provide additional context and explanation for the commit’s purpose. Lastly, there’s the footer, commonly used for metadata like assigning a commit. While utilizing both the description and footer is considered a good practice, it’s not required.</p></li><li><p><strong>Use the imperative mood in the subject line.</strong> For example:</p></li></ul><blockquote><p><code>Add README.md</code> ✅;<br><code>Added README.md</code> ❌;<br><code>Adding README.md</code> ❌;</p></blockquote><ul><li><strong>Capitalize the first letter of the subject line.</strong> For example:</li></ul><blockquote><p><code>Add user authentication</code> ✅;<br><code>add user authentication</code> ❌;</p></blockquote><ul><li><strong>Don’t end the subject line with a period.</strong> For example:</li></ul><blockquote><p><code>Update unit tests</code> ✅;<br><code>Update unit tests.</code> ❌;</p></blockquote><ul><li><p>Limit the subject line to <strong>50 characters</strong>, i.e., be clear and concise;</p></li><li><p>Wrap the body at <strong>72 characters</strong> and separate the subject from a <strong>blank line</strong>;</p></li><li><p>If your body of commit has more than one paragraph, so <strong>use blank lines to separate them</strong>;</p></li><li><p>If necessary, use <strong>bullet points</strong> instead of only paragraphs;</p></li></ul><hr><h2 id="Conventional-Commit’s"><a href="#Conventional-Commit’s" class="headerlink" title="Conventional Commit’s"></a>Conventional Commit’s</h2><blockquote><p>“The Conventional Commits specification is a lightweight convention on top of commit messages. It provides an easy set of rules for creating an explicit commit history.”</p></blockquote><p>The quote below was obtained from the Conventional Commit’s official website. This specification is the most used convention to commit messages in the community.</p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-keyword">type</span>&gt;[<span class="hljs-keyword">optional</span> scope]: &lt;description&gt;<br><br>[<span class="hljs-keyword">optional</span> body]<br><br>[<span class="hljs-keyword">optional</span> footer(s)]<br></code></pre></td></tr></table></figure><h3 id="Commit-Type"><a href="#Commit-Type" class="headerlink" title="Commit Type"></a>Commit Type</h3><p>The first structure that we have to study is the commit type. It provides a clear context about what’s done in this commit. Below you can see the list of commit types and when to use them:</p><ul><li><p><strong>feat:</strong> Introductions of new functionalities;</p></li><li><p><strong>fix:</strong> Rectifications of software bugs;</p></li><li><p><strong>refactor:</strong> Employed for code alterations preserving its overall functionality;</p></li><li><p><strong>chore:</strong> Updates not impacting production code, involving tool, config, or library adjustments;</p></li><li><p><strong>docs:</strong> Additions or modifications to documentation files;</p></li><li><p><strong>perf:</strong> Code changes enhancing performance;</p></li><li><p><strong>style:</strong> Adjustments related to code presentation, like formatting and whitespace;</p></li><li><p><strong>test:</strong> Inclusion or correction of tests;</p></li><li><p><strong>build:</strong> Modifications affecting the build system or external dependencies;</p></li><li><p><strong>ci:</strong> Alterations to CI configuration files and scripts;</p></li><li><p><strong>env:</strong> Describes adjustments or additions to configuration files within CI processes, such as container configuration parameters.</p></li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>A scope is a structure that can be added after the commit’s type to provide additional contextual information:</p><ul><li><code>fix(ui): resolve issue with button alignment</code></li><li><code>feat(auth): implement user authentication</code></li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>The body of a commit message provides detailed explanations about the changes introduced by the commit. It’s typically added after a blank line following the subject line.</p><p><strong>Example:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Add</span> <span class="hljs-built_in">new</span> functionality <span class="hljs-keyword">to</span> handle <span class="hljs-keyword">user</span> authentication.<br><br>This <span class="hljs-keyword">commit</span> introduces a <span class="hljs-built_in">new</span> module <span class="hljs-keyword">to</span> manage <span class="hljs-keyword">user</span> authentication. It includes<br><span class="hljs-keyword">functions</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">login</span>, registration, <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span> recovery.<br></code></pre></td></tr></table></figure><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>The footer of a commit message is used to provide additional information related to the commit. This can include details such as who reviewed or approved the changes.</p><p><strong>Example:</strong></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">Signed-off-<span class="hljs-meta">by</span>: John &lt;john.doe<span class="hljs-meta">@example</span>.com&gt;<br>Reviewed-<span class="hljs-meta">by</span>: Anthony &lt;anthony<span class="hljs-meta">@example</span>.com&gt;<br></code></pre></td></tr></table></figure><h3 id="Breaking-Change"><a href="#Breaking-Change" class="headerlink" title="Breaking Change"></a>Breaking Change</h3><p>Indicate that the commit includes significant changes that may lead to compatibility issues or require modifications in dependent code. You can add a <code>BREAKING CHANGE</code> in the footer or include <code>!</code> after the type&#x2F;scope.</p><h3 id="Examples-of-commits-using-conventional-commits"><a href="#Examples-of-commits-using-conventional-commits" class="headerlink" title="Examples of commits using conventional commits"></a>Examples of commits using conventional commits</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">chore: add commitlint and husky<br><span class="hljs-function"><span class="hljs-title">chore</span><span class="hljs-params">(eslint)</span></span>: enforce the use of double <span class="hljs-attribute">quotes</span> in JSX<br>refactor: type refactoring<br>feat: add axios and data handling<br><span class="hljs-function"><span class="hljs-title">feat</span><span class="hljs-params">(page/home)</span></span>: create next routing<br>chore!: drop support <span class="hljs-keyword">for</span> Node <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p><strong>With subject, body and footer:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">feat:</span> add <span class="hljs-keyword">function</span> <span class="hljs-keyword">to</span> convert colors <span class="hljs-keyword">in</span> hexadecimal <span class="hljs-keyword">to</span> rgba<br><br>Lorem Ipsum <span class="hljs-built_in">is</span> simply dummy <span class="hljs-keyword">text</span> <span class="hljs-keyword">of</span> the printing <span class="hljs-built_in">and</span> typesetting industry.<br><br>Lorem Ipsum has been the industry<span class="hljs-comment">&#x27;s standard dummy text ever since the 1500s.</span><br><br>Reviewed-<span class="hljs-keyword">by</span>: <span class="hljs-number">2</span><br><span class="hljs-symbol">Refs:</span> #<span class="hljs-number">345</span><br></code></pre></td></tr></table></figure><hr><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.conventionalcommits.org/">https://www.conventionalcommits.org</a></li><li><a href="https://medium.com/@abhay.pixolo/naming-conventions-for-git-branches-a-cheatsheet-8549feca2534">https://medium.com/@abhay.pixolo/naming-conventions-for-git-branches-a-cheatsheet-8549feca2534</a></li><li><a href="https://se-education.org/guides/conventions/git.html">https://se-education.org/guides/conventions/git.html</a></li><li><a href="https://cbea.ms/git-commit/">https://cbea.ms/git-commit/</a> <a href="https://blog.geekhunter.com.br/o-que-e-commit-e-como-usar-commits-semanticos/">https://blog.geekhunter.com.br/o-que-e-commit-e-como-usar-commits-semanticos/</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事件分析平台设计</title>
    <link href="/posts/45405.html"/>
    <url>/posts/45405.html</url>
    
    <content type="html"><![CDATA[<p>在广告业务中，我们的服务器每天都会收集到很多条用户行为日志。我们希望能有效地利用这些日志来揭示用户行为模式，以解答以下问题：</p><ul><li>在过去的三个月中，哪个广告渠道的用户注册量最大？</li><li>上周，北京地区浏览广告的用户年龄分布是怎样的？</li><li>最近一周，通过广告注册的用户，他们的一周留存率是多少？有何变化趋势？</li><li>在过去的一周中，用户从接触广告到完成下单的各个环节的转化率如何？</li></ul><p>为解答这些问题，我构建了一个事件分析平台。本文将首先概述平台的功能，然后深入讨论平台架构的一些思考</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>总结来说，为了解答各种商业分析问题，事件分析平台提供了基于事件的指标统计、属性分组、条件筛选等功能的查询。在这里，“事件”是指用户行为，如点击广告、浏览商品、购买商品等。具体来说，事件分析平台支持「事件分析」，「漏斗分析」和「留存分析」这三种分析方式。</p><h4 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h4><p>事件分析是一种分析方法，用户可以通过设定一系列条件，查询特定指标，以解答特定的分析问题。这些条件包括：</p><ul><li>事件类型：这是指用户的行为，这些行为数据来自埋点数据。例如，点击某个广告，或者购买某个产品。</li><li>指标：指标可以分为基础指标和自定义指标。<ul><li>基础指标：总次数（页面浏览量，PV），总用户数（独立访客，UV），人均次数（PV&#x2F;UV）。</li><li>自定义指标：事件属性 + 计算类型，例如「用户购买金额」的「总额&#x2F;平均值&#x2F;最大值」。</li></ul></li><li>过滤条件：这是用于筛选出我们关心的用户群体。</li><li>维度分组：基于分组，可以进行组间的对比。</li><li>时间范围：设定事件发生的时间范围。</li></ul><p>以一个具体的例子来说明。假设我们想要解答这个问题：「最近一周，在北京地区，不同年龄段的用户在点击某个广告后，购买产品的平均金额是多少？」这个问题可以拆解为以下的事件分析：</p><ul><li>事件类型 &#x3D; 点击某个广告并购买产品</li><li>指标 &#x3D; 购买产品的平均金额</li><li>过滤条件 &#x3D; 用户所在地区为北京</li><li>维度分组 &#x3D; 根据用户年龄段进行分组</li><li>时间范围 &#x3D; 最近一周</li></ul><h4 id="漏斗分析"><a href="#漏斗分析" class="headerlink" title="漏斗分析"></a>漏斗分析</h4><p>漏斗分析是用于研究在一个多步骤的过程中，每一步的转化率和流失率。</p><p>以广告业务为例，用户的完整广告互动和购买流程可能包括以下步骤：浏览广告 -&gt; 点击广告 -&gt; 查看产品详情 -&gt; 购买产品。我们可以将这个流程设定为一个漏斗，以便分析整个过程以及每个步骤的转化情况。</p><p>此外，漏斗分析还需要定义「窗口期」，即整个过程必须在设定的窗口期内完成，才算作一次成功的转化。与事件分析相似，漏斗分析也支持选择维度分组和时间范围。</p><h4 id="留存分析"><a href="#留存分析" class="headerlink" title="留存分析"></a>留存分析</h4><p>在留存分析中，用户定义初始事件和后续事件，并计算在发生初始事件后的第 N 天，发生后续事件的比率。这个比率能够有效地衡量广告用户的粘性。</p><p>举例来说，我们可能想要了解某个广告是否足够吸引用户。因此，我们可以设置初始事件为点击广告，后续事件为购买产品，留存周期为 7 天，进行留存分析。</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>在架构上，广告业务的事件分析平台分为两个主要模块，如下图所示：</p><p>数据写入：广告点击或浏览的日志数据从客户端或服务器端上报后，经过 Kafka 消息队列，由 Flink 完成 ETL，然后写入 ClickHouse。<br>分析查询：用户通过前端页面，进行事件、条件、维度的选择，后端将这些条件组合成 SQL 语句，从 ClickHouse 中查询数据，然后展示给前端页面。</p><h5 id="使用-ClickHouse-存储广告点击事件数据"><a href="#使用-ClickHouse-存储广告点击事件数据" class="headerlink" title="使用 ClickHouse 存储广告点击事件数据"></a>使用 ClickHouse 存储广告点击事件数据</h5><p>广告业务的事件分析平台的数据来源主要有两类：</p><p>一类是来源于广告点击和浏览的日志数据，另一类是来源于「用户画像平台」的用户属性数据。本文只讨论关于广告点击和浏览日志数据的存储</p><p>在进行广告点击和浏览日志的存储选型前，我们首先明确了几个核心需求：</p><ul><li>支持海量数据的存储。广告业务每天产生的点击和浏览日志数据是海量的</li><li>支持实时聚合查询。由于广告策略和运营团队会使用事件分析平台来探索多种用户行为模式，分析引擎必须能灵活且高效地完成各种聚合。</li></ul><p>ClickHouse 在海量数据存储场景被广泛使用，高效支持各类聚合查询，配套有成熟和活跃的社区，促使我最终选择 ClickHouse 作为存储引擎。</p><p>根据对真实广告点击和浏览数据的测试，亿级数据的简单查询，例如广告点击量和独立访客数量，都能在 1 秒内返回结果；对于留存分析、漏斗分析这类的复杂查询，可以在 10 秒内返回结果。</p><p>解决了「数据存在哪里」的问题后，接下来回答「如何存储」的问题。ClickHouse 的列式存储结构非常适合存储大宽表，以支持高效查询</p><p>建表如下（简化了大部分字段）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> event_analytics<br>(<br>    app_id          String COMMENT <span class="hljs-string">&#x27;应用 ID&#x27;</span>,<br>    open_id         String COMMENT <span class="hljs-string">&#x27;用户 OPEN ID&#x27;</span>,<br>    media           String COMMENT <span class="hljs-string">&#x27;媒体&#x27;</span>,<br>    channel         String COMMENT <span class="hljs-string">&#x27;渠道&#x27;</span>,<br>    event           String COMMENT <span class="hljs-string">&#x27;事件类型&#x27;</span>,<br>    event_date      <span class="hljs-type">Date</span> COMMENT <span class="hljs-string">&#x27;事件日期&#x27;</span>,<br>    city            String COMMENT <span class="hljs-string">&#x27;城市&#x27;</span>,<br>    age             UInt8 COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    ...<br>)<br>    engine <span class="hljs-operator">=</span> MergeTree<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMMDD(event_date)<br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> open_id<br>        SETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span><br>        COMMENT <span class="hljs-string">&#x27;用户事件表&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="查询-ClickHouse"><a href="#查询-ClickHouse" class="headerlink" title="查询 ClickHouse"></a>查询 ClickHouse</h5><p>可以使用 ClickHouse 的内置函数，轻松实现广告业务的事件分析平台所需要提供的事件分析、漏斗分析和留存分析三个功能。</p><p>事件分析可以用最朴素的 SQL 语句实现。例如，最近一周，北京地区的，发生过广告点击行为的用户，按照年龄段的分布，可以表述为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> cnt,<br>    event_date <span class="hljs-keyword">as</span> <span class="hljs-type">date</span>,<br>    age<br><span class="hljs-keyword">FROM</span> event_analytics<br><span class="hljs-keyword">WHERE</span><br>  event <span class="hljs-operator">=</span> &quot;click_ad&quot; <span class="hljs-keyword">AND</span><br>  city <span class="hljs-operator">=</span> &quot;beijing&quot; <span class="hljs-keyword">AND</span><br>  event_date <span class="hljs-operator">&gt;=</span> toDate(<span class="hljs-string">&#x27;2023-01-01&#x27;</span>) <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">&lt;=</span> toDate(<span class="hljs-string">&#x27;2023-01-08&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> (<span class="hljs-type">date</span>, age);<br></code></pre></td></tr></table></figure><p>留存分析使用 ClickHouse 提供的 <a href="https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/parametric-functions/#retention">retention</a> 函数。例如，查看广告后，计算点击广告的次日留存、7日留存可以表述为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    <span class="hljs-built_in">sum</span>(ret[<span class="hljs-number">1</span>]) <span class="hljs-keyword">AS</span> original,<br>    <span class="hljs-built_in">sum</span>(ret[<span class="hljs-number">2</span>]) <span class="hljs-keyword">AS</span> next_day_ret,<br>    <span class="hljs-built_in">sum</span>(ret[<span class="hljs-number">3</span>]) <span class="hljs-keyword">AS</span> seven_day_ret<br><span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span><br>  open_id,<br>  retention(<br>      event <span class="hljs-operator">=</span> &quot;view_ad&quot; <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2023-03-01&#x27;</span>),<br>      event <span class="hljs-operator">=</span> &quot;click_ad&quot; <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2023-03-02&#x27;</span>),<br>      event <span class="hljs-operator">=</span> &quot;click_ad&quot; <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2023-03-08&#x27;</span>)<br>      ) <span class="hljs-keyword">as</span> ret<br><span class="hljs-keyword">FROM</span> event_analytics<br><span class="hljs-keyword">WHERE</span>  <br>    event_date <span class="hljs-operator">&gt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-01&#x27;</span>) <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">&lt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-08&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> open_id);<br></code></pre></td></tr></table></figure><p>漏斗分析使用 ClickHouse 提供的 <a href="https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/parametric-functions/#windowfunnel">windowFunnel</a> 函数。例如，在 查看广告 -&gt; 点击广告，窗口期为2天的这个转化路径上，转化率的计算可以被表达为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    <span class="hljs-keyword">array</span>( sumIf(count, level <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span>), sumIf(count, level <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>) ) <span class="hljs-keyword">AS</span> funnel_uv,<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span><br>        level,<br>        <span class="hljs-built_in">count</span>() <span class="hljs-keyword">AS</span> count<br>    <span class="hljs-keyword">FROM</span> (<br>            <span class="hljs-keyword">SELECT</span><br>                open_id,<br>                windowFunnel(<span class="hljs-number">2</span>)(<br>                    event_date, event <span class="hljs-operator">=</span> &quot;view_ad&quot; <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">&gt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-01&#x27;</span>) <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">&lt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-08&#x27;</span>), event <span class="hljs-operator">=</span> &quot;click_ad&quot;) <span class="hljs-keyword">AS</span> level<br>            <span class="hljs-keyword">FROM</span><br>                event_analytics<br>            <span class="hljs-keyword">WHERE</span><br>                event_date <span class="hljs-operator">&gt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-01&#x27;</span>) <span class="hljs-keyword">AND</span> event_date <span class="hljs-operator">&lt;=</span> toDate(<span class="hljs-string">&#x27;2023-03-08&#x27;</span>)<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> open_id<br>        )<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> level<br>)<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在海量的数据集下使用 ClickHouse 自带 retention&#x2F;windowFunnel 等函数运行速度更快、更高效。提升了现有技术中用户留存率、漏斗分析的计算方式速度慢效率低的问题，进而达到了提高计算速度和计算效率的效果</p>]]></content>
    
    
    <categories>
      
      <category>system design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户画像平台设计</title>
    <link href="/posts/53612.html"/>
    <url>/posts/53612.html</url>
    
    <content type="html"><![CDATA[<p>不管在任何公司，我们都需要努力了解我们的用户，以便为他们提供更优质的服务。APP内容推荐需要根据用户特征来决定推送内容；促销活动需要针对不同的用户群体设计不同的活动方案；线上产品售卖也需要了解用户喜好，才能更好地把产品卖给用户。</p><p>为了实现这些目标，我建立了一个用户画像平台。本文将首先探讨平台的功能需求和标签体系定位，然后介绍平台的架构和具体功能实现。</p><span id="more"></span><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>用户画像平台主要关注分析场景，主要的使用者是公司各个业务线的运营人员和数据分析师。在平台的第一阶段，主要支持以下几个功能：</p><ol><li>标签定义：标签是描述用户的一个属性，比如「使用的设备类型」、「居住地」或「年龄范围」等。</li><li>用户群体选择：选择一组用户标签及其相应的标签值，找出符合条件的用户群体。比如，寻找「居住在上海，且使用安卓设备」的用户。</li><li>用户画像：对于选定的用户群体，查看其标签分布。例如，查看「居住在上海，且使用安卓设备」的用户的年龄范围分布。</li></ol><h4 id="标签体系"><a href="#标签体系" class="headerlink" title="标签体系"></a>标签体系</h4><p>在明确用户画像平台的使用场景和主要功能后，我们进一步回溯并确定用户标签体系。用户标签可以从两个方面进行分类：标签的实时性和标签的值类型。</p><p>首先考虑标签的实时性。由于用户画像平台的主要功能是「用户群体筛选」和「用户画像查看」，这两个功能并不需要极高的实时性，因此实时标签的优势并不明显。T+1的非实时标签完全能够满足数据分析师和运营人员的需求。</p><p>接着考虑标签的值类型，也就是标签是枚举的还是非枚举的。枚举标签，顾名思义，指的是标签值可以列举的标签，例如设备类型、网络类型、国家、城市等，这类标签在用户群体筛选中发挥了重要作用。非枚举标签则指标签值可以无限增长的标签，比如活跃天数、注册日期等，这类标签主要用于展示用户信息。考虑到「用户群体筛选」是各业务线最急迫的需求，我们在第一阶段决定不支持非枚举标签功能。</p><p>因此，我们确定了用户画像平台的第一阶段标签体系为非实时的枚举标签，主要为「用户群体筛选」和「用户画像查看」这两个查询功能服务。</p><h4 id="架构与实现"><a href="#架构与实现" class="headerlink" title="架构与实现"></a>架构与实现</h4><p>在架构上，用户画像平台分为两个模块：数据写入，分析查询。</p><h5 id="Roaringbitmap简介"><a href="#Roaringbitmap简介" class="headerlink" title="Roaringbitmap简介"></a><strong>Roaringbitmap</strong>简介</h5><p>接下来，我将简要介绍一种高效的位图压缩方法——Roaringbitmap。首先，我们来看一个问题：</p><p>假设我们有一个包含40亿个不重复且位于[0,2^32-1]范围内的整数集合，如何快速判断一个数是否在这个集合中？</p><p>如果我们直接存储这40亿个数，需要消耗约14.9GB的内存，这显然是不可接受的。因此，我们可以使用位图（bitmap）进行存储，即第0位表示数字0，第1位表示数字1，以此类推。如果一个数在原集合中，我们就将其对应的位图位设置为1，否则保持为0。这样，我们可以方便地查询结果，只需要占用512MB的内存，仅为原来的3.4%。但这种方法也存在缺点：例如，如果我们需要存储从1到5000万的5000万个连续整数，使用普通的位图仍需要消耗512MB的存储，显然，对于这种情况，我们有很大的优化空间。2016年，S. Chambi、D. Lemire、O. Kaser等人在论文《Better bitmap performance with Roaring bitmaps》和《Consistently faster and smaller compressed bitmaps with Roaring》中提出了Roaringbitmap，<strong>其主要特性是可以大幅度节省存储并提供快速的位图计算，因此，我们可以考虑使用它进行优化。对于前面提到的存储连续的5000万个整数，只需要几十KB</strong>。</p><p>Roaringbitmap的主要思想是：将32位无符号整数按照高16位进行分桶，即最多可能有2^16&#x3D;65536个桶，论文中称之为container。</p><p><img src="/posts/53612/2023-11-27-18-28XABB227qjVY0rlXL-20240228182643277.jpg" alt="img"></p><p>在存储数据时，根据数据的高16位找到对应的container（如果找不到，就会新建一个)，然后将低16位放入container中。换句话说，一个Roaringbitmap就是许多container的集合，具体的细节可以参阅 <a href="https://roaringbitmap.org/">https://roaringbitmap.org/</a></p><h5 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h5><p>我们的原始数据主要分为：</p><ul><li><strong>用户操作行为数据table_oper_raw</strong><br>这包括操作时间(oper_datetime)、用户标识ID(user_id)以及用户操作行为名称(oper_name)。例如，”2024-02-24 14:31:09|o4fdG4-Tm6-SO4fz9p3fiIQoK6a0|点击首页banner” 表示在2024-02-24 14:31:09，用户o4fdG4-Tm6-SO4fz9p3fiIQoK6a0点击了首页的banner</li></ul><table><thead><tr><th align="left">user_id</th><th align="left">oper_name</th><th align="left">oper_datetime</th><th align="left">…</th></tr></thead><tbody><tr><td align="left">o4fdG4-Tm6-SO4fz9p3fiIQoK6a0</td><td align="left">click_banner</td><td align="left">2024-02-24 14:31:09</td><td align="left">…</td></tr><tr><td align="left">o4fdG4-Tm6-SO4fz9p3fiIQoK6a0</td><td align="left">click_banner</td><td align="left">2024-02-24 14:32:20</td><td align="left">…</td></tr><tr><td align="left">o4fdG4-Tm6-SO4fz9p3fiIQoK6a0</td><td align="left">close_game</td><td align="left">2024-02-24 14:44:12</td><td align="left">…</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left"></td></tr></tbody></table><ul><li><strong>用户属性数据table_attribute_raw</strong><br>这表示用户在产品或用户画像中的属性，包含时间(datetime)、用户标识(user_id)以及各类用户属性字段（可能包括用户的新进渠道、所在地区等），例如“2024-02-24 14:31:09|o4fdG4-Tm6-SO4fz9p3fiIQoK6a0|小米商店|广东省”</li></ul><table><thead><tr><th align="left">user_id</th><th align="left">country</th><th align="left">city</th><th align="left">device_type</th><th align="left">age</th><th align="left">…</th></tr></thead><tbody><tr><td align="left">o4fdG4-Tm6-SO4fz9p3fiIQoK6a0</td><td align="left">China</td><td align="left">Beijing</td><td align="left">IOS</td><td align="left">10</td><td align="left">…</td></tr><tr><td align="left">o4fdG4-cZVBIUGtbOYvOPDKTxXLU</td><td align="left">China</td><td align="left">Shanghai</td><td align="left">Android</td><td align="left">5</td><td align="left">…</td></tr><tr><td align="left">o4fdG479Ln6OURYtGdZIYfQHMBHg</td><td align="left">United States</td><td align="left">New York</td><td align="left">Android</td><td align="left">12</td><td align="left">…</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>然后，将大宽表的数据进行”转置”，然后批量导入到 ClickHouse，如下表所示。表中的每一行代表一个标签实例（也就是标签和标签值的组合），例如”city &#x3D; Beijing”。此外，这一行还需要保存用户 id，这个 id 需要进行<strong>编码</strong>，将每个用户映射成<strong>唯一的id</strong>（32位的无符号整型），因为 Roaringbitmap 只能接受整型</p><table><thead><tr><th align="left">tag</th><th align="left">tag_item</th><th align="left">users</th></tr></thead><tbody><tr><td align="left">country</td><td align="left">China</td><td align="left">1</td></tr><tr><td align="left">country</td><td align="left">United States</td><td align="left">10</td></tr><tr><td align="left">city</td><td align="left">Beijing</td><td align="left">2</td></tr><tr><td align="left">city</td><td align="left">Shanghai</td><td align="left">1002</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>建表语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_user_tag<br>(<br>    `tag`         String comment <span class="hljs-string">&#x27;标签类别&#x27;</span>,<br>    `tag_item`    String comment <span class="hljs-string">&#x27;标签项&#x27;</span>,<br>    `p_day`       <span class="hljs-type">Date</span> comment <span class="hljs-string">&#x27;日期&#x27;</span>,<br>    `origin_user` String comment <span class="hljs-string">&#x27;用户 ID&#x27;</span><br>)<br>    ENGINE <span class="hljs-operator">=</span> MergeTree<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMMDD(p_day)<br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (tag, tag_item)<br>        SETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span><br>        COMMENT <span class="hljs-string">&#x27;用户标签表&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="Roaringbitmap压缩"><a href="#Roaringbitmap压缩" class="headerlink" title="Roaringbitmap压缩"></a><strong>Roaringbitmap</strong>压缩</h5><p>对于用户的属性&#x2F;操作数据，先建一个可以存放 bitmap 的表 table_user_tag_bitmap，根据使用场景，我设计 ClickHouse 表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_user_tag_bitmap<br>(<br>    `tag`      String comment <span class="hljs-string">&#x27;标签类别&#x27;</span>,<br>    `tag_item` String comment <span class="hljs-string">&#x27;标签项&#x27;</span>,<br>    `p_day`    <span class="hljs-type">Date</span> comment <span class="hljs-string">&#x27;日期&#x27;</span>,<br>    `users` AggregateFunction(groupBitmap, UInt64) comment <span class="hljs-string">&#x27;内部用户bitmap&#x27;</span><br>)<br>    ENGINE <span class="hljs-operator">=</span> AggregatingMergeTree<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMMDD(p_day)<br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (p_day, tag, tag_item)<br>        SETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span><br>        COMMENT <span class="hljs-string">&#x27;用户标签bitmap表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>当然这里面还可以增加其他字段以区分更细的粒度，比如 app_id 等用来区分不同应用，这里简化</p><p>然后，看表包含的字段</p><ul><li><code>tag</code> 代表标签， <code>tag_item</code> 代表标签值。因为在标签的圈选查询中，经常有 <code>tag = &quot;city&quot; AND tag_item = &quot;beijing&quot;</code> 的语句，我们将 <code>(tag, tag_item)</code> 作为主键，以提高查询效率。</li><li><code>p_day</code> 代表数据写入的日期，也作为 ClickHouse 的分片键。因为每天的标签数据都是全量导入，p_day 不仅可以用来区分标签版本，也方便我们批量删除历史数据。</li><li><code>users</code> 用来存放根据 <code>(tag, tag_item)</code> 聚合得到用户人群</li></ul><p>接着用聚合函数 <code>groupBitmapState</code> 对用户id进行压缩写入到 <code>table_user_tag_bitmap</code> 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_user_tag_bitmap<br><span class="hljs-keyword">SELECT</span> tag, tag_item, toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>), groupBitmapState(origin_user) <span class="hljs-keyword">as</span> users<br><span class="hljs-keyword">FROM</span> table_user_tag<br><span class="hljs-keyword">WHERE</span> p_day <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> tag, tag_item;<br></code></pre></td></tr></table></figure><p>这样原本很庞大的数据就被压缩成了几十行数据，每行包括标签和对应的用户id形成的bitmap：</p><p><img src="/posts/53612/image-20240228190040062.png" alt="image-20240228190040062"></p><h5 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h5><p>首先，简要地介绍下方案中常用的bitmap函数：</p><ul><li><p><strong>bitmapCardinality</strong><br>返回一个UInt64类型的数值，表示bitmap对象的基数。用来计算不同条件下的用户数，可以粗略理解为count(distinct)</p></li><li><p><strong>bitmapAnd</strong><br>为两个bitmap对象进行与操作，返回一个新的bitmap对象。可以理解为用来满足两个条件之间的and，但是参数只能是两个bitmap</p></li><li><p><strong>bitmapOr</strong><br>为两个bitmap对象进行或操作，返回一个新的bitmap对象。可以理解为用来满足两个条件之间的or，但是参数也同样只能是两个bitmap。</p></li></ul><p>如果是多个的情况，可以尝试使用groupBitmapMergeState，组合不同标签，圈选出用户人群。例如，我们想找出城市为北京、性别为女的用户。</p><p>我们只需首先找到城市为北京的用户人群（用 bitmap 表示），然后找到性别为女的用户人群，然后对它们进行 AND 操作即可。具体查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span><br>    (<br>        <span class="hljs-keyword">SELECT</span> groupBitmapAndState(users)<br>        <span class="hljs-keyword">FROM</span> table_user_tag_bitmap<br>        <span class="hljs-keyword">WHERE</span> <br>          <span class="hljs-keyword">AND</span> tag <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;city&#x27;</span><br>          <span class="hljs-keyword">AND</span> tag_item <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;beijing&#x27;</span><br>          <span class="hljs-keyword">AND</span> p_day <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>)<br>    ) <span class="hljs-keyword">AS</span> user_group_1,<br>    (<br>        <span class="hljs-keyword">SELECT</span> groupBitmapAndState(users)<br>        <span class="hljs-keyword">FROM</span> table_user_tag_bitmap<br>        <span class="hljs-keyword">WHERE</span> <br>          <span class="hljs-keyword">AND</span> tag <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;gender&#x27;</span><br>          <span class="hljs-keyword">AND</span> tag_item <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;female&#x27;</span><br>          <span class="hljs-keyword">AND</span> p_day <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>)<br>    ) <span class="hljs-keyword">AS</span> user_group_2<br><span class="hljs-keyword">SELECT</span> bitmapToArray(bitmapOr(user_group_1, user_group_2));<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/posts/53612/image-20240228192441076.png" alt="image-20240228192441076"></p><p>其中，groupBitmapMergeState 函数对通过 WHERE 筛除得到的任意个数的 bitmap (users) 进行 AND 操作，而 bitmapAnd&#x2F;bitmapOr 只能对两个 bitmap 进行操作。</p><h5 id="查看用户画像"><a href="#查看用户画像" class="headerlink" title="查看用户画像"></a>查看用户画像</h5><p>假如需要选取”北京的女性用户”这个人群，我们想要了解这个人群中使用设备的 benchmarkLevel。这种标签分布信息就是我们所说的用户画像。</p><p>这个查询的实现方式也是直观的。</p><ol><li>使用和上一节相同的步骤，得到”北京的女性用户”这个bitmap。</li><li>对这个人群进行分组，分别得到各个benchmarkLevel的bitmap。我们在这一步会得到更多的bitmap。</li><li>将步骤2中的每一个bitmap与步骤1中的bitmap进行AND操作，就可以得到”北京的女性用户”在”设备benchmarkLevel”上的分布情况。</li></ol><p>具体的实现方式如下查询所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span><br>(<br>    <span class="hljs-keyword">SELECT</span> groupBitmapMergeState(users)<br>    <span class="hljs-keyword">FROM</span> table_user_tag_bitmap<br>    <span class="hljs-keyword">WHERE</span> p_day <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>) <span class="hljs-keyword">AND</span> tag <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;city&#x27;</span> <span class="hljs-keyword">AND</span> tag_item <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;beijing&#x27;</span><br>) <span class="hljs-keyword">AS</span> user_group_1,<br>(<br>    <span class="hljs-keyword">SELECT</span> groupBitmapMergeState(users)<br>    <span class="hljs-keyword">FROM</span> table_user_tag_bitmap<br>    <span class="hljs-keyword">WHERE</span> p_day <span class="hljs-operator">=</span> toDate(<span class="hljs-string">&#x27;2024-02-28&#x27;</span>) <span class="hljs-keyword">AND</span> tag <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;gender&#x27;</span> <span class="hljs-keyword">AND</span> tag_item <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;female&#x27;</span><br>) <span class="hljs-keyword">AS</span> user_group_2,<br>(<br>    <span class="hljs-comment">-- 北京的女性用户</span><br>    <span class="hljs-keyword">SELECT</span> bitmapAnd(user_group_1, user_group_2)<br>) <span class="hljs-keyword">AS</span> filter_users<br><span class="hljs-keyword">SELECT</span><br>    bitmapCardinality(bitmapAnd(filter_users, group_by_users)) <span class="hljs-keyword">AS</span> count,<br>    tag,<br>    tag_item<br><span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span><br>    groupBitmapMergeState(users) <span class="hljs-keyword">AS</span> group_by_users,<br>    tag,<br>    tag_item<br><span class="hljs-keyword">FROM</span> table_user_tag_bitmap<br><span class="hljs-keyword">WHERE</span> tag <span class="hljs-operator">=</span> &quot;device_type&quot;<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> (tag, tag_item));<br></code></pre></td></tr></table></figure><p><img src="/posts/53612/image-20240229110703638.png" alt="image-20240229110703638"></p><h4 id="总结和反思"><a href="#总结和反思" class="headerlink" title="总结和反思"></a>总结和反思</h4><p>总的来看，这个方案的优势包括：</p><ol><li>存储体积小，极大地节省了存储空间；</li><li>查询速度快，通过使用bitmapCardinality、bitmapAnd、bitmapOr等位图函数，可以快速计算用户数量和满足某些条件的查询，将耗时的join操作转变为位图之间的计算；</li><li>适合进行灵活天数的标签查询；</li><li>更新方便，用户行为数据和用户属性数据分开存储，便于后续属性的添加和数据的回滚。</li></ol>]]></content>
    
    
    <categories>
      
      <category>system design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql面试题</title>
    <link href="/posts/6760.html"/>
    <url>/posts/6760.html</url>
    
    <content type="html"><![CDATA[<h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h3><ul><li><strong>数据保存在内存</strong><ul><li>优点： 存取速度快</li><li>缺点： 数据不能永久保存</li></ul></li><li><strong>数据保存在文件</strong><ul><li>优点： 数据永久保存</li><li>缺点：1、速度比内存操作慢，频繁的IO操作。2、查询数据不方便</li></ul></li><li><strong>数据保存在数据库</strong><ul><li>数据永久保存</li><li>使用SQL语句，查询方便效率高。</li><li>管理数据方便</li></ul></li></ul><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul><li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">作用：用于存取数据、查询、更新和管理关系数据库系统。<br></code></pre></td></tr></table></figure><h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul><li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li></ul><h3 id="MySql-Oracle，Sql-Service的区别"><a href="#MySql-Oracle，Sql-Service的区别" class="headerlink" title="MySql, Oracle，Sql Service的区别"></a>MySql, Oracle，Sql Service的区别</h3><ol><li>Sql Service只能在Windows上使用，而MySql和Oracle可以在其他系统上使用， 而且可以支持数据库不同系统之间的移植</li><li>MySql开源免费的，Sql Service和Oracle要钱。</li><li>我从小到大排序哈，MySql很小，Sql Service居中，Oracle最大</li><li>Oracle支持大并发量，大访问量，Sql Service还行，而MySql的话压力没这么大，因此现在的MySql的话最好是要使用集群或者缓存来搭配使用</li><li>Oracle支持多用户不同权限来进行操作，而MySql只要有登录权限就可操作全部数据库</li><li>安装所用的空间差别也是很大的，Mysql安装完后才几百M而Oracle有几G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。</li><li>做分页的话，MySql使用Limit，Sql Service使用top，Oracle使用row</li><li>Oracle没有自动增长类型，Mysql和Sql Service一般使用自动增长类型</li></ol><h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><ul><li>第一范式：每个列都不可以再拆分。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。<br></code></pre></td></tr></table></figure><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql\_install\_db脚本初始化。这些权限表分别user，db，table\_priv，columns\_priv和host。下面分别介绍一下这些表的结构和内容：<br></code></pre></td></tr></table></figure><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">有三种格式，<span class="hljs-keyword">statement</span>，<span class="hljs-keyword">row</span>和mixed。<br></code></pre></td></tr></table></figure><ul><li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">此外，新版的MySQL中对<span class="hljs-built_in">row</span>级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。<br></code></pre></td></tr></table></figure><h3 id="数据库经常使用的函数"><a href="#数据库经常使用的函数" class="headerlink" title="数据库经常使用的函数"></a>数据库经常使用的函数</h3><ul><li>count(*&#x2F;column)：返回行数</li><li>sum(column)： 返回指定列中唯一值的和</li><li>max(column)：返回指定列或表达式中的数值最大值</li><li>min(column)：返回指定列或表达式中的数值最小值</li><li>avg(column)：返回指定列或表达式中的数值平均值</li><li>date（Expression）: 返回指定表达式代表的日期值</li></ul><p>……</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h3><blockquote><table><thead><tr><th align="left">分类</th><th align="left">类型名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">整数类型</td><td align="left">tinyInt</td><td align="left">很小的整数(8位二进制)</td></tr><tr><td align="left">整数类型</td><td align="left">smallint</td><td align="left">小的整数(16位二进制)</td></tr><tr><td align="left">整数类型</td><td align="left">mediumint</td><td align="left">中等大小的整数(24位二进制)</td></tr><tr><td align="left">整数类型</td><td align="left">int(integer)</td><td align="left">普通大小的整数(32位二进制)</td></tr><tr><td align="left">小数类型</td><td align="left">float</td><td align="left">单精度浮点数</td></tr><tr><td align="left">小数类型</td><td align="left">double</td><td align="left">双精度浮点数</td></tr><tr><td align="left">小数类型</td><td align="left">decimal(m,d)</td><td align="left">压缩严格的定点数</td></tr><tr><td align="left">日期类型</td><td align="left">year</td><td align="left">YYYY 1901~2155</td></tr><tr><td align="left">日期类型</td><td align="left">time</td><td align="left">HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td align="left">日期类型</td><td align="left">date</td><td align="left">YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td align="left">日期类型</td><td align="left">datetime</td><td align="left">YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td align="left">日期类型</td><td align="left">timestamp</td><td align="left">YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">CHAR(M)</td><td align="left">M为0~255之间的整数</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">VARCHAR(M)</td><td align="left">M为0~65535之间的整数</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">TINYBLOB</td><td align="left">允许长度0~255字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">BLOB</td><td align="left">允许长度0~65535字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">MEDIUMBLOB</td><td align="left">允许长度0~167772150字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">LONGBLOB</td><td align="left">允许长度0~4294967295字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">TINYTEXT</td><td align="left">允许长度0~255字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">TEXT</td><td align="left">允许长度0~65535字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">MEDIUMTEXT</td><td align="left">允许长度0~167772150字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">LONGTEXT</td><td align="left">允许长度0~4294967295字节</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">VARBINARY(M)</td><td align="left">允许长度0~M个字节的变长字节字符串</td></tr><tr><td align="left">文本、二进制类型</td><td align="left">BINARY(M)</td><td align="left">允许长度0~M个字节的定长字节字符串</td></tr></tbody></table></blockquote><ul><li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p></li><li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。 DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。 而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB VARCHAR用于存储可变长字符串，它比定长类型更节省空间。 VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。 VARCHAR存储的内容超出设置的长度时，内容会被截断。 CHAR是定长的，根据定义的字符串长度分配足够的空间。 CHAR会根据需要使用空格进行填充方便比较。 CHAR适合存储很短的字符串，或者所有值都接近同一个长度。 CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p><strong>使用策略：</strong>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。 尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p></li><li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。 有时可以使用ENUM代替常用的字符串类型。 ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。 ENUM在内部存储时，其实存的是整数。 尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。 排序是按照内部存储的整数</p></li><li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime， 用整数保存时间戳通常不方便处理。 如果需要存储微妙，可以使用bigint存储。 看到这里，这道真题是不是就比较容易回答了。</p></li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><ul><li>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</li><li>常用的存储引擎有以下：<ul><li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul></li></ul><p><strong>MyISAM与InnoDB区别</strong></p><blockquote><table><thead><tr><th align="left">比较</th><th align="left">MyISAM</th><th align="left">Innodb</th></tr></thead><tbody><tr><td align="left">存储结构</td><td align="left">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td align="left">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td align="left">存储空间</td><td align="left">MyISAM可被压缩，存储空间较小</td><td align="left">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td align="left">可移植性、备份及恢复</td><td align="left">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td align="left">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td align="left">文件格式</td><td align="left">数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td align="left">数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td align="left">记录存储顺序</td><td align="left">按记录插入顺序保存</td><td align="left">按主键大小有序插入</td></tr><tr><td align="left">外键</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">事务</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td align="left">表级锁定</td><td align="left">行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td align="left">SELECT</td><td align="left">MyISAM更优</td><td align="left">–</td></tr><tr><td align="left">INSERT、UPDATE、DELETE</td><td align="left">–</td><td align="left">InnoDB更优</td></tr><tr><td align="left">select count(*)</td><td align="left">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td align="left"></td></tr><tr><td align="left">索引的实现方式</td><td align="left">B+树索引，myisam 是堆表</td><td align="left">B+树索引，Innodb 是索引组织表</td></tr><tr><td align="left">哈希索引</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">全文索引</td><td align="left">支持</td><td align="left">不支持</td></tr></tbody></table></blockquote><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><ul><li>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</li><li>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</li><li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul><li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li><li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li><li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li></ul><h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><p><strong>索引的优点</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p><strong>索引的缺点</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增&#x2F;改&#x2F;删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><h3 id="怎么创建索引的，有什么好处，有哪些分类"><a href="#怎么创建索引的，有什么好处，有哪些分类" class="headerlink" title="怎么创建索引的，有什么好处，有哪些分类"></a>怎么创建索引的，有什么好处，有哪些分类</h3><ol><li>创建索引的语法：create index depe_unique_ide on depe(dept_no) tablespace idx_</li><li>创建索引可以增加查询速度，唯一索引可以保证数据库列的一致性，可以确定表与表之间的连接</li><li>索引的分类：             逻辑分类：单列索引，复合索引，唯一索引，非唯一索引，函数索引             物理分类：B数索引，反向键索引，位图索引</li></ol><h3 id="简述有哪些索引和作用"><a href="#简述有哪些索引和作用" class="headerlink" title="简述有哪些索引和作用"></a>简述有哪些索引和作用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">索引的作用：通过索引可以大大的提高数据库的检索速度，改善数据库性能<br></code></pre></td></tr></table></figure><ol><li>唯一索引：不允许有俩行具有相同的值</li><li>主键索引：为了保持数据库表与表之间的关系</li><li>聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。</li><li>非聚集索引：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致</li><li>复合索引：在创建索引时，并不是只能对一列进行创建索引，可以与主键一样，讲多个组合为索引</li><li>全文索引： 全文索引为在字符串数据中进行复杂的词搜索提供有效支持</li></ol><h3 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h3><ol><li>当数据多且字段值有相同的值得时候用普通索引。</li><li>当字段多且字段值没有重复的时候用唯一索引。</li><li>当有多个字段名都经常被查询的话用复合索引。</li><li>普通索引不支持空值，唯一索引支持空值。</li><li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li><li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li><li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li><li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li><li>所以，会对增删改的执行减缓速度，</li><li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li><li>更新太频繁地字段不适合创建索引。</li><li>不会出现在where条件中的字段不该建立索引。</li></ol><h3 id="主键索引与唯一索引的区别"><a href="#主键索引与唯一索引的区别" class="headerlink" title="主键索引与唯一索引的区别"></a>主键索引与唯一索引的区别</h3><ol><li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li><li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li><li>唯一性索引列允许空值，而主键列不允许为空值。</li><li>主键列在创建时，已经默认为空值 ++   唯一索引了。</li><li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li><li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。</li><li>主键可以被其他表引用为外键，而唯一索引不能。  ？</li></ol><h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li></ul><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li></ul><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li></ul><h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul><li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li></ul><p><strong>1、B树索引</strong></p><ul><li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</li></ul><p><img src="/posts/6760/640-20240329150913182.jpeg" alt="图片">在这里插入图片描述</p><ul><li>查询方式：<ul><li>主键索引区:PI(关联保存的时数据的地址)按主键查询,</li><li>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</li></ul></li><li>B+tree性质：<ol><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ol></li></ul><p><strong>2、哈希索引</strong></p><ul><li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</li></ul><p><img src="/posts/6760/640.jpeg" alt="图片">在这里插入图片描述</p><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul><li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li><li>索引的原理很简单，就是把无序的数据变成有序的查询<ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol></li></ul><h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul><li>索引算法有 BTree算法和Hash算法</li></ul><p><strong>1、BTree算法</strong></p><ul><li><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-comment">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;jack%&#x27;</span>; <br><span class="hljs-comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%jack&#x27;</span>; <br></code></pre></td></tr></table></figure></li></ul><p><strong>2、Hash算法</strong></p><ul><li>Hash Hash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li></ul><h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ol><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ol><h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul><li>索引虽好，但也不是无限制的使用，最好符合一下几个原则</li></ul><ol><li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>较频繁作为查询条件的字段才去创建索引</li><li>更新频繁字段不适合创建索引</li><li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li>定义有外键的数据列一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ol><h3 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h3><ul><li><p>第一种方式：在执行CREATE TABLE时创建索引</p><p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p></li><li><p>第二种方式：使用ALTER TABLE命令去增加索引</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (column_list);<br></code></pre></td></tr></table></figure><ul><li>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</li><li>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</li><li>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</li></ul></li><li><p>第三种方式：使用CREATE INDEX命令创建</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> (column_list);<br></code></pre></td></tr></table></figure><ul><li>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</li></ul></li></ul><h3 id="如何删除索引"><a href="#如何删除索引" class="headerlink" title="如何删除索引"></a>如何删除索引</h3><ul><li><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">复制代码<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> name;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> id_card;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index <span class="hljs-keyword">drop</span> <span class="hljs-keyword">KEY</span> information;<br></code></pre></td></tr></table></figure></li><li><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p></li></ul><p><img src="/posts/6760/640-20240329150913185.jpeg" alt="图片">在这里插入图片描述</p><ul><li><p>需要取消自增长再行删除：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> user_index<br><span class="hljs-comment">-- 重新定义字段</span><br>MODIFY id <span class="hljs-type">int</span>,<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">PRIMARY KEY</span><br></code></pre></td></tr></table></figure></li><li><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p></li></ul><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。<br></code></pre></td></tr></table></figure><ul><li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I&#x2F;O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><ul><li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</li></ul><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</li><li>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</li><li>实操的难度：在于前缀截取的长度。</li><li>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</li></ul><h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li><li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li></ul><p><img src="/posts/6760/640-20240329150913205.jpeg" alt="图片">在这里插入图片描述</p><h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul><li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li></ul><h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul><li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li></ul><h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><ul><li>首先要知道Hash索引和B+树索引的底层实现原理：</li><li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li></ul><p><strong>那么可以看出他们有以下的不同：</strong></p><ul><li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li><li>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</li><li>hash索引不支持使用索引进行排序，原理同上。</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li><li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li><li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li><li>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</li></ul><h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul><li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><h3 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><ul><li>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。<br></code></pre></td></tr></table></figure><h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">何时使用聚簇索引与非聚簇索引<br></code></pre></td></tr></table></figure><p><img src="/posts/6760/640-20240329150913180.jpeg" alt="图片">在这里插入图片描述</p><h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul><li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li><li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li></ul><h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul><li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li></ul><p><strong>具体原因为:</strong></p><ul><li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li><li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul><li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务最经典也经常被拿出来说例子就是转账了。</li><li>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</li></ul><h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul><li>关系性数据库需要遵循ACID规则，具体内容如下：</li></ul><p><img src="/posts/6760/640-20240329150913217.jpeg" alt="图片">在这里插入图片描述</p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻影读</th></tr></thead><tbody><tr><td align="left">READ-UNCOMMITTED</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">READ-COMMITTED</td><td align="left">×</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">REPEATABLE-READ</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">SERIALIZABLE</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p><strong>注意：</strong></p><ul><li>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</li><li>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</li><li>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</li><li>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h3><ul><li>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</li><li>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</li></ul><h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><ul><li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁就是让多个线程同时获取一个锁。</li><li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排它锁也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><ul><li>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</li><li><strong>MyISAM和InnoDB存储引擎使用的锁：</strong><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul></li></ul><p><strong>行级锁，表级锁和页级锁对比</strong></p><ul><li><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<ul><li>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul></li><li><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<ul><li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul></li><li><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<ul><li>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul></li></ul><h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><ul><li>InnoDB是基于索引来完成行锁</li><li>例: select * from tab_with_index where id &#x3D; 1 for update;</li><li>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</li></ul><h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h3><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p><strong>相关知识点：</strong></p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li><li>常见的解决死锁的方法<ul><li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果业务不好处理,可以用分布式事务锁或者使用乐观锁<br></code></pre></td></tr></table></figure><h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul><li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p></li><li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">复制代码<span class="hljs-operator">/</span><span class="hljs-operator">/</span>核心<span class="hljs-keyword">SQL</span>,主要靠<span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br><span class="hljs-keyword">select</span> status <span class="hljs-keyword">from</span> t_goods <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码//核心<span class="hljs-keyword">SQL</span><br><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> x=x+<span class="hljs-number">1</span>, version=<span class="hljs-keyword">version</span>+<span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id=#&#123;id&#125; <span class="hljs-keyword">and</span> version=#&#123;<span class="hljs-keyword">version</span>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><strong>两种锁的使用场景</strong></p><ul><li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li><li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h3><ul><li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li><li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li></ul><h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h3><p><strong>视图的特点如下:</strong></p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">视图根本用途：简化<span class="hljs-keyword">sql</span>查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。<br></code></pre></td></tr></table></figure><p><strong>下面是视图的常见使用场景：</strong></p><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li><li>使用表的组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h3><ul><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li></ul><h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><ul><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li></ul><p><strong>优点</strong></p><ol><li>存储过程是预编译过的，执行效率高。</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li><li>安全性高，执行存储过程需要有一定权限的用户。</li><li>存储过程可以重复使用，减少数据库开发人员的工作量。</li></ol><p><strong>缺点</strong></p><ol><li>调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。</li><li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li><li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li><li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li></ol><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h3><ul><li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</li></ul><p><strong>使用场景</strong></p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h3><p><strong>在MySQL数据库中有如下六种触发器：</strong></p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><ul><li><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p></li><li><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p></li><li><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p></li><li><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p></li></ul><h3 id="SQL语句的语法顺序："><a href="#SQL语句的语法顺序：" class="headerlink" title="SQL语句的语法顺序："></a>SQL语句的语法顺序：</h3><ol><li>SELECT</li><li>FROM</li><li>JOIN</li><li>ON</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>UNION</li><li>ORDER BY</li><li>LIMIT</li></ol><h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul><li><p>交叉连接（CROSS JOIN）</p></li><li><p>内连接（INNER JOIN）</p></li><li><p>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</p></li><li><p>联合查询（UNION与UNION ALL）</p></li><li><p>全连接（FULL JOIN）</p></li><li><p>交叉连接（CROSS JOIN）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A,B(,C)或者<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> B (<span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>）<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A,B <span class="hljs-keyword">WHERE</span> A.id=B.id或者<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id=B.id多表中同时符合某种条件的数据记录的集合，<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>可以缩写为<span class="hljs-keyword">JOIN</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>内连接分为三类</strong></p><ul><li>等值连接：ON A.id&#x3D;B.id</li><li>不等值连接：ON A.id &gt; B.id</li><li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id&#x3D;T2.pid</li></ul><p><strong>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</strong></p><ul><li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li><li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li></ul><p><strong>联合查询（UNION与UNION ALL）</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">n1ql<br>复制代码<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> B <span class="hljs-keyword">UNION</span> ...<br></code></pre></td></tr></table></figure><ul><li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><p><strong>全连接（FULL JOIN）</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">复制代码<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id=B.id UNIONSELECT * <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id=B.id<br></code></pre></td></tr></table></figure><ul><li>MySQL不支持全连接</li><li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><h4 id="表连接面试题"><a href="#表连接面试题" class="headerlink" title="表连接面试题"></a>表连接面试题</h4><h5 id="有2张表。"><a href="#有2张表。" class="headerlink" title="有2张表。"></a>有2张表。</h5><ul><li>1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录</li></ul><p><strong>R表</strong></p><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td></tr></tbody></table><p><strong>S表</strong></p><table><thead><tr><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">c4</td><td align="left">d3</td></tr></tbody></table><h5 id="1、交叉连接-笛卡尔积"><a href="#1、交叉连接-笛卡尔积" class="headerlink" title="1、交叉连接(笛卡尔积)"></a>1、交叉连接(笛卡尔积)</h5><ul><li>SQL</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">复制代码<span class="hljs-built_in">select</span> <span class="hljs-built_in">r</span>.*,s.* from <span class="hljs-built_in">r</span>,s<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c4</td><td align="left">d3</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c4</td><td align="left">d3</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td><td align="left">c4</td><td align="left">d3</td></tr></tbody></table><h5 id="2、内连接结果"><a href="#2、内连接结果" class="headerlink" title="2、内连接结果"></a>2、内连接结果</h5><ul><li>SQL</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">复制代码<span class="hljs-keyword">select</span> r.*,s.* <span class="hljs-keyword">from</span> r <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> s <span class="hljs-keyword">on</span> r.c=s.c<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c2</td><td align="left">d2</td></tr></tbody></table><h5 id="3、左连接结果"><a href="#3、左连接结果" class="headerlink" title="3、左连接结果"></a>3、左连接结果</h5><ul><li>SQL</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">复制代码<span class="hljs-keyword">select</span> r.*,s.* <span class="hljs-keyword">from</span> r <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> s <span class="hljs-keyword">on</span> r.c=s.c<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="4、右连接结果"><a href="#4、右连接结果" class="headerlink" title="4、右连接结果"></a>4、右连接结果</h5><ul><li>SQL</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">复制代码<span class="hljs-keyword">select</span> r.*,s.* <span class="hljs-keyword">from</span> r <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> s <span class="hljs-keyword">on</span> r.c=s.c<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">c4</td><td align="left">d3</td></tr></tbody></table><h5 id="5、全表连接的结果（MySql不支持，Oracle支持）"><a href="#5、全表连接的结果（MySql不支持，Oracle支持）" class="headerlink" title="5、全表连接的结果（MySql不支持，Oracle支持）"></a>5、全表连接的结果（MySql不支持，Oracle支持）</h5><ul><li>SQL</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">select</span> r.*,s.* <span class="hljs-keyword">from</span> r <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> s <span class="hljs-keyword">on</span> r.c=s.c<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">C</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">a1</td><td align="left">b1</td><td align="left">c1</td><td align="left">c1</td><td align="left">d1</td></tr><tr><td align="left">a2</td><td align="left">b2</td><td align="left">c2</td><td align="left">c2</td><td align="left">d2</td></tr><tr><td align="left">a3</td><td align="left">b3</td><td align="left">c3</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">c4</td><td align="left">d3</td></tr></tbody></table><h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h3><ol><li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li><li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li></ol><h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h3><ul><li>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。<ol><li>如果查询的两个表大小相当，那么用in和exists差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol></li></ul><h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p><ul><li>char表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于char来说，最多能存放的字符个数为255，和编码无关</li></ul><p><strong>varchar的特点</strong></p><ul><li>varchar表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于varchar来说，最多能存放的字符个数为65532</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">总之，结合性能角度（<span class="hljs-type">char</span>更快）和节省磁盘空间角度（<span class="hljs-type">varchar</span>更小），具体情况还需具体来设计数据库才是妥当的做法。<br></code></pre></td></tr></table></figure><h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h3><ul><li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</li></ul><h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h3><ul><li>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</li><li>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</li></ul><h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h3><ul><li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</li></ul><h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul><li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li><li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li><li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li></ul><h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h3><ul><li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul><h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><ul><li>三者都表示删除，但是三者有一些差别：</li></ul><table><thead><tr><th align="left">比较</th><th align="left">Delete</th><th align="left">Truncate</th><th align="left">Drop</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left">属于DML</td><td align="left">属于DDL</td><td align="left">属于DDL</td></tr><tr><td align="left">回滚</td><td align="left">可回滚</td><td align="left">不可回滚</td><td align="left">不可回滚</td></tr><tr><td align="left">删除内容</td><td align="left">表结构还在，删除表的全部或者一部分数据行</td><td align="left">表结构还在，删除表中的所有数据</td><td align="left">从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td align="left">删除速度</td><td align="left">删除速度慢，需要逐行删除</td><td align="left">删除速度快</td><td align="left">删除速度最快</td></tr></tbody></table><ul><li>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</li></ul><h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h3><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="说出一些数据库优化方面的经验"><a href="#说出一些数据库优化方面的经验" class="headerlink" title="说出一些数据库优化方面的经验?"></a>说出一些数据库优化方面的经验?</h3><ol><li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li><li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li><li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li><li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li><li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li></ol><h3 id="怎么优化SQL查询语句吗"><a href="#怎么优化SQL查询语句吗" class="headerlink" title="怎么优化SQL查询语句吗"></a>怎么优化SQL查询语句吗</h3><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li><li>用索引可以提高查询</li><li>SELECT子句中避免使用*号，尽量全部大写SQL</li><li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li><li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描</li></ol><h3 id="你怎么知道SQL语句性能是高还是低"><a href="#你怎么知道SQL语句性能是高还是低" class="headerlink" title="你怎么知道SQL语句性能是高还是低"></a>你怎么知道SQL语句性能是高还是低</h3><ol><li>查看SQL的执行时间</li><li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li></ol><h3 id="SQL的执行顺序"><a href="#SQL的执行顺序" class="headerlink" title="SQL的执行顺序"></a>SQL的执行顺序</h3><ol><li>FROM：将数据从硬盘加载到数据缓冲区，方便对接下来的数据进行操作。</li><li>WHERE：从基表或视图中选择满足条件的元组。（不能使用聚合函数）</li><li>JOIN（如right left 右连接——-从右边表中读取某个元组，并且找到该元组在左边表中对应的元组或元组集）</li><li>ON：join on实现多表连接查询，推荐该种方式进行多表查询，不使用子查询。</li><li>GROUP BY：分组，一般和聚合函数一起使用。</li><li>HAVING：在元组的基础上进行筛选，选出符合条件的元组。（一般与GROUP BY进行连用）</li><li>SELECT：查询到得所有元组需要罗列的哪些列。</li><li>DISTINCT：去重的功能。</li><li>UNION：将多个查询结果合并（默认去掉重复的记录）。</li><li>ORDER BY：进行相应的排序。</li><li>LIMIT 1：显示输出一条数据记录（元组）</li></ol><h3 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><ul><li>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</li></ul><p><img src="/posts/6760/640-20240329150913224.jpeg" alt="图片">在这里插入图片描述</p><ul><li><p>执行计划包含的信息</p><p>id</p><p>有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>id相同执行顺序由上至下。</li><li>id不同，id值越大优先级越高，越先被执行。</li><li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul></li></ul><p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">不包含任何子查询或union等查询</td></tr><tr><td align="left">2</td><td align="left">PRIMARY</td><td align="left">包含子查询最外层查询就显示为 PRIMARY</td></tr><tr><td align="left">3</td><td align="left">SUBQUERY</td><td align="left">在select或 where字句中包含的查询</td></tr><tr><td align="left">4</td><td align="left">DERIVED</td><td align="left">from字句中包含的查询</td></tr><tr><td align="left">5</td><td align="left">UNION</td><td align="left">出现在union后的查询语句中</td></tr><tr><td align="left">6</td><td align="left">UNION RESULT</td><td align="left">从UNION中获取结果集，例如上文的第三个例子</td></tr></tbody></table><ul><li><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tmp (<br>    id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> AUTO_INCREMENT,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">PRIMARY KEY</span> (id)<br>) engine = innodb<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> key (id) partitions <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型<ul><li>ALL 扫描全表数据</li><li>index 遍历索引</li><li>range 索引范围查找</li><li>index_subquery 在子查询中使用 ref</li><li>unique_subquery 在子查询中使用 eq_ref</li><li>ref_or_null 对Null进行索引的优化的 ref</li><li>fulltext 使用全文索引</li><li>ref 使用非唯一索引查找数据</li><li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li></ul></li><li><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</li><li><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</li><li><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</li><li><strong>key_length</strong> 索引长度</li><li><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li><li><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</li><li><strong>extra</strong> 的信息非常丰富，常见的有：<ol><li>Using index 使用覆盖索引</li><li>Using where 使用了用where子句来过滤结果集</li><li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li><li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li></ol></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码【推荐】<span class="hljs-keyword">SQL</span>性能优化的目标：至少要达到 range 级别，要求是<span class="hljs-keyword">ref</span>级别，如果可以是consts最好。 <br>说明： <br><span class="hljs-number">1</span>） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 <br><span class="hljs-number">2</span>） <span class="hljs-keyword">ref</span> 指的是使用普通的索引（normal <span class="hljs-keyword">index</span>）。 <br><span class="hljs-number">3</span>） range 对索引进行范围检索。 <br>反例：<span class="hljs-keyword">explain</span>表的结果，<span class="hljs-keyword">type</span>=<span class="hljs-keyword">index</span>，索引物理文件全扫描，速度非常慢，这个<span class="hljs-keyword">index</span>级别比较range还低，与全表扫描是小巫见大巫。<br></code></pre></td></tr></table></figure><h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h3><ol><li>应用服务器与数据库服务器建立一个连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ol><p><img src="/posts/6760/640-20240329150913200.jpeg" alt="图片">在这里插入图片描述</p><h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p><strong>超大的分页一般从两个方向上来解决.</strong></p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p><h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h3><ul><li><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><p>SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</p></li><li><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><p>SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.</p></li><li><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><p>SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行</p></li><li><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p></li></ul><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><ul><li>开启慢查询日志</li><li>配置项：<code>slow_query_log</code></li><li>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</li><li>设置临界时间</li><li>配置项：<code>long_query_time</code></li><li>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</li><li>设置：<code>set long_query_time=0.5</code></li><li>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</li><li>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</li></ul><h3 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><ul><li>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</li><li>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</li></ul><p><strong>所以优化也是针对这三个方向来的，</strong></p><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul><li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li></ul><h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul><li>推荐使用自增ID，不要使用UUID。</li><li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。<br></code></pre></td></tr></table></figure><h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul><li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li></ul><h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul><li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li></ul><h3 id="如何优化查询过程中的数据访问"><a href="#如何优化查询过程中的数据访问" class="headerlink" title="如何优化查询过程中的数据访问"></a>如何优化查询过程中的数据访问</h3><ul><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行</li><li>避免犯如下SQL语句错误</li><li>避免查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h3 id="如何优化长难的查询语句"><a href="#如何优化长难的查询语句" class="headerlink" title="如何优化长难的查询语句"></a>如何优化长难的查询语句</h3><ul><li>分析是一个复杂查询还是多个简单查询速度快</li><li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>将一个大的查询分为多个小的相同的查询</li><li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>分解关联查询，让缓存的效率更高。</li><li>执行单个查询可以减少锁的竞争。</li><li>在应用层做关联更容易对数据库进行拆分。</li><li>查询效率会有大幅提升。</li><li>较少冗余记录的查询。</li></ul><h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h3><ul><li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>MyISAM中，没有任何where条件的count(*)非常快。</li><li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>可以使用explain查询近似值，用近似值替代count(*)</li><li>增加汇总表</li><li>使用缓存</li></ul><h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul><li>用关联查询替代</li><li>优化GROUP BY和DISTINCT</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h3><ul><li>UNION ALL的效率高于UNION</li></ul><h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h3><ul><li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li></ul><h3 id="SQL语句优化的一些方法"><a href="#SQL语句优化的一些方法" class="headerlink" title="SQL语句优化的一些方法"></a>SQL语句优化的一些方法</h3><ul><li><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">复制代码<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span><br>-- 可以在num上设置默认值<span class="hljs-number">0</span>，确保表中num列没有<span class="hljs-literal">null</span>值，然后这样查询：<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p></li><li><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">复制代码<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">or</span> num<span class="hljs-operator">=</span><span class="hljs-number">20</span><br><span class="hljs-comment">-- 可以这样查询：</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">复制代码select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <br><span class="hljs-comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span><br>select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p></li><li><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">复制代码<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-variable">@num</span><br><span class="hljs-comment">-- 可以改为强制查询使用索引：</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">with</span>(index(索引名)) <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-variable">@num</span><br></code></pre></td></tr></table></figure></li><li><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">复制代码select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num/<span class="hljs-number">2</span>=<span class="hljs-number">100</span><br><span class="hljs-comment">-- 应改为:</span><br>select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num=<span class="hljs-number">100</span>*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">复制代码<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> substring(<span class="hljs-type">name</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)=’abc’<br><span class="hljs-comment">-- name以abc开头的id应改为:</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> ‘abc%’<br></code></pre></td></tr></table></figure></li><li><p>10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p></li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。<br></code></pre></td></tr></table></figure><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul><li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li><li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li></ul><p><strong>将字段很多的表分解成多个表</strong></p><ul><li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li><li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li></ul><p><strong>增加中间表</strong></p><ul><li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li><li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li></ul><p><strong>增加冗余字段</strong></p><ul><li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li><li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li></ul><p><strong>注意：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。<br></code></pre></td></tr></table></figure><h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul><li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li><li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li><li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li><li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li></ul><h3 id="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li><strong>读&#x2F;写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li></ol><p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p><h4 id="1、垂直分区"><a href="#1、垂直分区" class="headerlink" title="1、垂直分区"></a>1、垂直分区</h4><ul><li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li><li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li></ul><p><img src="/posts/6760/640-20240329150913215.jpeg" alt="图片">在这里插入图片描述</p><ul><li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li></ul><h4 id="2、垂直分表"><a href="#2、垂直分表" class="headerlink" title="2、垂直分表"></a>2、垂直分表</h4><ul><li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li></ul><p><img src="/posts/6760/640-20240329150913220.jpeg" alt="图片">在这里插入图片描述</p><p><strong>适用场景</strong></p><ul><li>1、如果一个表中某些列常用，另外一些列不常用</li><li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I&#x2F;O次数</li></ul><p><strong>缺点</strong></p><ul><li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li><li>对于应用层来说，逻辑算法增加开发成本</li><li>管理冗余列，查询所有数据需要join操作</li></ul><h4 id="3、水平分区"><a href="#3、水平分区" class="headerlink" title="3、水平分区"></a>3、水平分区</h4><ul><li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li><li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li></ul><p><img src="/posts/6760/640-20240329150913235.jpeg" alt="图片">在这里插入图片描述</p><ul><li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li><li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">《<span class="hljs-variable">Java</span>工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>。<br></code></pre></td></tr></table></figure><h4 id="4、水平分表："><a href="#4、水平分表：" class="headerlink" title="4、水平分表："></a>4、水平分表：</h4><ul><li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li></ul><p><img src="/posts/6760/640-20240329150913354.jpeg" alt="图片">在这里插入图片描述</p><p><strong>适用场景</strong></p><ul><li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li><li>2、需要把数据存放在多个介质上。</li></ul><p><strong>水平切分的缺点</strong></p><ul><li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li><li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li></ul><h4 id="数据库分片的两种常见方案："><a href="#数据库分片的两种常见方案：" class="headerlink" title="数据库分片的两种常见方案："></a>数据库分片的两种常见方案：</h4><ul><li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h4 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h4><ul><li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库join</strong></p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p><strong>ID问题</strong></p></li><li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p><ul><li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li></ul></li><li><p><strong>跨分片的排序分页问题</strong></p><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="/posts/6760/640-20240329150913227.jpeg" alt="图片">在这里插入图片描述</p></li></ul><h3 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h3><ul><li>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li></ul><h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol><h4 id="MySQL主从复制解决的问题"><a href="#MySQL主从复制解决的问题" class="headerlink" title="MySQL主从复制解决的问题"></a>MySQL主从复制解决的问题</h4><ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul><h4 id="MySQL主从复制工作原理"><a href="#MySQL主从复制工作原理" class="headerlink" title="MySQL主从复制工作原理"></a>MySQL主从复制工作原理</h4><ul><li>在主库上把数据更高记录到二进制日志</li><li>从库将主库的日志复制到自己的中继日志</li><li>从库读取中继日志的事件，将其重放到从库数据中</li></ul><h4 id="基本原理流程，3个线程以及之间的关联"><a href="#基本原理流程，3个线程以及之间的关联" class="headerlink" title="基本原理流程，3个线程以及之间的关联"></a>基本原理流程，3个线程以及之间的关联</h4><ul><li><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</li><li><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</li><li><strong>从</strong>：sql执行线程——执行relay log中的语句；</li></ul><h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p><img src="/posts/6760/640-20240329150913353.jpeg" alt="图片">在这里插入图片描述</p><ul><li>Binary log：主数据库的二进制日志</li><li>Relay log：从服务器的中继日志</li></ul><ol><li>master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</li><li>salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程最终的目的是将这些事件写入到中继日志中。</li><li>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li></ol><h3 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h3><ul><li>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</li></ul><p><strong>方案一</strong></p><ul><li>使用mysql-proxy代理</li><li>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</li><li>缺点：降低性能， 不支持事务</li></ul><p><strong>方案二</strong></p><ul><li>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。</li><li>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert&#x2F;update&#x2F;delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</li></ul><p><strong>方案三</strong></p><ul><li>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</li><li>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</li></ul><h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><ul><li><strong>(1)备份计划</strong><ul><li>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</li><li>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</li></ul></li><li><strong>(2)备份恢复时间</strong><ul><li>物理备份恢复快，逻辑备份恢复慢</li><li>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</li><li>20G的2分钟（mysqldump）</li><li>80G的30分钟(mysqldump)</li><li>111G的30分钟（mysqldump)</li><li>288G的3小时（xtra)</li><li>3T的4小时（xtra)</li><li>逻辑导入时间一般是备份时间的5倍以上</li></ul></li><li><strong>(3)备份恢复失败如何处理</strong><ul><li>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</li></ul></li></ul><p><strong>(4)mysqldump和xtrabackup实现原理</strong></p><ul><li><p>mysqldump</p><p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION &#x2F;*!40100 WITH CONSISTENTSNAPSHOT *&#x2F;)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data&#x3D;1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p></li><li><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p></li><li><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p></li></ul><h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>1 修复前将mysql服务停止。</li><li>2 打开命令行方式，然后进入到mysql的&#x2F;bin目录。</li><li>3 执行myisamchk –recover 数据库所在路径&#x2F;*.MYI</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">使用repair <span class="hljs-selector-tag">table</span> 或者 OPTIMIZE <span class="hljs-selector-tag">table</span>命令来修复，REPAIR <span class="hljs-selector-tag">TABLE</span> <span class="hljs-selector-tag">table</span>\_name 修复表 OPTIMIZE <span class="hljs-selector-tag">TABLE</span> <span class="hljs-selector-tag">table</span>\_name 优化表 REPAIR <span class="hljs-selector-tag">TABLE</span> 用于修复被破坏的表。 OPTIMIZE <span class="hljs-selector-tag">TABLE</span> 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE <span class="hljs-selector-tag">TABLE</span>命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM面试五十问</title>
    <link href="/posts/55776.html"/>
    <url>/posts/55776.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1.什么是JVM?"></a>1.什么是JVM?</h2><p>JVM——Java虚拟机，它是Java实现平台无关性的基石。</p><p>Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。</p><p><img src="/posts/55776/640.png" alt="图片">Java语言编译运行</p><p>同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。</p><p><img src="/posts/55776/640-20240321152409506.png" alt="图片">JVM跨语言</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="2-能说一下JVM的内存区域吗？"><a href="#2-能说一下JVM的内存区域吗？" class="headerlink" title="2.能说一下JVM的内存区域吗？"></a>2.能说一下JVM的内存区域吗？</h2><p>JVM内存区域最粗略的划分可以分为<code>堆</code>和<code>栈</code>，当然，按照虚拟机规范，可以划分为以下几个区域：</p><p><img src="/posts/55776/640-20240321152409541.png" alt="图片">Java虚拟机运行时数据区</p><p>JVM内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><p><strong>1、程序计数器</strong></p><p>程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。</p><p>它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>2、Java虚拟机栈</strong></p><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p><p>Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。</p><p><img src="/posts/55776/640-20240321152409574.png" alt="图片">Java虚拟机栈</p><p><strong>3、本地方法栈</strong></p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。</p><p><strong>4、Java堆</strong></p><p>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。</p><p><img src="/posts/55776/640-20240321152409490.png" alt="图片">Java 堆内存结构</p><p><strong>5.方法区</strong></p><p>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。</p><h2 id="3-说一下JDK1-6、1-7、1-8内存区域的变化？"><a href="#3-说一下JDK1-6、1-7、1-8内存区域的变化？" class="headerlink" title="3.说一下JDK1.6、1.7、1.8内存区域的变化？"></a>3.说一下JDK1.6、1.7、1.8内存区域的变化？</h2><p>JDK1.6、1.7&#x2F;1.8内存区域发生了变化，主要体现在方法区的实现：</p><ul><li>JDK1.6使用永久代实现方法区：</li></ul><p><img src="/posts/55776/640-20240321152409563.png" alt="图片">JDK 1.6内存区域</p><ul><li>JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上</li></ul><p><img src="/posts/55776/640-20240321152409579.png" alt="图片">JDK 1.7内存区域</p><ul><li><p>在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</p><p><img src="/posts/55776/640-20240321152409560-1005849.png" alt="图片">JDK 1.8内存区域</p></li></ul><h2 id="4-为什么使用元空间替代永久代作为方法区的实现？"><a href="#4-为什么使用元空间替代永久代作为方法区的实现？" class="headerlink" title="4.为什么使用元空间替代永久代作为方法区的实现？"></a>4.为什么使用元空间替代永久代作为方法区的实现？</h2><p>Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。</p><ul><li>客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</li><li>主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</li></ul><h2 id="5-对象创建的过程了解吗？"><a href="#5-对象创建的过程了解吗？" class="headerlink" title="5.对象创建的过程了解吗？"></a>5.对象创建的过程了解吗？</h2><p>在JVM中对象的创建，我们从一个new指令开始：</p><ul><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li></ul><p>这个过程大概图示如下：</p><p><img src="/posts/55776/640-20240321152409540.png" alt="图片">对象创建过程</p><h2 id="6-什么是指针碰撞？什么是空闲列表？"><a href="#6-什么是指针碰撞？什么是空闲列表？" class="headerlink" title="6.什么是指针碰撞？什么是空闲列表？"></a>6.什么是指针碰撞？什么是空闲列表？</h2><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><p><img src="/posts/55776/640-20240321152409567.png" alt="图片">指针碰撞和空闲列表</p><ul><li>指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li>空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li><li>两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。</li></ul><h2 id="7-JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？"><a href="#7-JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？" class="headerlink" title="7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？"></a>7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？</h2><p>会，假设JVM虚拟机上，每一次new 对象时，指针就会向右移动一个对象size的距离，一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</p><p>有两种可选方案来解决这个问题：</p><p><img src="/posts/55776/640-20240321152409560.png" alt="图片">堆抢占和解决方案</p><ul><li><p>采用CAS分配重试的方式来保证更新操作的原子性</p></li><li><p>每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation</p><p>Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p></li></ul><h2 id="8-能说一下对象的内存布局吗？"><a href="#8-能说一下对象的内存布局吗？" class="headerlink" title="8.能说一下对象的内存布局吗？"></a>8.能说一下对象的内存布局吗？</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p><img src="/posts/55776/640-20240321152409724.png" alt="图片">对象的存储布局</p><p><strong>对象头</strong>主要由两部分组成：</p><ul><li>第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。</li><li>第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。</li><li>此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据</li></ul><p><strong>实例数据</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</p><p><strong>对齐填充</strong>不是必须的，没有特别含义，仅仅起着占位符的作用。</p><h2 id="9-对象怎么访问定位？"><a href="#9-对象怎么访问定位？" class="headerlink" title="9.对象怎么访问定位？"></a>9.对象怎么访问定位？</h2><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p><ul><li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：</li></ul><p><img src="/posts/55776/640-20240321152409808.png" alt="图片">通过句柄访问对象</p><ul><li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：</li></ul><p><img src="/posts/55776/640-20240321152409690.png" alt="图片">通过直接指针访问对象</p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>HotSpot虚拟机主要使用直接指针来进行对象访问。</p><h2 id="10-内存溢出和内存泄漏是什么意思？"><a href="#10-内存溢出和内存泄漏是什么意思？" class="headerlink" title="10.内存溢出和内存泄漏是什么意思？"></a>10.内存溢出和内存泄漏是什么意思？</h2><p>内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p>内存溢出就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。</p><p><img src="/posts/55776/640-20240321152409706.png" alt="图片">内存泄漏、内存溢出</p><h2 id="11-能手写内存溢出的例子吗？"><a href="#11-能手写内存溢出的例子吗？" class="headerlink" title="11.能手写内存溢出的例子吗？"></a>11.能手写内存溢出的例子吗？</h2><p>在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。</p><ul><li>Java堆溢出</li></ul><p>Java堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。</p><p>这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;OOMObject&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">OOMObject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虚拟机栈.OutOfMemoryError</li></ul><p>JDK使用的HotSpot虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生OutOfMemoryError异常。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vm参数：-Xss2M</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackOOM</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dontStop</span>()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackLeakByThread</span>()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                    dontStop();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws Throwable</span> &#123;<br>        JavaVMStackOOM oom = <span class="hljs-keyword">new</span> JavaVMStackOOM();<br>        oom.stackLeakByThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-内存泄漏可能由哪些原因导致呢？"><a href="#12-内存泄漏可能由哪些原因导致呢？" class="headerlink" title="12.内存泄漏可能由哪些原因导致呢？"></a>12.内存泄漏可能由哪些原因导致呢？</h2><p>内存泄漏可能的原因有很多种：</p><p><img src="/posts/55776/640-20240321152409613.png" alt="图片">内存泄漏可能原因</p><p><strong>静态集合类引起内存泄漏</strong></p><p>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOM</span> &#123;<br> <span class="hljs-keyword">static</span> <span class="hljs-title class_">List</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">oomTests</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   list.<span class="hljs-title function_">add</span>(obj);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>单例模式</strong></p><p>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</p><p><strong>数据连接、IO、Socket等连接</strong></p><p>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>    conn = DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(<span class="hljs-string">&quot;....&quot;</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; <br>   <br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//不关闭连接</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量不合理的作用域</strong></p><p>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span> &#123;<br>    <span class="hljs-title class_">Object</span> <span class="hljs-built_in">object</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-comment">//...其他代码</span><br>        <span class="hljs-comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span><br>        <span class="hljs-built_in">object</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>hash值发生变化</strong></p><p>对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。</p><p><strong>ThreadLocal使用不当</strong></p><p>ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。</p><h2 id="13-如何判断对象仍然存活？"><a href="#13-如何判断对象仍然存活？" class="headerlink" title="13.如何判断对象仍然存活？"></a>13.如何判断对象仍然存活？</h2><p>有两种方式，<strong>引用计数算法（reference counting）</strong>和可达性分析算法。</p><ul><li><strong>引用计数算法</strong></li></ul><p>引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><img src="/posts/55776/640-20240321152409590.png" alt="图片">引用计数算法</p><ul><li><strong>可达性分析算法</strong></li></ul><p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。<img src="/posts/55776/640-20240321152409632.png" alt="图片"></p><h2 id="14-Java中可作为GC-Roots的对象有哪几种？"><a href="#14-Java中可作为GC-Roots的对象有哪几种？" class="headerlink" title="14.Java中可作为GC Roots的对象有哪几种？"></a>14.Java中可作为GC Roots的对象有哪几种？</h2><p>可以作为GC Roots的主要有四种对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><h2 id="15-说一下对象有哪几种引用？"><a href="#15-说一下对象有哪几种引用？" class="headerlink" title="15.说一下对象有哪几种引用？"></a>15.说一下对象有哪几种引用？</h2><p>Java中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用是最传统的<code>引用</code>的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Object</span> obj =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><ul><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Object obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>ReferenceQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReferenceQueue()</span>;<br>SoftReference reference = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SoftReference(<span class="hljs-params">obj</span>, <span class="hljs-params">queue</span>)</span>;<br><span class="hljs-comment">//强引用对象滞空，保留软引用</span><br>obj = null;<br></code></pre></td></tr></table></figure><ul><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Object obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>ReferenceQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReferenceQueue()</span>;<br>WeakReference reference = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WeakReference(<span class="hljs-params">obj</span>, <span class="hljs-params">queue</span>)</span>;<br><span class="hljs-comment">//强引用对象滞空，保留软引用</span><br>obj = null;<br></code></pre></td></tr></table></figure><ul><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Object obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>ReferenceQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReferenceQueue()</span>;<br>PhantomReference reference = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PhantomReference(<span class="hljs-params">obj</span>, <span class="hljs-params">queue</span>)</span>;<br><span class="hljs-comment">//强引用对象滞空，保留软引用</span><br>obj = null;<br></code></pre></td></tr></table></figure><p><img src="/posts/55776/640-20240321152409653.png" alt="图片">四种引用总结</p><h2 id="16-finalize-方法了解吗？有什么作用？"><a href="#16-finalize-方法了解吗？有什么作用？" class="headerlink" title="16.finalize()方法了解吗？有什么作用？"></a>16.finalize()方法了解吗？有什么作用？</h2><p>用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。</p><p><img src="/posts/55776/640-20240321152409635.png" alt="图片">刀下留人</p><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象在在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</p><h2 id="17-Java堆的内存分区了解吗？"><a href="#17-Java堆的内存分区了解吗？" class="headerlink" title="17.Java堆的内存分区了解吗？"></a>17.Java堆的内存分区了解吗？</h2><p>按照垃圾收集，将Java堆划分为<strong>新生代 （Young Generation）</strong>和<strong>老年代（Old Generation）</strong>两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>而新生代又可以分为三个区域，eden、from、to，比例是8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。</p><p><img src="/posts/55776/640-20240321152409700.png" alt="图片">Java堆内存划分</p><h2 id="18-垃圾收集算法了解吗？"><a href="#18-垃圾收集算法了解吗？" class="headerlink" title="18.垃圾收集算法了解吗？"></a>18.垃圾收集算法了解吗？</h2><p>垃圾收集算法主要有三种：</p><ol><li><strong>标记-清除算法</strong></li></ol><p>见名知义，<code>标记-清除</code>（Mark-Sweep）算法分为两个阶段：</p><ul><li><strong>标记</strong> : 标记出所有需要回收的对象</li><li><strong>清除</strong>：回收所有被标记的对象</li></ul><p><img src="/posts/55776/640-20240321152409693.png" alt="图片">标记-清除算法</p><p>标记-清除算法比较基础，但是主要存在两个缺点：</p><ul><li>执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><ol><li><strong>标记-复制算法</strong></li></ol><p>标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。</p><p>过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="/posts/55776/640-20240321152409676.png" alt="图片">标记-复制算法</p><p>这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。</p><p>新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。</p><ol><li><strong>标记-整理算法</strong></li></ol><p>为了降低内存的消耗，引入一种针对性的算法：<code>标记-整理</code>（Mark-Compact）算法。</p><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)标记-整理算法</p><p>标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。</p><h2 id="19-说一下新生代的区域划分？"><a href="#19-说一下新生代的区域划分？" class="headerlink" title="19.说一下新生代的区域划分？"></a>19.说一下新生代的区域划分？</h2><p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p><p>基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)新生代内存划分</p><h2 id="20-Minor-GC-Young-GC、Major-GC-Old-GC、Mixed-GC、Full-GC都是什么意思？"><a href="#20-Minor-GC-Young-GC、Major-GC-Old-GC、Mixed-GC、Full-GC都是什么意思？" class="headerlink" title="20.Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC都是什么意思？"></a>20.Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC都是什么意思？</h2><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有</strong>CMS收集器会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul><p><strong>整堆收集</strong>（Full GC）：收集整个Java堆和方法区的垃圾收集。</p><h2 id="21-Minor-GC-Young-GC什么时候触发？"><a href="#21-Minor-GC-Young-GC什么时候触发？" class="headerlink" title="21.Minor GC&#x2F;Young GC什么时候触发？"></a>21.Minor GC&#x2F;Young GC什么时候触发？</h2><p>新创建的对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。</p><h2 id="22-什么时候会触发Full-GC？"><a href="#22-什么时候会触发Full-GC？" class="headerlink" title="22.什么时候会触发Full GC？"></a>22.什么时候会触发Full GC？</h2><p>这个触发条件稍微有点多，往下看：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Full GC触发条件</p><ul><li><strong>Young GC之前检查老年代</strong>：在要进行 Young GC 的时候，发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次Young GC后升入老年代的对象总和的平均大小</code>，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。</li><li><strong>Young GC之后老年代空间不足</strong>：执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Full GC</li><li><strong>老年代空间不足</strong>，老年代内存使用率过高，达到一定比例，也会触发Full GC。</li><li><strong>空间分配担保失败</strong>（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong>：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong>：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul><h2 id="23-对象什么时候会进入老年代？"><a href="#23-对象什么时候会进入老年代？" class="headerlink" title="23.对象什么时候会进入老年代？"></a>23.对象什么时候会进入老年代？</h2><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)对象进入老年代</p><p><strong>长期存活的对象将进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次YoungGC之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到15(默认)之后,这个对象将会被移入老年代。</p><p>可以通过这个参数设置这个年龄值。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>XX:MaxTenuringThreshold<br></code></pre></td></tr></table></figure><p><strong>大对象直接进入老年代</strong></p><p>有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。</p><p>HotSpot虚拟机提供了这个参数来设置。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX：PretenureSizeThreshold</span><br></code></pre></td></tr></table></figure><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在Young GC之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。</p><h2 id="24-知道有哪些垃圾收集器吗？"><a href="#24-知道有哪些垃圾收集器吗？" class="headerlink" title="24.知道有哪些垃圾收集器吗？"></a>24.知道有哪些垃圾收集器吗？</h2><p>主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)HotSpot虚拟机垃圾收集器</p><p>这些收集器里，面试的重点是两个——<strong>CMS</strong>和<strong>G1</strong>。</p><ul><li>Serial收集器</li></ul><p>Serial收集器是最基础、历史最悠久的收集器。</p><p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><p>Serial&#x2F;Serial Old收集器的运行过程如图：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Serial&#x2F;Serial Old收集器运行示意图</p><ul><li>ParNew</li></ul><p>ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><p>ParNew&#x2F;Serial Old收集器运行示意图如下：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)ParNew&#x2F;Serial Old收集器运行示意图</p><ul><li>Parallel Scavenge</li></ul><p>Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是CPU用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)吞吐量</p><ul><li>Serial Old</li></ul><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><ul><li>Parallel Old</li></ul><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Parallel Scavenge&#x2F;Parallel Old收集器运行示意图</p><ul><li>CMS收集器</li></ul><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。</p><ul><li>Garbage First收集器</li></ul><p>Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。</p><h2 id="25-什么是Stop-The-World-什么是-OopMap-？什么是安全点？"><a href="#25-什么是Stop-The-World-什么是-OopMap-？什么是安全点？" class="headerlink" title="25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？"></a>25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？</h2><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<code>Stop The World</code>。也简称为STW。</p><p>在HotSpot中，有个数据结构（映射表）称为<code>OopMap</code>。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在<code>特定的位置</code>生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ul><li>1.循环的末尾（非 counted 循环）</li><li>2.方法临返回前 &#x2F; 调用方法的call指令后</li><li>3.可能抛异常的位置</li></ul><p>这些位置就叫作<strong>安全点(safepoint)。</strong> 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><p>用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)老王拉车只能在平路休息</p><h2 id="26-能详细说一下CMS收集器的垃圾收集过程吗？"><a href="#26-能详细说一下CMS收集器的垃圾收集过程吗？" class="headerlink" title="26.能详细说一下CMS收集器的垃圾收集过程吗？"></a>26.能详细说一下CMS收集器的垃圾收集过程吗？</h2><p>CMS收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep收集器运行示意图如下：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Concurrent Mark Sweep收集器运行示意图</p><h2 id="27-G1垃圾收集器了解吗？"><a href="#27-G1垃圾收集器了解吗？" class="headerlink" title="27.G1垃圾收集器了解吗？"></a>27.G1垃圾收集器了解吗？</h2><p>Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。</p><p>虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。</p><p>G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)G1 Heap Regions</p><p>这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。</p><p>G1收集器的运行过程大致可划分为以下四个步骤：</p><ul><li><strong>初始标记</strong>（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)G1收集器运行示意图</p><h2 id="28-有了CMS，为什么还要引入G1？"><a href="#28-有了CMS，为什么还要引入G1？" class="headerlink" title="28.有了CMS，为什么还要引入G1？"></a>28.有了CMS，为什么还要引入G1？</h2><p>优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS同样有三个明显的缺点。</p><ul><li>Mark Sweep算法会导致内存碎片比较多</li><li>CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1主要解决了内存碎片过多的问题。</p><h2 id="29-你们线上用的什么垃圾收集器？为什么要用它？"><a href="#29-你们线上用的什么垃圾收集器？为什么要用它？" class="headerlink" title="29.你们线上用的什么垃圾收集器？为什么要用它？"></a>29.你们线上用的什么垃圾收集器？为什么要用它？</h2><p>怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你Java怎么升，我用8，那么JDK1.8默认用的是什么呢？</p><p>可以使用命令：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">java -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintCommandLineFlags</span> -version<br></code></pre></td></tr></table></figure><p>可以看到有这么一行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span><br></code></pre></td></tr></table></figure><p><code>UseParallelGC</code> &#x3D; <code>Parallel Scavenge + Parallel Old</code>，表示的是新生代用的<code>Parallel Scavenge</code>收集器，老年代用的是<code>Parallel Old</code> 收集器。</p><p>那为什么要用这个呢？默认的呗。</p><p>当然面试肯定不能这么答。</p><p>Parallel Scavenge的特点是什么？</p><p>高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用<code>Parallel Scavenge + Parallel Old</code>的组合。</p><p>当然，这个默认虽然也有说法，但不太讨喜。</p><p>还可以说：</p><p>采用<code>Parallel New</code>+<code>CMS</code>的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。</p><p>或者一步到位：</p><p>我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。</p><h2 id="30-垃圾收集器应该如何选择？"><a href="#30-垃圾收集器应该如何选择？" class="headerlink" title="30.垃圾收集器应该如何选择？"></a>30.垃圾收集器应该如何选择？</h2><p>垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……</p><p>这里简单地列一下上面提到的一些收集器的适用场景：</p><ul><li>Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。</li><li>Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。</li><li>CMS&#x2F;G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。</li><li>ZGC：如果响应时间是高优先级的，或者堆空间比较大。</li></ul><h2 id="31-对象一定分配在堆中吗？有没有了解逃逸分析技术？"><a href="#31-对象一定分配在堆中吗？有没有了解逃逸分析技术？" class="headerlink" title="31.对象一定分配在堆中吗？有没有了解逃逸分析技术？"></a>31.对象一定分配在堆中吗？有没有了解逃逸分析技术？</h2><p><strong>对象一定分配在堆中吗？</strong> 不一定的。</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p><strong>什么是逃逸分析？</strong></p><p><strong>逃逸分析</strong>是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p><p>通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)逃逸</p><p>除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)逃逸强度</p><p><strong>逃逸分析的好处</strong></p><ul><li>栈上分配</li></ul><p>如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</p><ul><li><strong>同步消除</strong></li></ul><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p><ul><li><strong>标量替换</strong></li></ul><p>如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</p><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="32-有哪些常用的命令行性能监控和故障处理工具？"><a href="#32-有哪些常用的命令行性能监控和故障处理工具？" class="headerlink" title="32.有哪些常用的命令行性能监控和故障处理工具？"></a>32.有哪些常用的命令行性能监控和故障处理工具？</h2><ul><li>操作系统工具<ul><li>top：显示系统整体资源使用情况</li><li>vmstat：监控内存和CPU</li><li>iostat：监控IO使用</li><li>netstat：监控网络使用</li></ul></li><li>JDK性能监控工具<ul><li>jps：虚拟机进程查看</li><li>jstat：虚拟机运行时信息查看</li><li>jinfo：虚拟机配置查看</li><li>jmap：内存映像（导出）</li><li>jhat：堆转储快照分析</li><li>jstack：Java堆栈跟踪</li><li>jcmd：实现上面除了jstat外所有命令的功能</li></ul></li></ul><h2 id="33-了解哪些可视化的性能监控和故障处理工具？"><a href="#33-了解哪些可视化的性能监控和故障处理工具？" class="headerlink" title="33.了解哪些可视化的性能监控和故障处理工具？"></a>33.了解哪些可视化的性能监控和故障处理工具？</h2><p>以下是一些JDK自带的可视化性能监控和故障处理工具：</p><ul><li>JConsole</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)JConsole概览</p><ul><li>VisualVM</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)VisualVM安装插件</p><ul><li>Java Mission Control</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)JMC主要界面</p><p>除此之外，还有一些第三方的工具：</p><ul><li><strong>MAT</strong></li></ul><p>Java 堆内存分析工具。</p><ul><li><strong>GChisto</strong></li></ul><p>GC 日志分析工具。</p><ul><li><strong>GCViewer</strong></li></ul><p><code>GC</code> 日志分析工具。</p><ul><li><strong>JProfiler</strong></li></ul><p>商用的性能分析利器。</p><ul><li><strong>arthas</strong></li></ul><p>阿里开源诊断工具。</p><ul><li><strong>async-profiler</strong></li></ul><p>Java 应用性能分析工具，开源、火焰图、跨平台。</p><h2 id="34-JVM的常见参数配置知道哪些？"><a href="#34-JVM的常见参数配置知道哪些？" class="headerlink" title="34.JVM的常见参数配置知道哪些？"></a>34.JVM的常见参数配置知道哪些？</h2><p>一些常见的参数配置：</p><p><strong>堆配置：</strong></p><ul><li>-Xms:初始堆大小</li><li>-Xms：最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><p><strong>收集器设置：</strong></p><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><p><strong>并行收集器设置</strong></p><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为：1&#x2F;(1+n)</li><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数</li></ul><p><strong>打印GC回收的过程日志信息</strong></p><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h2 id="35-有做过JVM调优吗？"><a href="#35-有做过JVM调优吗？" class="headerlink" title="35.有做过JVM调优吗？"></a>35.有做过JVM调优吗？</h2><p>JVM调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个JVM调优流程图：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)JVM调优大致流程图</p><p>实际上，JVM调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调JVM强。</p><p>但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。</p><p>1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G  -Xms8g。</p><p>2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。</p><p>3、用JProfiler 对  堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p><p>4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，<code>导出订单信息</code>。</p><p>5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p><p>6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p><p>7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：</p><ul><li>在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击</li><li>后端代码加分布式锁，做防重处理</li></ul><p>这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！</p><h2 id="36-线上服务CPU占用过高怎么排查？"><a href="#36-线上服务CPU占用过高怎么排查？" class="headerlink" title="36.线上服务CPU占用过高怎么排查？"></a>36.线上服务CPU占用过高怎么排查？</h2><p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)CPU飙高</p><p>1、所以先需要找出那个进程占用CPU高。</p><ul><li>top  列出系统各个进程的资源占用情况。</li></ul><p>2、然后根据找到对应进行里哪个线程占用CPU高。</p><ul><li>top -Hp 进程ID  列出对应进程里面的线程占用资源情况</li></ul><p>3、找到对应线程ID后，再打印出对应线程的堆栈信息</p><ul><li>printf “%x\n”  PID   把线程ID转换为16进制。</li><li>jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。</li></ul><p>4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p><p>查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</p><h2 id="37-内存飙高问题怎么排查？"><a href="#37-内存飙高问题怎么排查？" class="headerlink" title="37.内存飙高问题怎么排查？"></a>37.内存飙高问题怎么排查？</h2><p>分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p><p>1、先观察垃圾回收的情况</p><ul><li>jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。</li><li>jmap -histo PID | head -20  查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。</li></ul><p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p><p>2、导出堆内存文件快照</p><ul><li>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID  dump堆内存信息到文件。</li></ul><p>3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p><h2 id="38-频繁-minor-gc-怎么办？"><a href="#38-频繁-minor-gc-怎么办？" class="headerlink" title="38.频繁 minor gc 怎么办？"></a>38.频繁 minor gc 怎么办？</h2><p>优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间<code>-Xmn</code>来降低Minor GC的频率。</p><h2 id="39-频繁Full-GC怎么办？"><a href="#39-频繁Full-GC怎么办？" class="headerlink" title="39.频繁Full GC怎么办？"></a>39.频繁Full GC怎么办？</h2><p>Full GC的排查思路大概如下：</p><ol><li>清楚从程序角度，有哪些原因导致FGC？</li></ol><ul><li><strong>大对象</strong>：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li><li><strong>内存泄漏</strong>：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li><li>程序频繁生成一些<strong>长生命周期的对象</strong>，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）</li><li><strong>程序BUG</strong></li><li>代码中<strong>显式调用了gc</strong>方法，包括自己的代码甚至框架中的代码。</li><li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。</li></ul><ol><li>清楚排查问题时能使用哪些工具</li></ol><ul><li>公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。</li><li>JDK的自带工具，包括jmap、jstat等常用命令：</li></ul><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># 查看堆内存各区域的使用率以及GC情况</span><br>jstat -gcutil -h20 <span class="hljs-keyword">pid</span> <span class="hljs-number">1000</span><br><span class="hljs-comment"># 查看堆内存中的存活对象，并按空间排序</span><br>jmap -histo <span class="hljs-keyword">pid</span> | head -n20<br><span class="hljs-comment"># dump堆内存文件</span><br>jmap -dump:<span class="hljs-keyword">format</span>=b,<span class="hljs-keyword">file</span>=heap <span class="hljs-keyword">pid</span><br></code></pre></td></tr></table></figure><ul><li>可视化的堆内存分析工具：JVisualVM、MAT等</li></ul><ol><li>排查指南</li></ol><ul><li>查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。</li><li>再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ul><h2 id="40-有没有处理过内存泄漏问题？是如何定位的？"><a href="#40-有没有处理过内存泄漏问题？是如何定位的？" class="headerlink" title="40.有没有处理过内存泄漏问题？是如何定位的？"></a>40.有没有处理过内存泄漏问题？是如何定位的？</h2><p>内存泄漏是内在病源，外在病症表现可能有：</p><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 <code>OutOfMemoryError</code> 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><p>严重<strong>内存泄漏</strong>往往伴随频繁的 <strong>Full GC</strong>，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：</p><ol><li><p>使用 <code>jps</code> 查看运行的 Java 进程 ID</p></li><li><p>使用<code>top -p [pid]</code> 查看进程使用 CPU 和 MEM 的情况</p></li><li><p>使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占 CPU 和 MEM 的情况</p></li><li><p>将线程 ID 转换为 16 进制：<code>printf &quot;%x\n&quot; [pid]</code>，输出的值就是线程栈信息中的 <strong>nid</strong>。</p><p>例如：<code>printf &quot;%x\n&quot; 29471</code>，换行输出 <strong>731f</strong>。</p></li><li><p>抓取线程栈：<code>jstack 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。</p><p>在线程栈信息中找到对应线程号的 16 进制值，如下是 <strong>731f</strong> 线程的信息。线程栈分析可使用 Visualvm 插件 <strong>TDA</strong>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;Service Thread&quot;</span> #7 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">tid</span>=0x00007fbe2c164000 <span class="hljs-attribute">nid</span>=0x731f runnable [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br></code></pre></td></tr></table></figure></li><li><p>使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。</p><p>或使用 <code>jstat -gccause [pid] 5000</code> ，同样是输出 GC 摘要信息。</p><p>或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。</p></li><li><p>如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了</p></li><li><p>使用 <code>jmap -histo:live [pid]</code> 输出每个类的对象数量，内存大小(字节单位)及全限定类名。</p></li><li><p>生成 <code>dump</code> 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了</p><p>使用 jmap 生成 dump 文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># jmap -<span class="hljs-keyword">dump</span>:live,format=b,<span class="hljs-keyword">file</span>=<span class="hljs-number">29471</span>.<span class="hljs-keyword">dump</span> <span class="hljs-number">29471</span><br>Dumping heap to <span class="hljs-regexp">/root/</span><span class="hljs-keyword">dump</span> ...<br>Heap <span class="hljs-keyword">dump</span> <span class="hljs-keyword">file</span> created<br></code></pre></td></tr></table></figure><p>可以使用 <strong>jhat</strong> 命令分析：<code>jhat -port 8000 29471.dump</code>，浏览器访问 jhat 服务，端口是 8000。</p><p>通常使用图形化工具分析，如 JDK 自带的 <strong>jvisualvm</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p><p>或使用第三方式具分析的，如 <strong>JProfiler</strong> 也是个图形化工具，<strong>GCViewer</strong> 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 <strong>GCEasy</strong>。</p><p>注意：如果 dump 文件较大的话，分析会占比较大的内存。</p><p>基本上就可以定位到代码层的逻辑了。</p><ol><li>在 dump 文析结果中查找存在大量的对象，再查对其的引用。</li><li>dump 文件分析</li></ol></li></ol><h2 id="41-有没有处理过内存溢出问题？"><a href="#41-有没有处理过内存溢出问题？" class="headerlink" title="41.有没有处理过内存溢出问题？"></a>41.有没有处理过内存溢出问题？</h2><p>内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。</p><p>排查过程和排查内存泄漏过程类似。</p><h1 id="虚拟机执行"><a href="#虚拟机执行" class="headerlink" title="虚拟机执行"></a>虚拟机执行</h1><h2 id="42-能说一下类的生命周期吗？"><a href="#42-能说一下类的生命周期吗？" class="headerlink" title="42.能说一下类的生命周期吗？"></a>42.能说一下类的生命周期吗？</h2><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)类的生命周期</p><h2 id="43-类加载的过程知道吗？"><a href="#43-类加载的过程知道吗？" class="headerlink" title="43.类加载的过程知道吗？"></a>43.类加载的过程知道吗？</h2><p>加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>在加载过程，JVM要做三件事情：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)加载</p><ul><li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。</p><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h2 id="44-类加载器有哪些？"><a href="#44-类加载器有哪些？" class="headerlink" title="44.类加载器有哪些？"></a>44.类加载器有哪些？</h2><p>主要有四种类加载器:</p><ul><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li><strong>用户自定义类加载器</strong> (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器。</li></ul><h2 id="45-什么是双亲委派机制？"><a href="#45-什么是双亲委派机制？" class="headerlink" title="45.什么是双亲委派机制？"></a>45.什么是双亲委派机制？</h2><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)双亲委派模型</p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><h2 id="46-为什么要用双亲委派机制？"><a href="#46-为什么要用双亲委派机制？" class="headerlink" title="46.为什么要用双亲委派机制？"></a>46.为什么要用双亲委派机制？</h2><p>答案是为了保证应用程序的稳定有序。</p><p>例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。</p><h2 id="47-如何破坏双亲委派机制？"><a href="#47-如何破坏双亲委派机制？" class="headerlink" title="47.如何破坏双亲委派机制？"></a>47.如何破坏双亲委派机制？</h2><p>如果不想打破双亲委派模型，就重写ClassLoader类中的fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。</p><h2 id="48-历史上有哪几次双亲委派机制的破坏？"><a href="#48-历史上有哪几次双亲委派机制的破坏？" class="headerlink" title="48.历史上有哪几次双亲委派机制的破坏？"></a>48.历史上有哪几次双亲委派机制的破坏？</h2><p>双亲委派机制在历史上主要有三次破坏：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)双亲委派模型的三次破坏</p><blockquote><p><strong>第一次破坏</strong></p></blockquote><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类  java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的  protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。</p><blockquote><p><strong>第二次破坏</strong></p></blockquote><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>例如我们比较熟悉的JDBC:</p><p>各个厂商各有不同的JDBC的实现，Java在核心包<code>\lib</code>里定义了对应的SPI，那么这个就毫无疑问由<code>启动类加载器</code>加载器加载。</p><p>但是各个厂商的实现，是没办法放在核心包里的，只能放在<code>classpath</code>里，只能被<code>应用类加载器</code>加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。</p><p>为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。</p><blockquote><p><strong>第三次破坏</strong></p></blockquote><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><h2 id="49-你觉得应该怎么实现一个热部署功能？"><a href="#49-你觉得应该怎么实现一个热部署功能？" class="headerlink" title="49.你觉得应该怎么实现一个热部署功能？"></a>49.你觉得应该怎么实现一个热部署功能？</h2><p>我们已经知道了Java类的加载过程。一个Java类文件到虚拟机里的对象，要经过如下过程:首先通过Java编译器，将Java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。</p><p>类加载器ClassLoader功能，也就是将class字节码转换到类的实例。在Java应用中，所有的实例都是由类加载器，加载而来。</p><p>一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。</p><p>这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？</p><p>既然在类加载器中，Java类只能被加载一次，并且无法卸载。那么我们是不是可以直接把Java类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。</p><p>想要实现热部署可以分以下三个步骤：</p><ol><li>销毁原来的自定义ClassLoader</li><li>更新class类文件</li><li>创建新的ClassLoader去加载更新后的class类文件。</li></ol><p>到此，一个热部署的功能就这样实现了。</p><h2 id="50-Tomcat的类加载机制了解吗？"><a href="#50-Tomcat的类加载机制了解吗？" class="headerlink" title="50.Tomcat的类加载机制了解吗？"></a>50.Tomcat的类加载机制了解吗？</h2><p>Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。</p><p>Tomcat类加载器如下：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Tomcat类加载器</p><p>Tomcat实际上也是破坏了双亲委派模型的。</p><p>Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p><p>所以，Tomcat破坏了<strong>双亲委派原则</strong>，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。每一个WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交CommonClassLoader加载，这和双亲委派刚好相反。</p><hr><p><strong>参考：</strong></p><p>[1].《深入理解Java虚拟机》</p><p>[2].《不看后悔》38个JVM精选问答，让你变成专家！:<a href="https://juejin.cn/post/6936390496122044423">https://juejin.cn/post/6936390496122044423</a></p><p>[3]. 《不看后悔》超赞！来一份常见 JVM 面试题+“答案”！:<a href="https://mp.weixin.qq.com/s/7ZaLMI1LYHBEL7Q2gOrGKQ">https://mp.weixin.qq.com/s/7ZaLMI1LYHBEL7Q2gOrGKQ</a></p><p>[4]. JVM性能优化–类加载器,手动实现类的热加载:<a href="https://juejin.cn/post/6844904029357604877#heading-17">https://juejin.cn/post/6844904029357604877#heading-17</a></p><p>[5]. 炸了！一口气问了我18个JVM问!:<a href="https://mp.weixin.qq.com/s/M7f8_QHlvQGw_hH7K0If7A">https://mp.weixin.qq.com/s/M7f8_QHlvQGw_hH7K0If7A</a></p><p>[6]. 从实际案例聊聊Java应用的GC优化:<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p><p>[7]. JVM系列(二)：JVM 内存泄漏与内存溢出及问题排查:<a href="http://www.gxitsky.com/article/1603347575608495">http://www.gxitsky.com/article/1603347575608495</a></p><p>[8] .《实战Java虚拟机性能优化》</p><p>[9]. 再清楚不过了，JVM逃逸分析，你一定得知道:<a href="https://cloud.tencent.com/developer/article/1761785">https://cloud.tencent.com/developer/article/1761785</a></p><p>[10].【JVM进阶之路】十：JVM调优总结<a href="https://fighter3.blog.csdn.net/article/details/115600737">https://fighter3.blog.csdn.net/article/details/115600737</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发六十问</title>
    <link href="/posts/234.html"/>
    <url>/posts/234.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-并行跟并发有什么区别？"><a href="#1-并行跟并发有什么区别？" class="headerlink" title="1.并行跟并发有什么区别？"></a>1.并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li></ul><p><img src="/posts/234/640-20240321152949605.png" alt="图片">并行和并发</p><p>就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="/posts/234/640-20240321152949628-1006189.png" alt="图片">并行并发和食堂打饭</p><h2 id="2-说说什么是进程和线程？"><a href="#2-说说什么是进程和线程？" class="headerlink" title="2.说说什么是进程和线程？"></a>2.说说什么是进程和线程？</h2><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p><img src="/posts/234/640-20240321152949619.png" alt="图片">程序进程线程关系</p><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><h2 id="3-说说线程有几种创建方式？"><a href="#3-说说线程有几种创建方式？" class="headerlink" title="3.说说线程有几种创建方式？"></a>3.说说线程有几种创建方式？</h2><p>Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。</p><p><img src="/posts/234/640-20240321152949572.png" alt="图片">线程创建三种方式</p><ul><li>继承Thread类，重写run()方法，调用start()方法启动线程</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 继承Thread类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> extends Thread &#123;<br>        @<span class="hljs-function">Override</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;This is child thread&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        MyThread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyThread</span>();<br>        thread.<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现 Runnable 接口，重写run()方法</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Runnable!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">RunnableTask</span> task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTask</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><ul><li>实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerTask</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Callable</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> call() throws Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,i am running!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">//创建异步任务</span><br>        FutureTask&lt;<span class="hljs-keyword">String</span>&gt; task=<span class="hljs-keyword">new</span> <span class="hljs-type">FutureTask</span>&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">CallerTask</span>());<br>        <span class="hljs-comment">//启动线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(task).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待执行完成，并获取返回结果</span><br>            <span class="hljs-keyword">String</span> result=task.<span class="hljs-keyword">get</span>();<br>            System.out.println(result);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#4-为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="/posts/234/640-20240321152949567.png" alt="图片">start方法</p><p><strong>为什么我们不能直接调用run()方法？</strong>也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h2 id="5-线程有哪些常用的调度方法？"><a href="#5-线程有哪些常用的调度方法？" class="headerlink" title="5.线程有哪些常用的调度方法？"></a>5.线程有哪些常用的调度方法？</h2><p><img src="/posts/234/640-20240321152949593.png" alt="图片">线程常用调度方法</p><p><strong>线程等待与通知</strong></p><p>在Object类中有一些函数可以用于线程的等待与通知。</p><ul><li>wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：<ul><li>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</li><li>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</li></ul></li><li>wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</li><li>wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。</li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li>notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li>notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><p>Thread类也提供了一个方法用于等待的方法：</p><ul><li><p>join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才</p><p>从thread.join()返回。</p></li></ul><p><strong>线程休眠</strong></p><ul><li>sleep(long millis)  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li></ul><p><strong>让出优先权</strong></p><ul><li>yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li></ul><p><strong>线程中断</strong></p><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li>void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li><li>boolean isInterrupted() 方法：检测当前线程是否被中断。</li><li>boolean interrupted() 方法：检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><h2 id="6-线程有几种状态？"><a href="#6-线程有几种状态？" class="headerlink" title="6.线程有几种状态？"></a>6.线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p><table><thead><tr><th align="left">状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NEW</td><td align="left">初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td align="left">RUNNABLE</td><td align="left">运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td align="left">BLOCKED</td><td align="left">阻塞状态：表示线程阻塞于锁</td></tr><tr><td align="left">WAITING</td><td align="left">等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td align="left">TIME_WAITING</td><td align="left">超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td align="left">TERMINATED</td><td align="left">终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="/posts/234/640-20240321152949578.png" alt="图片">Java线程状态变化</p><h2 id="7-什么是线程上下文切换？"><a href="#7-什么是线程上下文切换？" class="headerlink" title="7.什么是线程上下文切换？"></a>7.什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。</p><p><img src="/posts/234/640-20240321152949585.png" alt="图片">线程切换-2020-12-16-2107</p><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="/posts/234/640-20240321152949588.png" alt="图片">上下文切换时机</p><h2 id="8-守护线程了解吗？"><a href="#8-守护线程了解吗？" class="headerlink" title="8.守护线程了解吗？"></a>8.守护线程了解吗？</h2><p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</p><p>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</p><p>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</p><h2 id="9-线程间有哪些通信方式？"><a href="#9-线程间有哪些通信方式？" class="headerlink" title="9.线程间有哪些通信方式？"></a>9.线程间有哪些通信方式？</h2><p><img src="/posts/234/640-20240321152949595.png" alt="图片">线程间通信方式</p><ul><li><strong>volatile和synchronized关键字</strong></li></ul><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><ul><li><strong>等待&#x2F;通知机制</strong></li></ul><p>可以通过Java内置的等待&#x2F;通知机制（wait()&#x2F;notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p><ul><li><strong>管道输入&#x2F;输出流</strong></li></ul><p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p><ul><li><strong>使用Thread.join()</strong></li></ul><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p><ul><li><strong>使用ThreadLocal</strong></li></ul><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p><blockquote><p>关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面老三会单独出一期来盘点一下常见的多线程笔试题。</p></blockquote><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。</p><h2 id="10-ThreadLocal是什么？"><a href="#10-ThreadLocal是什么？" class="headerlink" title="10.ThreadLocal是什么？"></a>10.ThreadLocal是什么？</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="/posts/234/640-20240321152949610-1006189.png" alt="图片">ThreadLocal线程副本</p><ul><li>创建</li></ul><p>创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//创建一个ThreadLocal变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;<span class="hljs-keyword">String</span>&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>写入</li></ul><p>线程可以在任何地方使用localVariable，写入变量。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">localVariable.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;鄙人三某”);</span><br></code></pre></td></tr></table></figure><ul><li>读取</li></ul><p>线程在任何地方读取的都是它写入的变量。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">localVariable.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h2 id="11-你在工作中用到过ThreadLocal吗？"><a href="#11-你在工作中用到过ThreadLocal吗？" class="headerlink" title="11.你在工作中用到过ThreadLocal吗？"></a>11.你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。</p><p><img src="/posts/234/640-20240321152949599.png" alt="图片">ThreadLoca存放用户上下文</p><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><h2 id="12-ThreadLocal怎么实现的呢？"><a href="#12-ThreadLocal怎么实现的呢？" class="headerlink" title="12.ThreadLocal怎么实现的呢？"></a>12.ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取<code>ThreadLocalMap</code>，然后把元素存到这个map中。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> <span class="hljs-built_in">set</span>(T value) &#123;<br>    <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-keyword">Thread</span> t = <span class="hljs-keyword">Thread</span>.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    ThreadLocalMap <span class="hljs-built_in">map</span> = getMap(t);<br>    <span class="hljs-comment">//讲当前元素存入map</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span> != <span class="hljs-built_in">null</span>)<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(this, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal实现的秘密都在这个<code>ThreadLocalMap</code>了，可以Thread类中定义了一个类型为<code>ThreadLocal.ThreadLocalMap</code>的成员变量<code>threadLocals</code>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Thread</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span> &#123;<br>   <span class="hljs-comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span><br>   ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    <span class="hljs-type">Object</span> value;<br><br>    <span class="hljs-comment">//节点类</span><br>    <span class="hljs-type">Entry</span>(<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>        <span class="hljs-comment">//key赋值</span><br>        <span class="hljs-keyword">super</span>(k);<br>        <span class="hljs-comment">//value赋值</span><br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个<strong>弱引用</strong>，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> WeakReference(T <span class="hljs-built_in">ref</span>erent) &#123;<br>    <span class="hljs-keyword">super</span>(<span class="hljs-built_in">ref</span>erent);<br>&#125;<br></code></pre></td></tr></table></figure><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="/posts/234/640-20240321152949604.png" alt="图片">ThreadLoca结构图</p><blockquote><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p></blockquote><ul><li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。</li><li>ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。</li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li><li>ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。</li></ul><h2 id="13-ThreadLocal-内存泄露是怎么回事？"><a href="#13-ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="13.ThreadLocal 内存泄露是怎么回事？"></a>13.ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="/posts/234/640-20240321152949610.png" alt="图片">ThreadLocal内存分配</p><p>ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。</p><blockquote><p>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</p></blockquote><p>那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会<strong>造成了内存泄漏问题</strong>。</p><blockquote><p>那怎么解决内存泄漏问题呢？</p></blockquote><p>很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; localVariable = <span class="hljs-keyword">new</span> ThreadLocal();<br><span class="hljs-keyword">try</span> &#123;<br>    localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br><span class="hljs-string">    ……</span><br><span class="hljs-string">&#125; finally &#123;</span><br><span class="hljs-string">    localVariable.remove();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>那为什么key还要设计成弱引用？</p></blockquote><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h2 id="14-ThreadLocalMap的结构了解吗？"><a href="#14-ThreadLocalMap的结构了解吗？" class="headerlink" title="14.ThreadLocalMap的结构了解吗？"></a>14.ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgI4lgEHeM9mwORic2rkq4KJ4vsibqs7eezWc6kiarB3LvnxhibaZzUSIDQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">ThreadLocalMap结构示意图</p><ul><li><p>元素数组</p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">private</span> <span class="hljs-keyword">Entry</span>[] table;<br></code></pre></td></tr></table></figure><ul><li><p>散列方法</p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p></li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">int i = <span class="hljs-keyword">key</span>.threadLocalHashCode &amp; (<span class="hljs-keyword">table</span>.<span class="hljs-keyword">length</span> - 1);<br></code></pre></td></tr></table></figure><p>这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> nextHashCode.<span class="hljs-title">getAndAdd</span><span class="hljs-params">(HASH_INCREMENT)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-ThreadLocalMap怎么解决Hash冲突的？"><a href="#15-ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="15.ThreadLocalMap怎么解决Hash冲突的？"></a>15.ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。</p><p>ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="/posts/234/640-20240321152949623.png" alt="图片">ThreadLocalMap解决冲突</p><p>如上图所示，如果我们插入一个value&#x3D;27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h2 id="16-ThreadLocalMap扩容机制了解吗？"><a href="#16-ThreadLocalMap扩容机制了解吗？" class="headerlink" title="16.ThreadLocalMap扩容机制了解吗？"></a>16.ThreadLocalMap扩容机制了解吗？</h2><p>在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (!cleanSomeSlots(<span class="hljs-name">i</span>, sz) <span class="hljs-symbol">&amp;&amp;</span> sz &gt;= threshold)<br>    rehash()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span>()</span> &#123;<br>    <span class="hljs-comment">//清理过期Entry</span><br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">//扩容</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-comment">//清理过期Entry</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleEntries</span>()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-built_in">int</span> len = tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.<span class="hljs-keyword">get</span>() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p><p><img src="/posts/234/640-20240321152949628.png" alt="图片">ThreadLocalMap扩容</p><p>具体代码：</p><p><img src="/posts/234/640-20240321152949626.png" alt="图片"></p><p>ThreadLocalMap resize</p><h2 id="17-父子线程怎么共享数据？"><a href="#17-父子线程怎么共享数据？" class="headerlink" title="17.父子线程怎么共享数据？"></a>17.父子线程怎么共享数据？</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<code>InheritableThreadLocal</code>。</p><p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalTest</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadLocal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>();<br>        <span class="hljs-comment">// 主线程</span><br>        threadLocal.set(<span class="hljs-string">&quot;不擅技术&quot;</span>);<br>        <span class="hljs-comment">//子线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>                System.out.println(<span class="hljs-string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());<br>            &#125;<br>        &#125;;<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>那原理是什么呢？</p></blockquote><p>原理很简单，在Thread类里还有另外一个变量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ThreadLocal.ThreadLocalMap inheritableThreadLocals <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (inheritThreadLocals<span class="hljs-operator"> &amp;&amp; </span>parent.inheritableThreadLocals != null)<br>    this.inheritableThreadLocals =<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadLocal</span>.</span></span>create<span class="hljs-constructor">InheritedMap(<span class="hljs-params">parent</span>.<span class="hljs-params">inheritableThreadLocals</span>)</span>;<br></code></pre></td></tr></table></figure><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="18-说一下你对Java内存模型（JMM）的理解？"><a href="#18-说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="18.说一下你对Java内存模型（JMM）的理解？"></a>18.说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><p>Java内存模型的抽象图：</p><p><img src="/posts/234/640-20240321152949694.png" alt="图片">Java内存模型</p><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="/posts/234/640-20240321152949667.png" alt="图片">实际线程工作模型</p><p>图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h2 id="19-说说你对原子性、可见性、有序性的理解？"><a href="#19-说说你对原子性、可见性、有序性的理解？" class="headerlink" title="19.说说你对原子性、可见性、有序性的理解？"></a>19.说说你对原子性、可见性、有序性的理解？</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li></ul><blockquote><p>分析下面几行代码的原子性？</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> j = i;<br>i++;<br>i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>第1句是基本类型赋值，是原子性操作。</li><li>第2句先读i的值，再赋值到j，两步操作，不能保证原子性。</li><li>第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li></ul><blockquote><p>原子性、可见性、有序性都应该怎么保证呢？</p></blockquote><ul><li>原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized</code>。</li><li>可见性：Java是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li><li>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。</li></ul><h2 id="20-那说说什么是指令重排？"><a href="#20-那说说什么是指令重排？" class="headerlink" title="20.那说说什么是指令重排？"></a>20.那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：</p><p><img src="/posts/234/640-20240321152949652.png" alt="图片">多级指令重排</p><p>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的JVM指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="/posts/234/640-20240321152949649.png" alt="图片">双重校验单例模式异常情形</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="21-指令重排有限制吗？happens-before了解吗？"><a href="#21-指令重排有限制吗？happens-before了解吗？" class="headerlink" title="21.指令重排有限制吗？happens-before了解吗？"></a>21.指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。</p><p>happens-before的定义：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</li></ul><p>happens-before和我们息息相关的有六大规则：</p><p><img src="/posts/234/640-20240321152949651.png" alt="图片">happens-before六大规则</p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><h2 id="22-as-if-serial又是什么？单线程的程序一定是顺序的吗？"><a href="#22-as-if-serial又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="22.as-if-serial又是什么？单线程的程序一定是顺序的吗？"></a>22.as-if-serial又是什么？单线程的程序一定是顺序的吗？</h2><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">double pi <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span><span class="hljs-comment">;   // A</span><br>double r <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span><span class="hljs-comment">;   // B </span><br>double area <span class="hljs-operator">=</span> pi * r * r<span class="hljs-comment">;   // C</span><br></code></pre></td></tr></table></figure><p>上面3个操作的数据依赖关系：</p><p><img src="/posts/234/640-20240321152949724.png" alt="图片">image-20210812200646364</p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><p>所以最终，程序可能会有两种执行顺序：</p><p><img src="/posts/234/640-20240321152949638.png" alt="图片">两种执行结果</p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h2 id="23-volatile实现原理了解吗？"><a href="#23-volatile实现原理了解吗？" class="headerlink" title="23.volatile实现原理了解吗？"></a>23.volatile实现原理了解吗？</h2><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p><blockquote><p>volatile怎么保证可见性的呢？</p></blockquote><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x &#x3D; 0，线程A修改x&#x3D;1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)volatile内存可见性</p><blockquote><p>volatile怎么保证有序性的呢？</p></blockquote><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)volatile重排序规则表</p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ol><li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障</li><li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障</li></ol><p><img src="/posts/234/640-20240321152949660.png" alt="图片">volatile写插入内存屏障后生成的指令序列示意图</p><p><img src="/posts/234/640-20240321152949669.png" alt="图片">volatile写插入内存屏障后生成的指令序列示意图</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="24-synchronized用过吗？怎么使用？"><a href="#24-synchronized用过吗？怎么使用？" class="headerlink" title="24.synchronized用过吗？怎么使用？"></a>24.synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">synchronized void <span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  //业务代码</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p></li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">synchronized void staic <span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment"> //业务代码</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;<br> <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-synchronized的实现原理？"><a href="#25-synchronized的实现原理？" class="headerlink" title="25.synchronized的实现原理？"></a>25.synchronized的实现原理？</h2><blockquote><p>synchronized是怎么加锁的呢？</p></blockquote><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><ol><li><p>synchronized修饰代码块时，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指向同步代码块的结束位置。</p><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p></li></ol><p><img src="/posts/234/640-20240321152949744.png" alt="图片">monitorenter和monitorexit</p><ol><li><p>synchronized修饰同步方法时，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</p><p>同样可以写段代码反编译看一下。</p></li></ol><p><img src="/posts/234/640-20240321152949742.png" alt="图片">synchronized修饰同步方法</p><blockquote><p>synchronized锁住的是什么呢？</p></blockquote><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是<strong>基于Monitor实现</strong>的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong>。</p><p>所谓的Monitor其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在Java虚拟机（HotSpot）中，Monitor是由<strong>ObjectMonitor实现</strong>的，可以叫做内部锁，或者Monitor锁。</p><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sqf">ObjectMonitor() &#123;<br>    <span class="hljs-variable">_header</span>       = NULL;<br>    <span class="hljs-variable">_count</span>        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>    <span class="hljs-variable">_waiters</span>      = <span class="hljs-number">0</span>,<br>    <span class="hljs-variable">_recursions</span>   = <span class="hljs-number">0</span>;  <span class="hljs-comment">//锁的重入次数</span><br>    <span class="hljs-variable">_object</span>       = NULL;<br>    <span class="hljs-variable">_owner</span>        = NULL;  <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>    <span class="hljs-variable">_WaitSet</span>      = NULL;  <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>    <span class="hljs-variable">_WaitSetLock</span>  = <span class="hljs-number">0</span> ;<br>    <span class="hljs-variable">_Responsible</span>  = NULL ;<br>    <span class="hljs-variable">_succ</span>         = NULL ;<br>    <span class="hljs-variable">_cxq</span>          = NULL ;<br>    FreeNext      = NULL ;<br>    <span class="hljs-variable">_EntryList</span>    = NULL ;  <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>    <span class="hljs-variable">_SpinFreq</span>     = <span class="hljs-number">0</span> ;<br>    <span class="hljs-variable">_SpinClock</span>    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以类比一个去医院就诊的例子[18]：</p><ul><li>首先，患者在<strong>门诊大厅</strong>前台或自助挂号机<strong>进行挂号</strong>；</li><li>随后，挂号结束后患者找到对应的<strong>诊室就诊</strong>：<ul><li>诊室每次只能有一个患者就诊；</li><li>如果此时诊室空闲，直接进入就诊；</li><li>如果此时诊室内有其它患者就诊，那么当前患者进入<strong>候诊室</strong>，等待叫号；</li></ul></li><li>就诊结束后，<strong>走出就诊室</strong>，候诊室的<strong>下一位候诊患者</strong>进入就诊室。</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)就诊-图片来源参考[18]</p><p>这个过程就和Monitor机制比较相似：</p><ul><li><strong>门诊大厅</strong>：所有待进入的线程都必须先在<strong>入口Entry Set</strong>挂号才有资格；</li><li><strong>就诊室</strong>：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开</li><li><strong>候诊室</strong>：就诊室繁忙时，进入<strong>等待区（Wait Set）</strong>，就诊室空闲的时候就从<strong>等待区（Wait Set）</strong>叫新的线程</li></ul><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Java Montior机制</p><p>所以我们就知道了，同步是锁住的什么东西：</p><ul><li>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</li><li>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h2 id="26-除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#26-除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><blockquote><p>synchronized怎么保证可见性？</p></blockquote><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><blockquote><p>synchronized怎么保证有序性？</p></blockquote><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</p><p>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p><p>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</p><blockquote><p>synchronized怎么实现可重入的呢？</p></blockquote><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p><p>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p><h2 id="27-锁升级？synchronized优化了解吗？"><a href="#27-锁升级？synchronized优化了解吗？" class="headerlink" title="27.锁升级？synchronized优化了解吗？"></a>27.锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p><p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)Mark Word变化</p><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><blockquote><p>synchronized做了哪些优化？</p></blockquote><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li><li>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li><li>自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><blockquote><p>锁升级的过程是什么样的？</p></blockquote><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="/posts/234/640-20240321152949707.png" alt="图片">锁升级方向</p><p>我们看一下升级的过程：</p><h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p><strong>偏向锁的获取：</strong></p><ol><li>判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’</li><li>如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’</li><li>通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’</li><li>CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，<strong>偏向锁升级为轻量级锁</strong>，然后被阻塞在安全点的线程继续往下执行同步代码块</li><li>执行同步代码</li></ol><p><strong>偏向锁的撤销：</strong></p><ol><li>偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</li><li>撤销—-T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态—-该状态达到阈值20则执行批量重偏向</li><li>升级—-T线程还在同步代码块中，则将T线程的偏向锁<strong>升级为轻量级锁</strong>，当前线程执行轻量级锁状态下的锁获取步骤—-该状态达到阈值40则执行批量撤销</li></ol><h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p><strong>轻量级锁的获取：</strong></p><ol><li>进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中</li><li>复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’</li><li>更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态</li><li>更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’</li><li>表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。</li><li>表示该锁对象已经被其他线程抢占，则进行<strong>自旋等待</strong>（默认10次），等待次数达到阈值仍未获取到锁，则<strong>升级为重量级锁</strong></li></ol><p>大体上省简的升级过程：</p><p><img src="/posts/234/640-20240321152949670.png" alt="图片">锁升级简略过程</p><p>完整的升级过程：</p><p><img src="/posts/234/640-20240321152949705.png" alt="图片">synchronized 锁升级过程-来源参考[14]</p><h2 id="28-说说synchronized和ReentrantLock的区别？"><a href="#28-说说synchronized和ReentrantLock的区别？" class="headerlink" title="28.说说synchronized和ReentrantLock的区别？"></a>28.说说synchronized和ReentrantLock的区别？</h2><p>可以从锁的实现、功能特点、性能等几个维度去回答这个问题：</p><ul><li><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try&#x2F;finally 语句块来完成。）</li><li><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</li><li><strong>功能特点：</strong> ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。<ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()&#x2F;notifyAll()方法结合实现等待&#x2F;通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul><p>下面的表格列出出了两种锁之间的区别：</p><p><img src="/posts/234/640-20240321152949691.png" alt="图片">synchronized和ReentrantLock的区别</p><h2 id="29-AQS了解多少？"><a href="#29-AQS了解多少？" class="headerlink" title="29.AQS了解多少？"></a>29.AQS了解多少？</h2><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><ul><li>AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列</li><li>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</li><li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li><li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</li></ul><p><img src="/posts/234/640-20240321152949683.png" alt="图片">先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong>。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p><p><img src="/posts/234/640-20240321152949702.png" alt="图片">CLH队列</p><p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShod0nzG9dWkP9pgooxqstkWOSmtiahqPMdIp9FGicaujPkWFyuEHb7Fw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">AQS变种CLH队列</p><p>AQS 中的 CLH 变体等待队列拥有以下特性：</p><ul><li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li><li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li><li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ul><p>ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。</p><h2 id="30-ReentrantLock实现原理？"><a href="#30-ReentrantLock实现原理？" class="headerlink" title="30.ReentrantLock实现原理？"></a>30.<strong>ReentrantLock</strong>实现原理？</h2><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>看看ReentrantLock的加锁操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 创建非公平锁</span><br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 获取锁操作</span><br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 执行代码逻辑</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 解锁操作</span><br>    <span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>new ReentrantLock()</code>构造函数默认创建的是非公平锁 NonfairSync。</p><p><strong>公平锁 FairSync</strong></p><ol><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li><li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li></ol><p><strong>非公平锁 NonfairSync</strong></p><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ul><p>默认创建的对象lock()的时候：</p><ul><li>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。</li><li>如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。</li></ul><p><img src="/posts/234/640-20240321152949712.png" alt="图片">ReentrantLock 非公平锁加锁流程简图</p><h2 id="31-ReentrantLock怎么实现公平锁的？"><a href="#31-ReentrantLock怎么实现公平锁的？" class="headerlink" title="31.ReentrantLock怎么实现公平锁的？"></a>31.ReentrantLock怎么实现公平锁的？</h2><p><code>new ReentrantLock()</code>构造函数默认创建的是非公平锁 NonfairSync</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span>()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ReentrantLock lock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLock(<span class="hljs-params">true</span>)</span>;<br>--- ReentrantLock<br><span class="hljs-comment">// true 代表公平锁，false 代表非公平锁</span><br>public <span class="hljs-constructor">ReentrantLock(<span class="hljs-params">boolean</span> <span class="hljs-params">fair</span>)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-constructor">FairSync()</span> : <span class="hljs-keyword">new</span> <span class="hljs-constructor">NonfairSync()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><p><strong>非公平锁和公平锁的两处不同：</strong></p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCS1z5onhYJcWagbrTJI5rcWrKribFQ5S3j7lMibJfwJY9z2vL2BDx6zg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">公平锁tryAcquire</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="32-CAS呢？CAS了解多少？"><a href="#32-CAS呢？CAS了解多少？" class="headerlink" title="32.CAS呢？CAS了解多少？"></a>32.CAS呢？CAS了解多少？</h2><p>CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。</p><p>CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。</p><p>只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。</p><h2 id="33-CAS-有什么问题？如何解决？"><a href="#33-CAS-有什么问题？如何解决？" class="headerlink" title="33.CAS 有什么问题？如何解决？"></a>33.CAS 有什么问题？如何解决？</h2><p>CAS的经典三大问题：</p><p><img src="/posts/234/640-20240321152949715.png" alt="图片">CAS三大问题</p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><blockquote><p>怎么解决ABA问题？</p></blockquote><ul><li>加版本号</li></ul><p>每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p><p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><h4 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h4><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><blockquote><p>怎么解决循环性能开销问题？</p></blockquote><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><h4 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h4><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><blockquote><p>怎么解决只能保证一个变量的原子操作问题？</p></blockquote><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</li></ul><h2 id="34-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#34-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h2><p><img src="/posts/234/640-20240321152949726.png" alt="图片">Java保证原子性方法</p><ul><li>使用循环原子类，例如AtomicInteger，实现i++原子操作</li><li>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</li><li>使用synchronized，对i++操作加锁</li></ul><h2 id="35-原子操作类了解多少？"><a href="#35-原子操作类了解多少？" class="headerlink" title="35.原子操作类了解多少？"></a>35.原子操作类了解多少？</h2><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i&#x3D;1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p><p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p><p><img src="/posts/234/640-20240321152949722.png" alt="图片">原子操作类</p><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p><ul><li>AtomicBoolean：原子更新布尔类型。</li><li>AtomicInteger：原子更新整型。</li><li>AtomicLong：原子更新长整型。</li></ul><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。</li><li>AtomicLongArray：原子更新长整型数组里的元素。</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li><li>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型</li></ul><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p><ul><li>AtomicReference：原子更新引用类型。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</li></ul><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</li></ul><h2 id="36-AtomicInteger-的原理？"><a href="#36-AtomicInteger-的原理？" class="headerlink" title="36.AtomicInteger 的原理？"></a>36.AtomicInteger 的原理？</h2><p>一句话概括：<strong>使用CAS实现</strong>。</p><p>以AtomicInteger的添加方法为例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> unsafe.<span class="hljs-title">getAndAddInt</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的CAS操作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndAddInt(Object <span class="hljs-params">var1</span>, <span class="hljs-params">long</span> <span class="hljs-params">var2</span>, <span class="hljs-params">int</span> <span class="hljs-params">var4</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = this.get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>)</span>;<br>    &#125; <span class="hljs-keyword">while</span>(!this.compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">var5</span>, <span class="hljs-params">var5</span> + <span class="hljs-params">var4</span>)</span>);<br><br>    return var5;<br>&#125;<br></code></pre></td></tr></table></figure><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><h2 id="37-线程死锁了解吗？该如何避免？"><a href="#37-线程死锁了解吗？该如何避免？" class="headerlink" title="37.线程死锁了解吗？该如何避免？"></a>37.线程死锁了解吗？该如何避免？</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><img src="/posts/234/640-20240321152949730.png" alt="图片">死锁示意图</p><p>那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：</p><p><img src="/posts/234/640-20240321152949732.png" alt="图片">死锁产生必备四条件</p><ul><li>互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li>请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul><p>该如何避免死锁呢？答案是<strong>至少破坏死锁发生的一个条件</strong>。</p><ul><li>其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</li><li>对于“请求并持有”这个条件，可以一次性请求所有的资源。</li><li>对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</li></ul><h2 id="38-那死锁问题怎么排查呢？"><a href="#38-那死锁问题怎么排查呢？" class="headerlink" title="38.那死锁问题怎么排查呢？"></a>38.那死锁问题怎么排查呢？</h2><p>可以使用jdk自带的命令行工具排查：</p><ol><li>使用jps查找运行的Java进程：jps -l</li><li>使用jstack查看线程堆栈信息：jstack -l  进程id</li></ol><p>基本就可以看到死锁的信息。</p><p>还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的<code>检测到死锁</code>按钮，将会看到线程的死锁信息。</p><p><img src="/posts/234/640-20240321152949750.png" alt="图片">线程死锁检测</p><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="39-CountDownLatch（倒计数器）了解吗？"><a href="#39-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="39.CountDownLatch（倒计数器）了解吗？"></a>39.CountDownLatch（倒计数器）了解吗？</h2><p>CountDownLatch，倒计数器，有两个常见的应用场景[18]：</p><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。</p><p><img src="/posts/234/640.jpeg" alt="图片">王者荣耀等待玩家确认-来源参考[18]</p><p>CountDownLatch模仿这个场景(参考[18])：</p><p>创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。</p><p>在这段代码中，<code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br>    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(5)</span>;<br><br>    Thread 大乔 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">countDownLatch</span>::<span class="hljs-params">countDown</span>)</span>;<br>    Thread 兰陵王 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">countDownLatch</span>::<span class="hljs-params">countDown</span>)</span>;<br>    Thread 安其拉 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">countDownLatch</span>::<span class="hljs-params">countDown</span>)</span>;<br>    Thread 哪吒 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">countDownLatch</span>::<span class="hljs-params">countDown</span>)</span>;<br>    Thread 铠 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 稍等，上个卫生间，马上到...</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1500</span>);<br>            countDownLatch.count<span class="hljs-constructor">Down()</span>;<br>        &#125; catch (InterruptedException ignored) &#123;&#125;<br>    &#125;);<br><br>    大乔.start<span class="hljs-literal">()</span>;<br>    兰陵王.start<span class="hljs-literal">()</span>;<br>    安其拉.start<span class="hljs-literal">()</span>;<br>    哪吒.start<span class="hljs-literal">()</span>;<br>    铠.start<span class="hljs-literal">()</span>;<br>    countDownLatch.await<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;所有玩家已经就位！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p><p>所以大家得一块出生，在</p><p><img src="/posts/234/640-20240321152949754.jpeg" alt="图片">王者荣耀-来源参考[18]</p><p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><br>    Thread 大乔 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; waitToFight(countDownLatch))</span>;</span><br><span class="hljs-function">    <span class="hljs-title">Thread</span> 兰陵王 = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; waitToFight(countDownLatch))</span>;</span><br><span class="hljs-function">    <span class="hljs-title">Thread</span> 安其拉 = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; waitToFight(countDownLatch))</span>;</span><br><span class="hljs-function">    <span class="hljs-title">Thread</span> 哪吒 = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; waitToFight(countDownLatch))</span>;</span><br><span class="hljs-function">    <span class="hljs-title">Thread</span> 铠 = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; waitToFight(countDownLatch))</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    大乔.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    兰陵王.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    安其拉.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    哪吒.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    铠.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">countDownLatch</span>.<span class="hljs-title">countDown</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;敌方还有5秒达到战场，全军出击！&quot;</span>)</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">waitToFight</span><span class="hljs-params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">countDownLatch</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>; // 在此等待信号再继续</span><br><span class="hljs-function">        <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;收到，发起进攻！&quot;</span>)</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>CountDownLatch的<strong>核心方法</strong>也不多：</p><ul><li><code>await()</code>：等待latch降为0；</li><li><code>boolean await(long timeout, TimeUnit unit)</code>：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</li><li><code>countDown()</code>：latch数量减1；</li><li><code>getCount()</code>：获取当前的latch数量。</li></ul><h2 id="40-CyclicBarrier（同步屏障）了解吗？"><a href="#40-CyclicBarrier（同步屏障）了解吗？" class="headerlink" title="40.CyclicBarrier（同步屏障）了解吗？"></a>40.CyclicBarrier（同步屏障）了解吗？</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。</p><p>不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。</p><p><img src="/posts/234/640-20240321152949781.png" alt="图片">想结衣结衣不依,迷爱理爱理不理。</p><p>我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。</p><p><img src="/posts/234/640-20240321152949845.png" alt="图片">小约翰可汗选妃模拟代码</p><p>运行结果：</p><p><img src="/posts/234/640-20240321152949868.png" alt="图片">运行结果</p><p>CyclicBarrier最最核心的方法，仍然是await()：</p><ul><li>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</li></ul><p>上面的例子抽象一下，本质上它的流程就是这样就是这样：</p><p><img src="/posts/234/640-20240321152949770.png" alt="图片">CyclicBarrier工作流程</p><h2 id="41-CyclicBarrier和CountDownLatch有什么区别？"><a href="#41-CyclicBarrier和CountDownLatch有什么区别？" class="headerlink" title="41.CyclicBarrier和CountDownLatch有什么区别？"></a>41.CyclicBarrier和CountDownLatch有什么区别？</h2><p>两者最核心的区别[18]：</p><ul><li>CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；</li><li>CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程</li></ul><p>它们区别用一个表格整理：</p><table><thead><tr><th align="left">CyclicBarrier</th><th align="left">CountDownLatch</th></tr></thead><tbody><tr><td align="left">CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td><td align="left">CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</td></tr><tr><td align="left">CyclicBarrier面向的是线程数</td><td align="left">CountDownLatch面向的是任务数</td></tr><tr><td align="left">在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法</td><td align="left">使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td></tr><tr><td align="left">CyclicBarrier可以在所有的线程释放后重新使用</td><td align="left">CountDownLatch在计数器为0时不能再使用</td></tr><tr><td align="left">在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题</td><td align="left">在CountDownLatch中，如果某个线程出现问题，其他线程不受影响</td></tr></tbody></table><h2 id="42-Semaphore（信号量）了解吗？"><a href="#42-Semaphore（信号量）了解吗？" class="headerlink" title="42.Semaphore（信号量）了解吗？"></a>42.Semaphore（信号量）了解吗？</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。</p><p><img src="/posts/234/640-20240321152949768-1006189.jpeg" alt="图片">停车场空闲车位提示-图片来源网络</p><p>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是<strong>协调多个线程对共享资源的获取</strong>。</p><p><img src="/posts/234/640-20240321152949768.jpeg" alt="图片">Semaphore许可获取-来源参考[18]</p><p>我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        s.acquire();<br>                        System.out.println(<span class="hljs-string">&quot;save data&quot;</span>);<br>                        s.release();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法<code>Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h2 id="43-Exchanger-了解吗？"><a href="#43-Exchanger-了解吗？" class="headerlink" title="43.Exchanger 了解吗？"></a>43.Exchanger 了解吗？</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p><img src="/posts/234/640-20240321152949781.jpeg" alt="图片">英雄交换猎物-来源参考[18]</p><p>这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Exchanger</span>&lt;<span class="hljs-title class_">String</span>&gt; exgr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;<span class="hljs-title class_">String</span>&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">ExecutorService</span> threadPool = <span class="hljs-title class_">Executors</span>.<span class="hljs-title function_">newFixedThreadPool</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        threadPool.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-title class_">String</span> A = <span class="hljs-string">&quot;银行流水A&quot;</span>; <span class="hljs-comment">// A录入银行流水数据 </span><br>                    exgr.<span class="hljs-title function_">exchange</span>(A);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        threadPool.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-title class_">String</span> B = <span class="hljs-string">&quot;银行流水B&quot;</span>; <span class="hljs-comment">// B录入银行流水数据 </span><br>                    <span class="hljs-title class_">String</span> A = exgr.<span class="hljs-title function_">exchange</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>                    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;A和B数据是否一致：&quot;</span> + A.<span class="hljs-title function_">equals</span>(B) + <span class="hljs-string">&quot;，A录入的是：&quot;</span><br>                            + A + <span class="hljs-string">&quot;，B录入是：&quot;</span> + B);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        threadPool.<span class="hljs-title function_">shutdown</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit)</code>设置最大等待时长。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="44-什么是线程池？"><a href="#44-什么是线程池？" class="headerlink" title="44.什么是线程池？"></a>44.什么是线程池？</h2><p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><p><img src="/posts/234/640-20240321152949799.png" alt="图片">管理线程的池子</p><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h2 id="45-能说说工作中线程池的应用吗？"><a href="#45-能说说工作中线程池的应用吗？" class="headerlink" title="45.能说说工作中线程池的应用吗？"></a>45.能说说工作中线程池的应用吗？</h2><p>之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。</p><p><img src="/posts/234/640-20240321152949784.png" alt="图片">业务示例</p><p>主要代码如下：</p><p><img src="/posts/234/640-20240321152949828.png" alt="图片">主要代码</p><p>完整可运行代码地址：<a href="https://gitee.com/fighter3/thread-demo.git">https://gitee.com/fighter3/thread-demo.git</a></p><p>线程池的参数如下：</p><ul><li>corePoolSize：线程核心参数选择了CPU数×2</li><li>maximumPoolSize：最大线程数选择了和核心线程数相同</li><li>keepAliveTime：非核心闲置线程存活时间直接置为0</li><li>unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒</li><li>workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列</li></ul><p>同时还用了synchronized 来加锁，保证数据不会被重复推送：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">synchronized</span> (PushProcessServiceImpl.<span class="hljs-keyword">class</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。</p><h2 id="46-能简单说一下线程池的工作流程吗？"><a href="#46-能简单说一下线程池的工作流程吗？" class="headerlink" title="46.能简单说一下线程池的工作流程吗？"></a>46.能简单说一下线程池的工作流程吗？</h2><p>用一个通俗的比喻：</p><p>有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。</p><p>老三去办业务，可能会遇到什么情况呢？</p><ol><li>老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。</li></ol><p><img src="/posts/234/640-20240321152949800.png" alt="图片">直接办理</p><ol><li>老三发现没有空闲的窗口，就在排队区排队等。</li></ol><p><img src="/posts/234/640-20240321152949805.png" alt="图片">排队等待</p><ol><li>老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</li></ol><p><img src="/posts/234/640-20240321152949809.png" alt="图片">排队区满</p><ol><li>老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？</li></ol><p><img src="/posts/234/640-20240321152949811.png" alt="图片">等待区，排队区都满</p><blockquote><ol><li>我们银行系统已经瘫痪</li><li>谁叫你来办的你找谁去</li><li>看你比较急，去队里加个塞</li><li>今天没办法，不行你看改一天</li></ol></blockquote><p>上面的这个流程几乎就跟 JDK 线程池的大致流程类似，</p><blockquote><ol><li>营业中的 3个窗口对应核心线程池数：corePoolSize</li><li>总的营业窗口数6对应：maximumPoolSize</li><li>打开的临时窗口在多少时间内无人办理则关闭对应：unit</li><li>排队区就是等待队列：workQueue</li><li>无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler</li><li>threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。</li></ol></blockquote><p>所以我们线程池的工作流程也比较好理解了：</p><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li></ol><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li></ul><p><img src="/posts/234/640-20240321152949820.png" alt="图片">线程池执行流程</p><ol><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><h2 id="47-线程池主要参数有哪些？"><a href="#47-线程池主要参数有哪些？" class="headerlink" title="47.线程池主要参数有哪些？"></a>47.线程池主要参数有哪些？</h2><p><img src="/posts/234/640-20240321152949829.png" alt="图片">线程池参数</p><p>线程池有七大参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code>这四个。</p><ol><li>corePoolSize</li></ol><p>此值是用来初始化线程池中核心线程数，当线程池中线程池数&lt; <code>corePoolSize</code>时，系统默认是添加一个任务才创建一个线程池。当线程数 &#x3D; corePoolSize时，新任务会追加到workQueue中。</p><ol><li>maximumPoolSize</li></ol><p><code>maximumPoolSize</code>表示允许的最大线程数 &#x3D; (非核心线程数+核心线程数)，当<code>BlockingQueue</code>也满了，但线程池中总线程数 &lt; <code>maximumPoolSize</code>时候就会再次创建新的线程。</p><ol><li>keepAliveTime</li></ol><p>非核心线程 &#x3D;(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。</p><ol><li>unit</li></ol><p>线程池中非核心线程保持存活的时间的单位</p><ul><li>TimeUnit.DAYS; 天</li><li>TimeUnit.HOURS; 小时</li><li>TimeUnit.MINUTES; 分钟</li><li>TimeUnit.SECONDS; 秒</li><li>TimeUnit.MILLISECONDS;  毫秒</li><li>TimeUnit.MICROSECONDS;  微秒</li><li>TimeUnit.NANOSECONDS;  纳秒</li></ul><ol><li>workQueue</li></ol><p>线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数&#x3D; corePoolSize时，新的任务会被添加到<code>workQueue</code>中，如果<code>workQueue</code>也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p><ol><li>threadFactory</li></ol><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。</p><ol><li>handler</li></ol><p><code>corePoolSize</code>、<code>workQueue</code>、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略。</p><h2 id="48-线程池的拒绝策略有哪些？"><a href="#48-线程池的拒绝策略有哪些？" class="headerlink" title="48.线程池的拒绝策略有哪些？"></a>48.线程池的拒绝策略有哪些？</h2><p>类比前面的例子，无法办理业务时的处理方式，帮助记忆：</p><p><img src="/posts/234/640-20240321152949851.png" alt="图片">四种策略</p><ul><li>AbortPolicy ：直接抛出异常，默认使用此策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</li><li>DiscardPolicy ：当前任务直接丢弃</li></ul><p>想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。</p><h2 id="49-线程池有哪几种工作队列？"><a href="#49-线程池有哪几种工作队列？" class="headerlink" title="49.线程池有哪几种工作队列？"></a>49.线程池有哪几种工作队列？</h2><p>常用的阻塞队列主要有以下几种：</p><p><img src="/posts/234/640-20240321152949823.png" alt="图片">线程池常用阻塞队列</p><ul><li>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li><li>LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</li><li>DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</li><li>PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</li><li>SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</li></ul><h2 id="50-线程池提交execute和submit有什么区别？"><a href="#50-线程池提交execute和submit有什么区别？" class="headerlink" title="50.线程池提交execute和submit有什么区别？"></a>50.线程池提交execute和submit有什么区别？</h2><ol><li>execute 用于提交不需要返回值的任务</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">threadsPool.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// TODO Auto-generated method stub &#125; </span><br>    &#125;);<br></code></pre></td></tr></table></figure><ol><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">Object</span>&gt; future = executor.submit(harReturnValuetask); <br><span class="hljs-keyword">try</span> &#123; <span class="hljs-built_in">Object</span> s = future.<span class="hljs-keyword">get</span>(); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <br>    <span class="hljs-comment">// 处理中断异常 </span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123; <br>    <span class="hljs-comment">// 处理无法执行任务异常 </span><br>&#125; <span class="hljs-keyword">finally</span> &#123; <br>    <span class="hljs-comment">// 关闭线程池 executor.shutdown();</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-线程池怎么关闭知道吗？"><a href="#51-线程池怎么关闭知道吗？" class="headerlink" title="51.线程池怎么关闭知道吗？"></a>51.线程池怎么关闭知道吗？</h2><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p><ol><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务interrupt中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li></ul><h2 id="52-线程池的线程数应该怎么配置？"><a href="#52-线程池的线程数应该怎么配置？" class="headerlink" title="52.线程池的线程数应该怎么配置？"></a>52.线程池的线程数应该怎么配置？</h2><p>线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。</p><ol><li>计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</li><li>IO密集型：数据库链接，网络通讯传输等。</li></ol><p><img src="/posts/234/640-20240321152949855.png" alt="图片">常见线程池参数配置方案-来源美团技术博客</p><p>一般的经验，不同类型线程池的参数配置：</p><ol><li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.available<span class="hljs-constructor">Processors()</span>;<br></code></pre></td></tr></table></figure><ol><li>IO密集型：线程数适当大一点，机器的Cpu核心数*2。</li><li>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li></ol><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p><h2 id="53-有哪几种常见的线程池？"><a href="#53-有哪几种常见的线程池？" class="headerlink" title="53.有哪几种常见的线程池？"></a>53.有哪几种常见的线程池？</h2><p>面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p><p><img src="/posts/234/640-20240321152949908.png" alt="图片">四大线程池</p><ul><li>newFixedThreadPool  (固定数目线程的线程池)</li><li>newCachedThreadPool (可缓存线程的线程池)</li><li>newSingleThreadExecutor (单线程的线程池)</li><li>newScheduledThreadPool (定时及周期执行的线程池)</li></ul><h2 id="54-能说一下四种常见线程池的原理吗？"><a href="#54-能说一下四种常见线程池的原理吗？" class="headerlink" title="54.能说一下四种常见线程池的原理吗？"></a>54.能说一下四种常见线程池的原理吗？</h2><p>前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span><br>          (<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                  <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory));<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li><li>keepAliveTime为0</li></ul><p><img src="/posts/234/640-20240321152949843.png" alt="图片">SingleThreadExecutor运行流程</p><p>工作流程：</p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li></ul><p><strong>适用场景</strong></p><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                    <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                    threadFactory);<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM</li></ul><p><img src="/posts/234/640-20240321152949854.png" alt="图片">FixedThreadPool</p><p>工作流程：</p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                   <span class="hljs-number">60</span>L, TimeUnit.SECONDS,<br>                                   <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                   threadFactory);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><p><img src="/posts/234/640-20240321152949867.png" alt="图片">CachedThreadPool执行流程</p><p>工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为Integer.MAX_VALUE，也有OOM的风险</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><img src="/posts/234/640-20240321152949875.png" alt="图片">ScheduledThreadPool执行流程</p><p><strong>工作机制</strong></p><ul><li>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</li><li>线程执行这个ScheduledFutureTask。</li><li>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</li><li>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgGFneaLl3DOo26lX6mr6PBWGmx6XSFLK5ibzzxf3I2ZsBGuia68awLFg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">ScheduledThreadPoolExecutor执行流程</p><p><strong>使用场景</strong></p><p>周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p>使用无界队列的线程池会导致什么问题吗？</p></blockquote><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。</p><h2 id="55-线程池异常怎么处理知道吗？"><a href="#55-线程池异常怎么处理知道吗？" class="headerlink" title="55.线程池异常怎么处理知道吗？"></a>55.线程池异常怎么处理知道吗？</h2><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><p>常见的异常处理方式：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSITic450VQC8zhvBae0x7bLCQU2BlmnEsMe1Ww18Kh4vf0zIVibP6Jr1g/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">线程池异常处理</p><h2 id="56-能说一下线程池有几种状态吗？"><a href="#56-能说一下线程池有几种状态吗？" class="headerlink" title="56.能说一下线程池有几种状态吗？"></a>56.能说一下线程池有几种状态吗？</h2><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//线程池状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> RUNNING    = <span class="hljs-number">-1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><p>线程池各个状态切换图：</p><p><img src="/posts/234/640-20240321152949888.png" alt="图片">线程池状态切换图</p><p><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul><h2 id="57-线程池如何实现参数的动态修改？"><a href="#57-线程池如何实现参数的动态修改？" class="headerlink" title="57.线程池如何实现参数的动态修改？"></a>57.线程池如何实现参数的动态修改？</h2><p>线程池提供了几个  setter方法来设置线程池的参数。</p><p><img src="/posts/234/640-20240321152949887.png" alt="图片">JDK 线程池参数设置接口来源参考[7]</p><p>这里主要有两个思路：</p><p><img src="/posts/234/640-20240321152949886.png" alt="图片">动态修改线程池参数</p><ul><li>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</li><li>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。</li></ul><h2 id="线程池调优了解吗？"><a href="#线程池调优了解吗？" class="headerlink" title="线程池调优了解吗？"></a>线程池调优了解吗？</h2><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：</p><p><img src="/posts/234/640-20240321152949855.png" alt="图片">线程池评估方案 来源参考[7]</p><p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。</p><p>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。</p><p>事后要注意仔细观察，随时调整。</p><p><img src="/posts/234/640-20240321152949891.png" alt="图片">线程池调优</p><p>具体的调优案例可以查看参考[7]美团技术博客。</p><h2 id="58-你能设计实现一个线程池吗？"><a href="#58-你能设计实现一个线程池吗？" class="headerlink" title="58.你能设计实现一个线程池吗？"></a>58.你能设计实现一个线程池吗？</h2><p>⭐这道题在阿里的面试中出现频率比较高</p><p>线程池实现原理可以查看 <a href="https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&mid=2247488521&idx=1&sn=66b0ae23ef24ba47f4487aa8a3646886&scene=21#wechat_redirect">要是以前有人这么讲线程池，我早就该明白了！</a> ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：</p><p><img src="/posts/234/640-20240321152949887-1006189.png" alt="图片">线程池主要实现流程</p><p>我们自己的实现就是完成这个核心流程：</p><ul><li>线程池中有N个工作线程</li><li>把任务提交给线程池运行</li><li>如果线程池已满，把任务放入队列</li><li>最后当有空闲时，获取队列中任务来执行</li></ul><p>实现代码[6]：</p><p><img src="/posts/234/640-20240321152949907.png" alt="图片">自定义线程池</p><p>这样，一个实现了线程池主要流程的类就完成了。</p><h2 id="59-单机线程池执行断电了应该怎么处理？"><a href="#59-单机线程池执行断电了应该怎么处理？" class="headerlink" title="59.单机线程池执行断电了应该怎么处理？"></a>59.单机线程池执行断电了应该怎么处理？</h2><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。</p><p>也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。</p><h1 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h1><p>关于一些并发容器，可以去看看 <a href="https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&mid=2247488788&idx=1&sn=01875e3e45515c2d57593cb7a01d0b6b&scene=21#wechat_redirect">面渣逆袭：Java集合连环三十问  </a>，里面有<code>CopyOnWriteList</code>和<code>ConcurrentHashMap</code>这两种线程安全容器类的问答。。</p><h2 id="60-Fork-Join框架了解吗？"><a href="#60-Fork-Join框架了解吗？" class="headerlink" title="60.Fork&#x2F;Join框架了解吗？"></a>60.Fork&#x2F;Join框架了解吗？</h2><p>Fork&#x2F;Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>要想掌握Fork&#x2F;Join框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。</p><p><strong>分而治之</strong></p><p>Fork&#x2F;Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p><img src="/posts/234/640-20240321152949896.png" alt="图片">Fork&#x2F;Join分治算法</p><p><strong>工作窃取算法</strong></p><p>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。</p><p>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。</p><p>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p><img src="/posts/234/640-20240321152949901.png" alt="图片">工作窃取</p><p>看一个Fork&#x2F;Join框架应用的例子，计算1~n之间的和：1+2+3+…+n</p><ul><li>设置一个分割阈值，任务大于阈值就拆分任务</li><li>任务有结果，所以需要继承RecursiveTask</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountTask</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果任务足够小就计算任务</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">canCompute</span> <span class="hljs-operator">=</span> (end - start) &lt;= THRESHOLD;<br>        <span class="hljs-keyword">if</span> (canCompute) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果任务大于阈值，就分裂成两个子任务计算</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">CountTask</span> <span class="hljs-variable">leftTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountTask</span>(start, middle);<br>            <span class="hljs-type">CountTask</span> <span class="hljs-variable">rightTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountTask</span>(middle + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 执行子任务</span><br>            leftTask.fork();<br>            rightTask.fork(); <span class="hljs-comment">// 等待子任务执行完，并得到其结果</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> leftTask.join();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> rightTask.join(); <span class="hljs-comment">// 合并子任务</span><br>            sum = leftResult + rightResult;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(); <span class="hljs-comment">// 生成一个计算任务，负责计算1+2+3+4</span><br>        <span class="hljs-type">CountTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountTask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 执行一个任务</span><br>        Future&lt;Integer&gt; result = forkJoinPool.submit(task);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(result.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><hr><p><strong>参考：</strong></p><ul><li>[1]. 《Java并发编程的艺术》</li><li>[2]. 《Java发编程实战》</li><li>[3]. 个人珍藏的80道多线程并发面试题（1-10答案解析）:<a href="https://juejin.cn/post/6854573221258199048">https://juejin.cn/post/6854573221258199048</a></li><li>[4]. 艾小仙 《我想进大厂》</li><li>[5]. Java并发基础知识，我用思维导图整理好了:<a href="https://fighter3.blog.csdn.net/article/details/113612422">https://fighter3.blog.csdn.net/article/details/113612422</a></li><li>[6] . 极客时间 《Java并发编程实战》</li><li>[7]. 《Java并发编程之美》</li><li>[8]. 万字图文 | 聊一聊 ReentrantLock 和 AQS 那点事（看完不会你找我）:<a href="https://juejin.cn/post/6896278031317663751">https://juejin.cn/post/6896278031317663751</a></li><li>[9]. 《深入理解Java虚拟机》</li><li>[10]. 如何实现阻塞队列 :<a href="https://juejin.cn/post/6977948393272246285">https://juejin.cn/post/6977948393272246285</a></li><li>[11]. 讲真 这次绝对让你轻松学习线程池:<a href="https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA">https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA</a></li><li>[12]. 面试必备：Java线程池解析:<a href="https://juejin.cn/post/6844903889678893063">https://juejin.cn/post/6844903889678893063</a></li><li>[13]. 面试官问：“在项目中用过多线程吗？”你就把这个案例讲给他听！:<a href="https://juejin.cn/post/6936457087505399821">https://juejin.cn/post/6936457087505399821</a></li><li>[14]. 小傅哥 《Java面经手册》</li><li>[15]. Java线程池实现原理及其在美团业务中的实践:<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></li><li>[16]. 面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）:<a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519</a></li><li>[17].面试官问我什么是JMM:<a href="https://zhuanlan.zhihu.com/p/258393139">https://zhuanlan.zhihu.com/p/258393139</a></li><li>[18]. 《王者并发课》:<a href="https://juejin.cn/column/6963590682602635294">https://juejin.cn/column/6963590682602635294</a></li><li>[19]. synchronized锁升级详细过程:<a href="https://www.cnblogs.com/suixing123/p/13996479.html">https://www.cnblogs.com/suixing123/p/13996479.html</a></li></ul><p><strong>END</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronized 锁升级</title>
    <link href="/posts/8012.html"/>
    <url>/posts/8012.html</url>
    
    <content type="html"><![CDATA[<p>在<a href="http://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&mid=2247485128&idx=1&sn=7fc733a5b958ee4db00879c1e51fe80b&chksm=96e680f1a19109e79b6184e2792da40bf3e40c389f6394dec0f46c8156fcc324c858650b3a3b&scene=21#wechat_redirect">图文详解Java对象内存布局</a>这篇文章中，在研究对象头时我们了解了<code>synchronized</code>锁升级的过程，由于篇幅有限，对锁升级的过程介绍的比较简略，本文在上一篇的基础上，来详细研究一下锁升级的过程以及各个状态下锁的原理。本文结构如下：</p><ul><li>1 无锁</li><li>2 偏向锁</li><li>3 轻量级锁</li><li>4 重量级锁</li><li>总结</li></ul><h3 id="1-无锁"><a href="#1-无锁" class="headerlink" title="1 无锁"></a>1 无锁</h3><p>在上一篇文章中，我们提到过 jvm会有4秒的偏向锁开启的延迟时间，在这个偏向延迟内对象处于为无锁态。如果关闭偏向锁启动延迟、或是经过4秒且没有线程竞争对象的锁，那么对象会进入<strong>无锁可偏向</strong>状态。</p><p>准确来说，无锁可偏向状态应该叫做<strong>匿名偏向</strong>(<code>Anonymously biased</code>)状态，因为这时对象的<code>mark word</code>中后三位已经是<code>101</code>，但是<code>threadId</code>指针部分仍然全部为0，它还没有向任何线程偏向。综上所述，对象在刚被创建时，根据jvm的配置对象可能会处于 <strong>无锁</strong> 或 <strong>匿名偏向</strong> 两个状态。</p><p>此外，如果在jvm的参数中关闭偏向锁，那么直到有线程获取这个锁对象之前，会一直处于无锁不可偏向状态。修改jvm启动参数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-UseBiasedLocking</span><br></code></pre></td></tr></table></figure><p>延迟5s后打印对象内存布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts/8012/640-20240315112202615.png" alt="图片"></p><p>可以看到，即使经过一定的启动延时，对象一直处于<code>001</code>无锁不可偏向状态。大家可能会有疑问，在无锁状态下，为什么要存在一个不可偏向状态呢？通过查阅资料得到的解释是：</p><blockquote><p>JVM内部的代码有很多地方也用到了synchronized，明确在这些地方存在线程的竞争，如果还需要从偏向状态再逐步升级，会带来额外的性能损耗，所以JVM设置了一个偏向锁的启动延迟，来降低性能损耗</p></blockquote><p>也就是说，在无锁不可偏向状态下，如果有线程试图获取锁，那么将跳过升级偏向锁的过程，直接使用轻量级锁。使用代码进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//-XX:-UseBiasedLocking</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看结果可以看到，在关闭偏向锁情况下使用<code>synchronized</code>，锁会直接升级为轻量级锁（<code>00</code>状态）:</p><p><img src="/posts/8012/640-20240315112202618.png" alt="图片"></p><p>在目前的基础上，可以用流程图概括上面的过程：</p><p><img src="/posts/8012/640-20240315112202639.png" alt="图片"></p><p>额外注意一点就是匿名偏向状态下，如果调用系统的<code>hashCode()</code>方法，会使对象回到无锁态，并在<code>markword</code>中写入<code>hashCode</code>。并且在这个状态下，如果有线程尝试获取锁，会直接从无锁升级到轻量级锁，不会再升级为偏向锁。</p><h3 id="2-偏向锁"><a href="#2-偏向锁" class="headerlink" title="2 偏向锁"></a>2 偏向锁</h3><h4 id="2-1-偏向锁原理"><a href="#2-1-偏向锁原理" class="headerlink" title="2.1 偏向锁原理"></a>2.1 偏向锁原理</h4><p>匿名偏向状态是偏向锁的初始状态，在这个状态下第一个试图获取该对象的锁的线程，会使用CAS操作（汇编命令<code>CMPXCHG</code>）尝试将自己的<code>threadID</code>写入对象头的<code>mark word</code>中，使匿名偏向状态升级为<strong>已偏向</strong>（Biased）的偏向锁状态。在已偏向状态下，线程指针<code>threadID</code>非空，且偏向锁的时间戳<code>epoch</code>为有效值。</p><p>如果之后有线程再次尝试获取锁时，需要检查<code>mark word</code>中存储的<code>threadID</code>是否与自己相同即可，如果相同那么表示当前线程已经获得了对象的锁，不需要再使用CAS操作来进行加锁。</p><p>如果<code>mark word</code>中存储的<code>threadID</code>与当前线程不同，那么将执行CAS操作，试图将当前线程的ID替换<code>mark word</code>中的<code>threadID</code>。只有当对象处于下面两种状态中时，才可以执行成功：</p><ul><li>对象处于匿名偏向状态</li><li>对象处于<strong>可重偏向</strong>（Rebiasable）状态，新线程可使用CAS将<code>threadID</code>指向自己</li></ul><p>如果对象不处于上面两个状态，说明锁存在线程竞争，在CAS替换失败后会执行<strong>偏向锁撤销</strong>操作。偏向锁的撤销需要等待全局安全点<code>Safe Point</code>（安全点是 jvm为了保证在垃圾回收的过程中引用关系不会发生变化设置的安全状态，在这个状态上会暂停所有线程工作），在这个安全点会挂起获得偏向锁的线程。</p><p>在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：</p><ul><li>如果线程还存活，且线程正在执行同步代码块中的代码，则升级为轻量级锁</li><li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul><li>不允许重偏向，则撤销偏向锁，将<code>mark word</code>升级为轻量级锁，进行CAS竞争锁</li><li>允许重偏向，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程</li></ul></li></ul><p>完成上面的操作后，唤醒暂停的线程，从安全点继续执行代码。可以使用流程图总结上面的过程：</p><p><img src="/posts/8012/640-20240315112202621.png" alt="图片"></p><h4 id="2-2-偏向锁升级"><a href="#2-2-偏向锁升级" class="headerlink" title="2.2 偏向锁升级"></a>2.2 偏向锁升级</h4><p>在上面的过程中，我们已经知道了匿名偏向状态可以变为无锁态或升级为偏向锁，接下来看一下偏向锁的其他状态的改变</p><ul><li>偏向锁升级为轻量级锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    &#125;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    thread.join();<br>    System.out.println(<span class="hljs-string">&quot;--END--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存布局，偏向锁升级为轻量级锁，在执行完成同步代码后释放锁，变为无锁不可偏向状态：</p><p><img src="/posts/8012/640-20240315112202649.png" alt="图片"></p><ul><li>偏向锁升级为重量级锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD1--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>            <span class="hljs-keyword">try</span> &#123;<br>                user.wait(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD END--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    thread.join();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存布局，可以看到在调用了对象的<code>wait()</code>方法后，直接从偏向锁升级成了重量级锁，并在锁释放后变为无锁态：</p><p><img src="/posts/8012/640-20240315112202629.png" alt="图片"></p><p>这里是因为<code>wait()</code>方法调用过程中依赖于重量级锁中与对象关联的<code>monitor</code>，在调用<code>wait()</code>方法后<code>monitor</code>会把线程变为<code>WAITING</code>状态，所以才会强制升级为重量级锁。除此之外，调用<code>hashCode</code>方法时也会使偏向锁直接升级为重量级锁。</p><p>在上面分析的基础上，再加上我们上一篇中讲到的轻量级锁升级到重量级锁的知识，就可以对上面的流程图进行完善了：</p><p><img src="/posts/8012/640-20240315112202623.png" alt="图片"></p><h4 id="2-3-批量重偏向"><a href="#2-3-批量重偏向" class="headerlink" title="2.3 批量重偏向"></a>2.3 批量重偏向</h4><p>在未禁用偏向锁的情况下，当一个线程建立了大量对象，并且对它们执行完同步操作解锁后，所有对象处于偏向锁状态，此时若再来另一个线程也尝试获取这些对象的锁，就会导偏向锁的<strong>批量重偏向</strong>（Bulk Rebias）。当触发批量重偏向后，第一个线程结束同步操作后的锁对象当再被同步访问时会被重置为可重偏向状态，以便允许快速重偏向，这样能够减少撤销偏向锁再升级为轻量级锁的性能消耗。</p><p>首先看一下和偏向锁有关的参数，修改jvm启动参数，使用下面的命令可以在项目启动时打印jvm的默认参数值：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintFlagsFinal</span><br></code></pre></td></tr></table></figure><p>需要关注的属性有下面3个：</p><p><img src="/posts/8012/640-20240315112202630.png" alt="图片"></p><ul><li><code>BiasedLockingBulkRebiasThreshold</code>：偏向锁批量重偏向阈值，默认为20次</li><li><code>BiasedLockingBulkRevokeThreshold</code>：偏向锁批量撤销阈值，默认为40次</li><li><code>BiasedLockingDecayTime</code>：重置计数的延迟时间，默认值为25000毫秒（即25秒）</li></ul><p>批量重偏向是以<code>class</code>而不是对象为单位的，每个<code>class</code>会维护一个偏向锁的撤销计数器，每当该<code>class</code>的对象发生偏向锁的撤销时，该计数器会加一，当这个值达到默认阈值20时，jvm就会认为这个锁对象不再适合原线程，因此进行批量重偏向。而距离上次批量重偏向的25秒内，如果撤销计数达到40，就会发生批量撤销，如果超过25秒，那么就会重置在[20, 40)内的计数。</p><p>上面这段理论是不是听上去有些难理解，没关系，我们先用代码验证批量重偏向的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread t1,t2;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>    List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>    &#125;<br><br>    t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (list.get(i)) &#123;<br>            &#125;<br>        &#125;<br>        LockSupport.unpark(t2);<br>    &#125;);<br>    t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.park();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">18</span> || i == <span class="hljs-number">19</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;THREAD-2 Object&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;:&quot;</span>+ClassLayout.parseInstance(o).toPrintable());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    t2.join();<br><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;Object19:&quot;</span>+ClassLayout.parseInstance(list.get(<span class="hljs-number">18</span>)).toPrintable());<br>    System.out.println(<span class="hljs-string">&quot;Object20:&quot;</span>+ClassLayout.parseInstance(list.get(<span class="hljs-number">19</span>)).toPrintable());<br>    System.out.println(<span class="hljs-string">&quot;Object30:&quot;</span>+ClassLayout.parseInstance(list.get(<span class="hljs-number">29</span>)).toPrintable());<br>    System.out.println(<span class="hljs-string">&quot;Object31:&quot;</span>+ClassLayout.parseInstance(list.get(<span class="hljs-number">30</span>)).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>分析上面的代码，当线程<code>t1</code>运行结束后，数组中所有对象的锁都偏向<code>t1</code>，然后<code>t1</code>唤醒被挂起的线程<code>t2</code>，线程<code>t2</code>尝试获取前30个对象的锁。我们打印线程<code>t2</code>获取到的第19和第20个对象的锁状态：</p><p><img src="/posts/8012/640-20240315112202686.png" alt="图片"></p><p>线程<code>t2</code>在访问前19个对象时对象的偏向锁会升级到轻量级锁，在访问后11个对象（下标19-29）时，因为偏向锁撤销次数达到了20，会触发批量重偏向，将锁的状态变为偏向线程<code>t2</code>。在全部线程结束后，再次查看第19、20、30、31个对象锁的状态：</p><p><img src="/posts/8012/640-20240315112202634.png" alt="图片"></p><p>线程<code>t2</code>结束后，第1-19的对象释放轻量级锁变为无锁不可偏向状态，第20-30的对象状态为偏向锁、但从偏向<code>t1</code>改为偏向<code>t2</code>，第31-40的对象因为没有被线程<code>t2</code>访问所以保持偏向线程<code>t1</code>不变。</p><h4 id="2-4-批量撤销"><a href="#2-4-批量撤销" class="headerlink" title="2.4 批量撤销"></a>2.4 批量撤销</h4><p>在多线程竞争激烈的状况下，使用偏向锁将会导致性能降低，因此产生了批量撤销机制，接下来使用代码进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread t1, t2, t3;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><br>    List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>    &#125;<br><br>    t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (list.get(i)) &#123;<br>            &#125;<br>        &#125;<br>        LockSupport.unpark(t2);<br>    &#125;);<br>    t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.park();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">18</span> || i == <span class="hljs-number">19</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;THREAD-2 Object&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;:&quot;</span>+ClassLayout.parseInstance(o).toPrintable());<br>                &#125;<br>            &#125;<br>        &#125;<br>        LockSupport.unpark(t3);<br>    &#125;);<br>    t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.park();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                System.out.println(<span class="hljs-string">&quot;THREAD-3 Object&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;:&quot;</span>+ClassLayout.parseInstance(o).toPrintable());<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    t1.start();<br>    t2.start();<br>    t3.start();<br>    t3.join();<br>    System.out.println(<span class="hljs-string">&quot;New: &quot;</span>+ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>对上面的运行流程进行分析：</p><ul><li>线程<code>t1</code>中，第1-40的锁对象状态变为偏向锁</li><li>线程<code>t2</code>中，第1-19的锁对象撤销偏向锁升级为轻量级锁，然后对第20-40的对象进行批量重偏向</li><li>线程<code>t3</code>中，首先直接对第1-19个对象竞争轻量级锁，而从第20个对象开始往后的对象不会再次进行批量重偏向，因此第20-39的对象进行偏向锁撤销升级为轻量级锁，这时<code>t2</code>和<code>t3</code>线程一共执行了40次的锁撤销，触发锁的批量撤销机制，对偏向锁进行撤销置为轻量级锁</li></ul><p>看一下在3个线程都结束后创建的新对象：</p><p><img src="/posts/8012/640-20240315112202648.png" alt="图片"></p><p>可以看到，创建的新对象为无锁不可偏向状态<code>001</code>，说明当类触发了批量撤销机制后，jvm会禁用该类创建对象时的可偏向性，该类新创建的对象全部为无锁不可偏向状态。</p><h4 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h4><p>偏向锁通过消除资源无竞争情况下的同步原语，提高了程序在<strong>单线程</strong>下访问同步资源的运行性能，但是当出现多个线程竞争时，就会撤销偏向锁、升级为轻量级锁。</p><p>如果我们的应用系统是高并发、并且代码中同步资源一直是被多线程访问的，那么撤销偏向锁这一步就显得多余，偏向锁撤销时进入<code>Safe Point</code>产生<code>STW</code>的现象应该是被极力避免的，这时应该通过禁用偏向锁来减少性能上的损耗。</p><h3 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3 轻量级锁"></a>3 轻量级锁</h3><h4 id="3-1-轻量级锁原理"><a href="#3-1-轻量级锁原理" class="headerlink" title="3.1 轻量级锁原理"></a>3.1 轻量级锁原理</h4><p>1、在代码访问同步资源时，如果锁对象处于无锁不可偏向状态，jvm首先将在当前线程的栈帧中创建一条锁记录（<code>lock record</code>），用于存放：</p><ul><li><code>displaced mark word</code>（置换标记字）：存放锁对象当前的<code>mark word</code>的拷贝</li><li><code>owner</code>指针：指向当前的锁对象的指针，在拷贝<code>mark word</code>阶段暂时不会处理它</li></ul><p><img src="/posts/8012/640-20240315112202644.png" alt="图片"></p><p>2、在拷贝<code>mark word</code>完成后，首先会挂起线程，jvm使用CAS操作尝试将对象的 <code>mark word</code> 中的 <code>lock record</code> 指针指向栈帧中的锁记录，并将锁记录中的<code>owner</code>指针指向锁对象的<code>mark word</code></p><ul><li>如果CAS替换成功，表示竞争锁对象成功，则将锁标志位设置成 <code>00</code>，表示对象处于轻量级锁状态，执行同步代码中的操作</li></ul><p><img src="/posts/8012/640-20240315112202646.png" alt="图片"></p><ul><li>如果CAS替换失败，则判断当前对象的<code>mark word</code>是否指向当前线程的栈帧：<ul><li>如果是则表示当前线程已经持有对象的锁，执行的是<code>synchronized</code>的锁重入过程，可以直接执行同步代码块</li><li>否则说明该其他线程已经持有了该对象的锁，如果在自旋一定次数后仍未获得锁，那么轻量级锁需要升级为重量级锁，将锁标志位变成<code>10</code>，后面等待的线程将会进入阻塞状态</li></ul></li></ul><p>4、轻量级锁的释放同样使用了CAS操作，尝试将<code>displaced mark word</code> 替换回<code>mark word</code>，这时需要检查锁对象的<code>mark word</code>中<code>lock record</code>指针是否指向当前线程的锁记录：</p><ul><li>如果替换成功，则表示没有竞争发生，整个同步过程就完成了</li><li>如果替换失败，则表示当前锁资源存在竞争，有可能其他线程在这段时间里尝试过获取锁失败，导致自身被挂起，并修改了锁对象的<code>mark word</code>升级为重量级锁，最后在执行重量级锁的解锁流程后唤醒被挂起的线程</li></ul><p>用流程图对上面的过程进行描述：</p><p><img src="/posts/8012/640-20240315112202680.png" alt="图片"></p><h4 id="3-2-轻量级锁重入"><a href="#3-2-轻量级锁重入" class="headerlink" title="3.2 轻量级锁重入"></a>3.2 轻量级锁重入</h4><p>我们知道，<code>synchronized</code>是可以锁重入的，在轻量级锁的情况下重入也是依赖于栈上的<code>lock record</code>完成的。以下面的代码中3次锁重入为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (user)&#123;<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        <span class="hljs-keyword">synchronized</span> (user)&#123;<br>            <span class="hljs-comment">//TODO</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>轻量级锁的每次重入，都会在栈中生成一个<code>lock record</code>，但是保存的数据不同：</p><ul><li>首次分配的<code>lock record</code>，<code>displaced mark word</code>复制了锁对象的<code>mark word</code>，<code>owner</code>指针指向锁对象</li><li>之后重入时在栈中分配的<code>lock record</code>中的<code>displaced mark word</code>为<code>null</code>，只存储了指向对象的<code>owner</code>指针</li></ul><p><img src="/posts/8012/640-20240315112202656.png" alt="图片"></p><p>轻量级锁中，重入的次数等于该锁对象在栈帧中<code>lock record</code>的数量，这个数量隐式地充当了锁重入机制的计数器。这里需要计数的原因是每次解锁都需要对应一次加锁，只有最后解锁次数等于加锁次数时，锁对象才会被真正释放。在释放锁的过程中，如果是重入则删除栈中的<code>lock record</code>，直到没有重入时则使用CAS替换锁对象的<code>mark word</code>。</p><h4 id="3-3-轻量级锁升级"><a href="#3-3-轻量级锁升级" class="headerlink" title="3.3 轻量级锁升级"></a>3.3 轻量级锁升级</h4><p>在jdk1.6以前，默认轻量级锁自旋次数是10次，如果超过这个次数或自旋线程数超过CPU核数的一半，就会升级为重量级锁。这时因为如果自旋次数过多，或过多线程进入自旋，会导致消耗过多cpu资源，重量级锁情况下线程进入等待队列可以降低cpu资源的消耗。自旋次数的值也可以通过jvm参数进行修改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:PreBlockSpin</span><br></code></pre></td></tr></table></figure><p>jdk1.6以后加入了<strong>自适应自旋锁</strong> （<code>Adapative Self Spinning</code>），自旋的次数不再固定，由jvm自己控制，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p><ul><li>对于某个锁对象，如果自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而允许自旋等待持续相对更长时间</li><li>对于某个锁对象，如果自旋很少成功获得过锁，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li></ul><p>下面通过代码验证轻量级锁升级为重量级锁的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    System.out.println(<span class="hljs-string">&quot;--MAIN--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD1--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD2--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>        &#125;<br>    &#125;);<br><br>    thread1.start();<br>    thread2.start();<br>    thread1.join();<br>    thread2.join();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，线程2在启动后休眠两秒后再尝试获取锁，确保线程1能够先得到锁，在此基础上造成锁对象的资源竞争。查看对象锁状态变化：</p><p><img src="/posts/8012/640-20240315112202661.png" alt="图片"></p><p>在线程1持有轻量级锁的情况下，线程2尝试获取锁，导致资源竞争，使轻量级锁升级到重量级锁。在两个线程都运行结束后，可以看到对象的状态恢复为了无锁不可偏向状态，在下一次线程尝试获取锁时，会直接从轻量级锁状态开始。</p><p>上面在最后一次打印前将主线程休眠3秒的原因是锁的释放过程需要一定的时间，如果在线程执行完成后直接打印对象内存布局，对象可能仍处于重量级锁状态。</p><h4 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h4><p>轻量级锁与偏向锁类似，都是jdk对于多线程的优化，不同的是轻量级锁是通过CAS来避免开销较大的互斥操作，而偏向锁是在无资源竞争的情况下完全消除同步。</p><p>轻量级锁的“轻量”是相对于重量级锁而言的，它的性能会稍好一些。轻量级锁尝试利用CAS，在升级为重量级锁之前进行补救，目的是为了减少多线程进入互斥，当多个线程交替执行同步块时，jvm使用轻量级锁来保证同步，避免线程切换的开销，不会造成用户态与内核态的切换。但是如果过度自旋，会引起cpu资源的浪费，这种情况下轻量级锁消耗的资源可能反而会更多。</p><h3 id="4-重量级锁"><a href="#4-重量级锁" class="headerlink" title="4 重量级锁"></a>4 重量级锁</h3><h4 id="4-1-Monitor"><a href="#4-1-Monitor" class="headerlink" title="4.1 Monitor"></a>4.1 Monitor</h4><p>重量级锁是依赖对象内部的monitor（监视器&#x2F;管程）来实现的 ，而monitor 又依赖于操作系统底层的<code>Mutex Lock</code>（互斥锁）实现，这也就是为什么说重量级锁比较“重”的原因了，操作系统在实现线程之间的切换时，需要从用户态切换到内核态，成本非常高。在学习重量级锁的工作原理前，首先需要了解一下monitor中的核心概念：</p><ul><li><code>owner</code>：标识拥有该<code>monitor</code>的线程，初始时和锁被释放后都为null</li><li><code>cxq (ConnectionList)</code>：竞争队列，所有竞争锁的线程都会首先被放入这个队列中</li><li><code>EntryList</code>：候选者列表，当<code>owner</code>解锁时会将<code>cxq</code>队列中的线程移动到该队列中</li><li><code>OnDeck</code>：在将线程从<code>cxq</code>移动到<code>EntryList</code>时，会指定某个线程为Ready状态（即<code>OnDeck</code>），表明它可以竞争锁，如果竞争成功那么称为<code>owner</code>线程，如果失败则放回<code>EntryList</code>中</li><li><code>WaitSet</code>：因为调用<code>wait()</code>或<code>wait(time)</code>方法而被阻塞的线程会被放在该队列中</li><li><code>count</code>：monitor的计数器，数值加1表示当前对象的锁被一个线程获取，线程释放monitor对象时减1</li><li><code>recursions</code>：线程重入次数</li></ul><p>用图来表示线程竞争的的过程：</p><p><img src="/posts/8012/640-20240315112202654.png" alt="图片"></p><p>当线程调用<code>wait()</code>方法，将释放当前持有的monitor，将<code>owner</code>置为null，进入<code>WaitSet</code>集合中等待被唤醒。当有线程调用<code>notify()</code>或<code>notifyAll()</code>方法时，也会释放持有的monitor，并唤醒<code>WaitSet</code>的线程重新参与monitor的竞争。</p><h4 id="4-2-重量级锁原理"><a href="#4-2-重量级锁原理" class="headerlink" title="4.2 重量级锁原理"></a>4.2 重量级锁原理</h4><p>当升级为重量级锁的情况下，锁对象的<code>mark word</code>中的指针不再指向线程栈中的<code>lock record</code>，而是指向堆中与锁对象关联的monitor对象。当多个线程同时访问同步代码时，这些线程会先尝试获取当前锁对象对应的monitor的所有权：</p><ul><li>获取成功，判断当前线程是不是重入，如果是重入那么<code>recursions+1</code></li><li>获取失败，当前线程会被阻塞，等待其他线程解锁后被唤醒，再次竞争锁对象</li></ul><p>在重量级锁的情况下，加解锁的过程涉及到操作系统的<code>Mutex Lock</code>进行互斥操作，线程间的调度和线程的状态变更过程需要在用户态和核心态之间进行切换，会导致消耗大量的cpu资源，导致性能降低。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在jdk1.6中，引入了偏向锁和轻量级锁，并使用锁升级机制对<code>synchronized</code>进行了充分的优化。其实除锁升级外，还使用了锁消除、锁粗化等优化手段，所以对它的认识要脱离“重量级”这一概念，不要再单纯的认为它的性能差了。在某些场景下，<code>synchronized</code>的性能甚至已经超过了<code>Lock</code>同步锁。</p><p>尽管 Java对<code>synchronized</code>做了这些优化，但是在使用过程中，我们还是要尽量减少锁的竞争，通过减小加锁粒度和减少同步代码的执行时间，来降低锁竞争，尽量使锁维持在偏向锁和轻量级锁的级别，避免升级为重量级锁，造成性能的损耗。</p><p>最后不得不再提一句，在 Java 15中已经默认禁用了偏向锁，并弃用所有相关的命令行选项，虽然说不确定未来的LTS版本会怎样改动，但是了解一下偏向锁的基础也没什么不好的，毕竟你发任你发，大家都用 Java 8</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>synchronized</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题</title>
    <link href="/posts/53971.html"/>
    <url>/posts/53971.html</url>
    
    <content type="html"><![CDATA[<ol><li>所有的final修饰的字段都是编译期常量吗?</li></ol><p>不是的，只有被final修饰的字段同时满足是基本数据类型或者String，并且在编译期间就可以确定值的情况下，才能被视为编译期常量。例如，<code>final int x = 1;</code>和<code>final String s = &quot;Hello&quot;;</code>是编译期常量，但<code>final Object o = new Object();</code>就不是，因为o的值需要在运行时才能确定。</p><ol start="2"><li>如何理解private所修饰的方法是隐式的final?</li></ol><p>这是因为private方法只能在当前类中被访问，不能被其他类访问，更不能被其他类重写。因此，虽然我们没有显式地将private方法标记为final，但它们的行为类似于final方法。</p><ol start="3"><li>final类型的类如何拓展?</li></ol><p>final类型的类不能被继承，这是final关键字的一个重要特性。如果你想写一个类，复用所有String中的方法，同时增加一个新的toMyString()的方法，你可以创建一个新的类，该类内部持有一个String对象，然后提供所有String类的方法的代理实现，同时添加toMyString()方法。这种模式被称为组合。</p><ol start="4"><li>final方法可以被重载吗? 可以父类的final方法能不能够被子类重写?</li></ol><p>final方法可以在同一个类中被重载，这是因为重载是在同一个类中，方法名相同但参数列表不同的多个方法共存。但是，final方法不能被子类重写，这是final关键字的主要特性之一。</p><ol start="5"><li>final域重排序规则?</li></ol><p>final域重排序规则是指在构造函数中对final字段的赋值操作，必须在构造函数执行完毕之前完成。这是为了保证在对象被其他线程引用之前，final字段已经被初始化完毕，从而保证了final字段的不变性。</p><ol start="6"><li>final的原理?</li></ol><p>final关键字的原理主要体现在Java编译器和JVM的实现上。在Java编译器层面，对于final变量，如果编译时可以确定其值，那么编译器会在编译时就将这个值写入到使用该常量的字节码中。对于final方法，编译器会禁止子类重写这个方法。对于final类，编译器会禁止其他类继承这个类。</p><p>在JVM层面，对于final字段，JVM会保证在构造函数执行完毕之前，这个字段已经被初始化。此外，JVM还会为final字段生成专门的字节码指令。</p><ol start="7"><li>使用final的限制条件和局限性?</li></ol><p>final关键字有以下的限制条件和局限性：</p><ul><li>final变量：一旦被初始化后，其值就不能被修改。</li><li>final方法：不能被子类重写，但可以被子类继承和使用。</li><li>final类：不能被继承，但可以被实例化。</li><li>final参数：在方法内部不能修改参数的值。</li></ul><p>这些限制条件在某些情况下可能会限制代码的灵活性，但是它们也提供了一些好处，比如提高了代码的安全性和可读性，以及在某些情况下可以提高代码的执行效率。</p><ol><li><code>volatile</code>关键字的作用是什么?</li></ol><p><code>volatile</code>是Java中的一种类型修饰符，用于标识一个变量可能会被多个线程同时修改和访问，其主要作用是保证变量的可见性和有序性。</p><ol start="2"><li><code>volatile</code>能保证原子性吗?</li></ol><p><code>volatile</code>不能保证复杂操作的原子性。例如，对于<code>volatile int i</code>，<code>i++</code>这种操作不能保证原子性，因为它实际上是一个复合操作，包括读取、修改和写入三个步骤。但是，对于单个的读操作或写操作，<code>volatile</code>可以保证其原子性。</p><ol start="3"><li>之前32位机器上共享的<code>long</code>和<code>double</code>变量的为什么要用<code>volatile</code>?</li></ol><p>在32位的JVM中，<code>long</code>和<code>double</code>类型的变量的读写可能会被拆分成两个32位的操作，这可能会导致其他线程在读取这个变量的时候，看到一个既不是旧值也不是新值的中间状态。使用<code>volatile</code>可以防止这种情况发生，因为<code>volatile</code>可以保证对这些变量的读写操作的原子性。</p><ol start="4"><li>现在64位机器上是否也要设置呢?</li></ol><p>在64位的JVM中，<code>long</code>和<code>double</code>类型的变量的读写操作默认就是原子的，所以在大多数情况下，我们不再需要使用<code>volatile</code>来保证它们的原子性。但是，如果这些变量需要被多个线程共享，我们仍然需要使用<code>volatile</code>来保证它们的可见性。</p><ol start="5"><li><code>i++</code>为什么不能保证原子性?</li></ol><p><code>i++</code>实际上是一个复合操作，包括读取、修改和写入三个步骤。在这三个步骤中，都有可能被其他线程的操作打断，从而导致结果不符合预期。只有通过同步机制（例如<code>synchronized</code>或<code>Lock</code>），或者使用原子类（例如<code>AtomicInteger</code>），才能保证<code>i++</code>操作的原子性。</p><ol start="6"><li><code>volatile</code>是如何实现可见性的?</li></ol><p><code>volatile</code>通过内存屏障来实现可见性。当一个线程修改了一个<code>volatile</code>变量后，它会立即将修改写入到主内存中，而不是缓存在CPU的缓存中。当另一个线程读取这个<code>volatile</code>变量时，它会直接从主内存中读取，而不是从CPU的缓存中读取，从而保证了可见性。</p><ol start="7"><li><code>volatile</code>是如何实现有序性的?</li></ol><p><code>volatile</code>通过禁止指令重排来实现有序性。在JVM中，为了提高执行效率，编译器和处理器可能会对指令进行重排。但是，如果两个操作之间存在数据依赖性，这种重排可能会导致结果不符合预期。<code>volatile</code>可以阻止这种重排，从而保证有序性。</p><ol start="8"><li><code>volatile</code>的应用场景?</li></ol><p><code>volatile</code>主要用于多线程环境，当一个变量需要被多个线程共享，且不需要同步，只需要保证可见性和有序性时，可以使用<code>volatile</code>。例如，一个线程修改了一个标志位，另一个线程需要根据这个标志位来决定是否继续执行，这种情况下就可以使用<code>volatile</code>。</p><p>Java的并发（Concurrency）工具类库Java.util.concurrent（JUC）主要包含以下几个部分：</p><ol><li><p>基础设施：提供了Java并发编程的基本接口和类，如Runnable、Callable、Future和Thread等。</p></li><li><p>同步器：这部分主要提供了各种同步工具类，如Semaphore（信号量）、CountDownLatch（倒计时门闩）、CyclicBarrier（循环栅栏）、Exchanger（数据交换器）等。</p></li><li><p>并发集合：这部分提供了多种并发集合类，如ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等。</p></li><li><p>Executor框架：这部分提供了线程池框架，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor等。</p></li><li><p>锁：提供了多种锁相关的类，如ReentrantLock、ReentrantReadWriteLock、StampedLock等。</p></li><li><p>原子变量：提供了一系列的原子操作类，如AtomicInteger、AtomicLong、AtomicReference等。</p></li></ol><p>每个部分的核心类如下：</p><ol><li><p>基础设施：Thread、Runnable、Callable、Future。</p></li><li><p>同步器：Semaphore、CountDownLatch、CyclicBarrier、Exchanger。</p></li><li><p>并发集合：ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue。</p></li><li><p>Executor框架：Executor、ExecutorService、ThreadPoolExecutor、ScheduledExecutorService。</p></li><li><p>锁：Lock、ReentrantLock、ReentrantReadWriteLock、StampedLock。</p></li><li><p>原子变量：AtomicInteger、AtomicLong、AtomicReference。</p></li></ol><p>最最核心的类有：</p><ul><li>基础设施：Thread、Future。</li><li>同步器：Semaphore、CountDownLatch。</li><li>并发集合：ConcurrentHashMap、BlockingQueue。</li><li>Executor框架：ExecutorService、ThreadPoolExecutor。</li><li>锁：ReentrantLock。</li><li>原子变量：AtomicInteger。</li></ul><p>以上类是并发编程中经常会用到的类，它们提供了丰富的功能，可以满足大部分并发编程的需求。</p><ol><li>线程安全的实现方法有哪些？</li></ol><p>线程安全主要有以下几种实现方式：</p><ul><li>同步（Synchronized）：通过Java的关键字<code>synchronized</code>实现，它保证了同一时刻对数据的访问和操作只有一个线程。</li><li>锁（Lock）：Java提供了更加灵活的锁机制，如ReentrantLock，可以实现公平锁和非公平锁，还提供了条件锁等高级功能。</li><li>原子类（Atomic）：Java提供了一系列的原子类，如AtomicInteger、AtomicLong、AtomicReference等，它们通过CAS（Compare And Swap）操作实现线程安全。</li><li>并发容器：Java提供了一系列并发容器，如ConcurrentHashMap、CopyOnWriteArrayList等，它们内部都实现了线程安全。</li><li>线程局部变量（ThreadLocal）：通过为每个线程创建独立的变量副本，实现线程安全。</li></ul><ol start="2"><li>什么是CAS？</li></ol><p>CAS，全称Compare And Swap，即比较并交换。它是一种无锁的线程安全实现方式。CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。如果内存位置的当前值与预期原值相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。</p><ol start="3"><li>CAS使用示例，结合AtomicInteger给出示例？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">expect</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>atomicInteger.compareAndSet(expect, update);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个AtomicInteger对象，并设置其初始值为0。然后我们期望它的值仍然为0（expect），如果是，我们将其更新为1（update）。</p><ol start="4"><li>CAS会有哪些问题？</li></ol><p>CAS主要有以下几个问题：</p><ul><li>ABA问题：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现该值没有发生变化，但是实际上该值已经被其他线程修改过了。</li><li>循环时间长开销大：CAS是一种自旋操作，如果不断地CAS失败，会消耗大量的CPU资源。</li><li>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，CAS能够保证该变量的原子性，但是对于多个共享变量，CAS就无法保证其原子性。</li></ul><ol start="5"><li>针对这些问题，Java提供了哪几个解决的？</li></ol><ul><li>ABA问题：Java提供了AtomicStampedReference和AtomicMarkableReference等类来解决ABA问题，它们通过给每个值加上一个版本号或标记来实现。</li><li>循环时间长开销大：可以通过限制CAS重试的次数来减少CPU的消耗。</li><li>只能保证一个共享变量的原子操作：可以通过AtomicReference来保证多个共享变量的原子性。</li></ul><ol start="6"><li>AtomicInteger底层实现？</li></ol><p>AtomicInteger的底层主要依赖Unsafe类提供的原生方法，如<code>compareAndSwapInt</code>来实现CAS操作，从而实现原子性。</p><ol start="7"><li>CAS+volatile请阐述你对Unsafe类的理解？</li></ol><p>Unsafe类提供了一些低层次的、操作系统级别的API，包括直接访问系统内存、执行类似于C语言的指针操作等。在AtomicInteger等原子类的实现中，主要利用了Unsafe类提供的CAS操作和volatile的内存语义，来实现线程安全的原子操作。</p><ol start="8"><li>说说你对Java原子类的理解？</li></ol><p>Java的原子类主要包括AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference等，它们提供了一种无锁的线程安全实现方式。这些类内部主要依赖Unsafe类提供的CAS操作来实现线程安全。它们通常用于在高并发环境下替代synchronized或Lock，因为它们的性能通常更高。</p><ol start="9"><li>AtomicStampedReference是什么？</li></ol><p>AtomicStampedReference是一个带有”时间戳”（或者说是版本号）的引用类型的原子类，它可以解决CAS操作的ABA问题。它通过将版本号和值一起进行CAS操作，来保证线程安全。</p><ol start="10"><li>AtomicStampedReference是怎么解决ABA的？</li></ol><p>AtomicStampedReference通过给每个值加上一个版本号（或者说是时间戳）来解决ABA问题。在每次操作的时候，不仅要比较值是否相等，还要比较版本号是否相等。如果版本号不相等，即使值相等，CAS操作也会失败。</p><ol start="11"><li>内部使用Pair来存储元素值及其版本号java中还有哪些类可以解决ABA的问题？</li></ol><p>除了AtomicStampedReference外，Java还提供了AtomicMarkableReference来解决ABA问题。AtomicMarkableReference通过给每个值加上一个布尔标记来解决ABA问题。在每次操作的时候，不仅要比较值是否相等，还要比较标记是否相等。如果标记不相等，即使值相等，CAS操作也会失败。</p><ol><li>为什么LockSupport也是核心基础类？</li></ol><p>LockSupport是Java并发编程的核心类之一，它提供了基本的线程同步原语。LockSupport类是构建许多同步组件和工具的基础，包括ForkJoinPool、FutureTask、AbstractQueuedSynchronizer（AQS）和ReentrantLock等。LockSupport中的park()和unpark()方法提供了一种安全和高效的方式来暂停和恢复线程。</p><ol start="2"><li>AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park&#x2F;unpark操作)</li></ol><p>AQS是AbstractQueuedSynchronizer的简称，它是Java并发包中的一个基础框架，用于构建锁和同步组件。AQS内部通过一个int成员变量来表示同步状态，并提供了修改同步状态的方法。这些方法基于Unsafe类提供的CAS操作，以实现同步状态管理的线程安全。</p><p>同时，AQS使用了LockSupport的park()和unpark()方法来挂起和唤醒线程。当获取同步状态失败时，线程会被AQS通过LockSupport.park()方法挂起；当同步状态释放时，被挂起的线程会被AQS通过LockSupport.unpark()方法唤醒。</p><ol start="3"><li>写出分别通过wait&#x2F;notify和LockSupport的park&#x2F;unpark实现同步的代码</li></ol><p>通过wait&#x2F;notify实现同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            obj.wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notify();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>通过LockSupport的park&#x2F;unpark实现同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    LockSupport.park();<br>&#125;);<br>t1.start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    LockSupport.unpark(t1);<br>&#125;).start();<br></code></pre></td></tr></table></figure><ol start="4"><li>LockSupport.park()会释放锁资源吗？那么Condition.await()呢？</li></ol><p>LockSupport.park()不会释放任何锁资源，它只是让当前线程进入等待状态。而Condition.await()方法会释放与Condition相关联的Lock锁。</p><ol start="5"><li>Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别？</li></ol><ul><li>Thread.sleep()：使当前线程进入TIMED_WAITING状态，不释放锁，指定时间后线程自动恢复。</li><li>Object.wait()：使当前线程进入WAITING状态，同时会释放锁，需要被其他线程调用notify&#x2F;notifyAll唤醒。</li><li>Condition.await()：使当前线程进入WAITING状态，同时会释放与Condition相关联的Lock锁，需要被其他线程调用Condition的signal&#x2F;signalAll唤醒。</li><li>LockSupport.park()：使当前线程进入WAITING状态，不释放任何锁资源，需要被其他线程调用LockSupport的unpark方法唤醒。</li></ul><ol start="6"><li>如果在wait()之前执行了notify()会怎样？如果在park()之前执行了unpark()会怎样？</li></ol><p>如果在wait()之前执行了notify()，那么这个notify()的唤醒效果就会被忽略，因为没有线程在等待状态，所以wait()方法会让线程进入无限期的等待状态，除非有其他线程再次调用notify()。</p><p>而如果在park()之前执行了unpark()，那么下一次调用park()时，不会阻塞，因为unpark()具有许可的特性，可以先于park()调用，也就是说unpark()的唤醒效果可以被先行保留。</p><ol><li>什么是AQS？</li></ol><p>AQS，全称为AbstractQueuedSynchronizer，是Java并发包中的一个抽象类，它为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（如semaphores、events）提供了一个框架。AQS解决了实现同步器的大部分细节问题，自定义同步组件只需要实现共享和独占模式下获取和释放同步状态的方法即可。</p><ol start="2"><li>为什么它是核心？</li></ol><p>AQS是Java并发包中的核心组件，许多高级同步工具，如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等，都是基于AQS实现的。AQS通过内部的同步队列来管理阻塞的线程，提供了丰富的状态操作方法，简化了同步器的实现。</p><ol start="3"><li>AQS的核心思想是什么？</li></ol><p>AQS的核心思想是，如果被请求的状态未被当前线程持有，则该线程将会被加入到队列中，并在其线程调度的turn时被唤醒；如果恰好获取到了可以满足其需求的状态，那么该线程将会从该等待队列中移除，并且得以执行。</p><ol start="4"><li>AQS是怎么实现的？底层数据结构等</li></ol><p>AQS的底层数据结构是一个双向链表（FIFO），用于维护等待获取资源的线程。AQS通过一个int类型的成员变量state来控制同步状态，通过内部的ConditionObject类来支持条件变量。</p><ol start="5"><li>AQS有哪些核心的方法？</li></ol><p>AQS的核心方法主要有以下几个：</p><ul><li>acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态失败，则会进入同步队列等待，同时会阻塞当前线程。</li><li>release(int arg)：独占式释放同步状态，会唤醒后继节点。</li><li>acquireShared(int arg)：共享式获取同步状态，如果当前线程获取同步状态失败，则会进入同步队列等待，同时会阻塞当前线程。</li><li>releaseShared(int arg)：共享式释放同步状态，会唤醒后继节点。</li></ul><ol start="6"><li>AQS定义什么样的资源获取方式？</li></ol><p>AQS定义了两种资源获取方式：独占模式和共享模式。</p><ul><li>独占模式：只有一个线程能执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock。</li><li>共享模式：多个线程可同时执行，如Semaphore、CountDownLatch、CyclicBarrier。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。</li></ul><ol start="7"><li>AQS底层使用了什么样的设计模式？</li></ol><p>AQS底层使用了模板方法设计模式，定义了一套同步器的操作流程。子类通过实现AQS的几个protected方法来改变同步器的行为。</p><ol start="8"><li>AQS的应用示例？</li></ol><p>ReentrantLock和Semaphore都是AQS的典型应用。ReentrantLock是一种基于AQS实现的可重入独占锁，Semaphore则是一种基于AQS实现的多线程并发控制工具。</p><ol><li>什么是可重入，什么是可重入锁？</li></ol><p>可重入，又称为递归调用，是指在同一个线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。换句话说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p><p>可重入锁，是指一个线程可以多次获取同一把锁。例如，一个线程在持有锁的情况下，再次请求同一把锁，如果这把锁是可重入的，那么请求会成功。</p><ol start="2"><li>它用来解决什么问题？</li></ol><p>可重入锁主要解决了方法或者代码块的重复调用的问题，避免了因重入造成的死锁问题。</p><ol start="3"><li>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗？说说其类内部结构关系。</li></ol><p>ReentrantLock的核心是AQS，它通过内部类（FairSync和NonfairSync）继承AQS来实现的。这两个内部类分别实现了公平锁和非公平锁的逻辑。ReentrantLock在创建时，会根据传入的公平性参数，实例化对应的Sync对象。</p><ol start="4"><li>ReentrantLock是如何实现公平锁的？ReentrantLock是如何实现非公平锁的？</li></ol><ul><li>公平锁：通过队列来实现公平性。当锁被请求时，如果有其他线程正在等待，或者锁已经被其他线程持有，那么请求的线程会被加入到队列的尾部，并且不会试图去获取锁，直到它的turn。</li><li>非公平锁：当锁被请求时，会首先尝试去获取锁，如果获取失败，才会进入等待队列。</li></ul><ol start="5"><li>ReentrantLock默认实现的是公平还是非公平锁？</li></ol><p>ReentrantLock默认实现的是非公平锁。</p><ol start="6"><li>使用ReentrantLock实现公平和非公平锁的示例？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">nonfairLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 或者 new ReentrantLock(false);</span><br></code></pre></td></tr></table></figure><ol start="7"><li>ReentrantLock和Synchronized的对比？</li></ol><ul><li>ReentrantLock和synchronized都是可重入锁，都支持公平和非公平锁，但是ReentrantLock需要显式解锁，synchronized会在代码块结束时自动解锁。</li><li>ReentrantLock提供了更高级的功能，例如能够中断等待锁的线程，或者限时等待获取锁，而synchronized则不具备这些功能。</li><li>ReentrantLock通过Condition类提供了分组唤醒需要唤醒的线程的能力，而synchronized则只能随机唤醒一个线程或者唤醒所有线程。</li><li>ReentrantLock的性能通常比synchronized要好。</li></ul><ol><li>为什么有了ReentrantLock还需要ReentrantReadWriteLock？</li></ol><p>ReentrantLock是一个独占锁，同一时间只能有一个线程获取锁。在某些读多写少的场景下，如果使用ReentrantLock可能会导致并发性能较差，因为读操作并不需要互斥。ReentrantReadWriteLock引入了读锁和写锁的概念，读锁是共享的，写锁是独占的，这样在读多写少的场景下，读操作可以并发进行，提高了并发性能。</p><ol start="2"><li>ReentrantReadWriteLock底层实现原理？</li></ol><p>ReentrantReadWriteLock的实现也是基于AQS的。它通过一个int变量来表示读锁和写锁的状态，高16位表示读锁，低16位表示写锁。读锁是共享的，写锁是独占的。</p><ol start="3"><li>ReentrantReadWriteLock底层读写状态如何设计的？</li></ol><p>ReentrantReadWriteLock的状态是由一个int变量表示的，这个int变量的高16位表示读锁的重入次数，低16位表示写锁的重入次数。</p><ol start="4"><li>读锁和写锁的最大数量是多少？</li></ol><p>由于ReentrantReadWriteLock的状态是由一个int变量表示的，所以读锁和写锁的最大数量是2^16-1，即65535。</p><ol start="5"><li>本地线程计数器ThreadLocalHoldCounter是用来做什么的？</li></ol><p>ThreadLocalHoldCounter用于保存当前线程获取读锁的重入次数。</p><ol start="6"><li>缓存计数器HoldCounter是用来做什么的？</li></ol><p>HoldCounter是ThreadLocalHoldCounter的一个优化，用于减少ThreadLocal的查询次数。</p><ol start="7"><li>写锁的获取与释放是怎么实现的？</li></ol><p>写锁的获取和释放是通过AQS的acquire和release方法实现的。</p><ol start="8"><li>读锁的获取与释放是怎么实现的？</li></ol><p>读锁的获取和释放是通过AQS的acquireShared和releaseShared方法实现的。</p><ol start="9"><li>RentrantReadWriteLock为什么不支持锁升级？</li></ol><p>锁升级是指一个线程在持有读锁的情况下，再尝试获取写锁，这种情况在ReentrantReadWriteLock中是不被允许的，因为这可能会导致死锁。例如，线程A持有读锁，线程B尝试获取写锁但失败，然后阻塞；此时，如果线程A尝试获取写锁（即尝试锁升级），那么线程A也会阻塞，这样就形成了死锁。</p><ol start="10"><li>什么是锁的升降级？</li></ol><p>锁的升级是指一个线程在持有读锁的情况下，再尝试获取写锁。锁的降级是指一个线程在持有写锁的情况下，再尝试获取读锁，然后释放写锁。ReentrantReadWriteLock支持锁的降级，但不支持锁的升级。</p><ol><li>为什么HashTable慢？它的并发度是什么？</li></ol><p>HashTable是线程安全的，它的线程安全是通过在修改数据时锁定整个HashTable来实现的。这意味着任何时候只能有一个线程能访问HashTable，这就是HashTable的并发度。这种方式在并发度较低时效率是可以接受的，但是在并发度较高时，由于大量线程阻塞等待获取锁，效率会变得非常低。</p><ol start="2"><li>ConcurrentHashMap并发度是什么？</li></ol><p>ConcurrentHashMap的并发度是它的分段锁的数量。在JDK1.7中，ConcurrentHashMap内部使用一个Segment数组，每个Segment对象持有一个锁，一个Segment内部包含一个HashEntry数组，每个HashEntry对象就是一个键值对。不同的Segment之间可以并发操作。在JDK1.8中，ConcurrentHashMap取消了Segment的概念，直接用Node数组实现，每个Node就是一个键值对，对Node数组的不同部分可以并发操作。</p><ol start="3"><li>ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别？</li></ol><p>JDK1.7的ConcurrentHashMap使用分段锁机制，每个Segment持有一个锁，Segment的数量就是并发度。JDK1.8的ConcurrentHashMap取消了Segment的概念，直接使用Node数组和CAS操作来实现并发操作，提高了并发度。</p><ol start="4"><li>JDK1.8解决了JDK1.7中什么问题？</li></ol><p>JDK1.8的ConcurrentHashMap解决了JDK1.7中并发度受限于Segment数量的问题，通过取消Segment的概念，提高了并发度。同时，JDK1.8的ConcurrentHashMap在处理哈希冲突时，引入了红黑树，提高了在高哈希冲突时的性能。</p><ol start="5"><li>ConcurrentHashMap JDK1.7实现的原理是什么？</li></ol><p>JDK1.7的ConcurrentHashMap使用分段锁机制，内部使用一个Segment数组，每个Segment对象持有一个锁，每个Segment内部包含一个HashEntry数组，每个HashEntry对象就是一个键值对。对不同的Segment的操作可以并发进行，每个Segment的操作是互斥的。</p><ol start="6"><li>ConcurrentHashMap JDK1.8实现的原理是什么？</li></ol><p>JDK1.8的ConcurrentHashMap取消了Segment的概念，直接使用Node数组和CAS操作来实现并发操作。对Node数组的不同部分可以并发操作，每个Node就是一个键值对。在处理哈希冲突时，如果链表长度超过一定阈值（默认为8），链表会转化为红黑树，提高查找效率。</p><ol start="7"><li>ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少？</li></ol><p>JDK1.7中ConcurrentHashMap的默认并发级别（concurrencyLevel）是16，也就是说默认会创建16个Segment。</p><ol start="8"><li>为何一旦初始化就不可再扩容？</li></ol><p>Segment数组的长度一旦初始化，就不能再进行扩容，这是因为Segment数组的长度决定了ConcurrentHashMap的并发度，如果允许扩容，那么在扩容过程中，需要重新分配键到新的Segment，这会带来较大的性能开销，并且在扩容过程中，需要锁定整个ConcurrentHashMap，降低并发性能。</p><ol start="9"><li>ConcurrentHashMap JDK1.7说说其put的机制？</li></ol><p>JDK1.7中ConcurrentHashMap的put操作首先会定位到具体的Segment（通过hash值），然后对该Segment加锁，接着在Segment内部的HashEntry数组中查找是否已经存在该键，如果存在则更新值，如果不存在则在数组对应的位置创建新的HashEntry。</p><ol start="10"><li>ConcurrentHashMap JDK1.7是如何扩容的？</li></ol><p>JDK1.7中ConcurrentHashMap的扩容是针对Segment内部的HashEntry数组进行的，当数组的元素数量超过阈值时，会触发扩容操作，扩容后数组的长度是原来的两倍。扩容操作需要对Segment加锁，保证扩容操作的线程安全。</p><ol start="11"><li>ConcurrentHashMap JDK1.8是如何扩容的？</li></ol><p>JDK1.8中ConcurrentHashMap的扩容是针对整个Node数组进行的，当数组的元素数量超过阈值时，会触发扩容操作，扩容后数组的长度是原来的两倍。扩容操作使用CAS操作，无需锁定整个数组，提高了并发性能。</p><ol start="12"><li>ConcurrentHashMap JDK1.8链表转红黑树的时机是什么？临界值为什么是8？</li></ol><p>当链表的长度超过阈值（默认为8）时，链表会转化为红黑树。这个阈值是通过经验得出的，当链表长度超过8时，链表的查找性能开始下降，而红黑树的查找性能则优于链表。</p><ol start="13"><li>ConcurrentHashMap JDK1.8是如何进行数据迁移的？</li></ol><p>JDK1.8中ConcurrentHashMap的数据迁移是在扩容时进行的。在扩容过程中，会创建一个新的Node数组，然后将旧数组的元素迁移到新数组中。迁移操作使用CAS操作，无需锁定整个数组，提高了并发性能。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 内存对象布局</title>
    <link href="/posts/11363.html"/>
    <url>/posts/11363.html</url>
    
    <content type="html"><![CDATA[<p>作为一名Java程序员，在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过<code>new</code>、反射、<code>clone</code>、反序列化等不同方式来创建，但最终使用时对象都要被放到内存中，那么你知道在内存中的java对象是由哪些部分组成、又是怎么存储的吗？</p><p>本文将基于代码进行实例测试，详细探讨对象在内存中的组成结构。全文目录结构如下：</p><ul><li>1、对象内存结构概述</li><li>2、JOL 工具简介</li><li>3、对象头</li><li>4、实例数据</li><li>5、对齐填充字节</li><li>6、总结</li></ul><blockquote><p>文中代码基于 JDK 1.8.0_261，64-Bit HotSpot 运行</p></blockquote><h3 id="1、对象内存结构概述"><a href="#1、对象内存结构概述" class="headerlink" title="1、对象内存结构概述"></a>1、对象内存结构概述</h3><p>在介绍对象在内存中的组成结构前，我们先简要回顾一个对象的创建过程：</p><p>1、jvm将对象所在的<code>class</code>文件加载到方法区中</p><p>2、jvm读取<code>main</code>方法入口，将<code>main</code>方法入栈，执行创建对象代码</p><p>3、在<code>main</code>方法的栈内存中分配对象的引用，在堆中分配内存放入创建的对象，并将栈中的引用指向堆中的对象</p><p>所以当对象在实例化完成之后，是被存放在堆内存中的，这里的对象由3部分组成，如下图所示：</p><p><img src="/posts/11363/640-20240315111906850.png" alt="图片"></p><p>对各个组成部分的功能简要进行说明：</p><ul><li>对象头：对象头存储的是对象在运行时状态的相关信息、指向该对象所属类的元数据的指针，如果对象是数组对象那么还会额外存储对象的数组长度</li><li>实例数据：实例数据存储的是对象的真正有效数据，也就是各个属性字段的值，如果在拥有父类的情况下，还会包含父类的字段。字段的存储顺序会受到数据类型长度、以及虚拟机的分配策略的影响</li><li>对齐填充字节：在java对象中，需要对齐填充字节的原因是，64位的jvm中对象的大小被要求向8字节对齐，因此当对象的长度不足8字节的整数倍时，需要在对象中进行填充操作。注意图中对齐填充部分使用了虚线，这是因为填充字节并不是固定存在的部分，这点在后面计算对象大小时具体进行说明</li></ul><h3 id="2、JOL-工具简介"><a href="#2、JOL-工具简介" class="headerlink" title="2、JOL 工具简介"></a>2、JOL 工具简介</h3><p>在具体开始研究对象的内存结构之前，先介绍一下我们要用到的工具，<code>openjdk</code>官网提供了查看对象内存布局的工具<code>jol (java object layout)</code>，可在<code>maven</code>中引入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在代码中使用<code>jol</code>提供的方法查看jvm信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(VM.current().details());<br></code></pre></td></tr></table></figure><p><img src="/posts/11363/640-20240315111906972.png" alt="图片"></p><p>通过打印出来的信息，可以看到我们使用的是64位 jvm，并开启了指针压缩，对象默认使用8字节对齐方式。通过<code>jol</code>查看对象内存布局的方法，将在后面的例子中具体展示，下面开始对象内存布局的正式学习。</p><h3 id="3、对象头"><a href="#3、对象头" class="headerlink" title="3、对象头"></a>3、对象头</h3><p>首先看一下对象头（<code>Object header</code>）的组成部分，根据普通对象和数组对象的不同，结构将会有所不同。只有当对象是数组对象才会有数组长度部分，普通对象没有该部分，如下图所示：</p><p><img src="/posts/11363/640-20240315111906975.png" alt="图片"></p><p>在对象头中<code>mark word</code> 占8字节，默认开启指针压缩的情况下<code>klass pointer</code> 占4字节，数组对象的数组长度占4字节。在了解了对象头的基础结构后，现在以一个不包含任何属性的空对象为例，查看一下它的内存布局，创建<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>jol</code>查看对象头的内存布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-comment">//查看对象的内存布局</span><br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>执行代码，查看打印信息：</p><p><img src="/posts/11363/640-20240315111906938.png" alt="图片"></p><ul><li><code>OFFSET</code>：偏移地址，单位为字节</li><li><code>SIZE</code>：占用内存大小，单位为字节</li><li><code>TYPE</code>：<code>Class</code>中定义的类型</li><li><code>DESCRIPTION</code>：类型描述，<code>Obejct header</code> 表示对象头，<code>alignment</code>表示对齐填充</li><li><code>VALUE</code>：对应内存中存储的值</li></ul><p>当前对象共占用16字节，因为8字节标记字加4字节的类型指针，不满足向8字节对齐，因此需要填充4个字节：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">8</span>B <span class="hljs-comment">(mark word)</span> + <span class="hljs-number">4</span>B <span class="hljs-comment">(klass pointer)</span> + <span class="hljs-number">0</span>B <span class="hljs-comment">(instance data)</span> + <span class="hljs-number">4</span>B <span class="hljs-comment">(padding)</span><br></code></pre></td></tr></table></figure><p>这样我们就通过直观的方式，了解了一个不包含属性的最简单的空对象，在内存中的基本组成是怎样的。在此基础上，我们来深入学习对象头中各个组成部分。</p><h4 id="3-1-Mark-Word-标记字"><a href="#3-1-Mark-Word-标记字" class="headerlink" title="3.1 Mark Word 标记字"></a>3.1 Mark Word 标记字</h4><p>在对象头中，<code>mark word</code> 一共有64个bit，用于存储对象自身的运行时数据，标记对象处于以下5种状态中的某一种：</p><p><img src="/posts/11363/640-20240315111906911.png" alt="图片"></p><h5 id="3-1-1-基于mark-word的锁升级"><a href="#3-1-1-基于mark-word的锁升级" class="headerlink" title="3.1.1 基于mark word的锁升级"></a>3.1.1 基于mark word的锁升级</h5><p>在jdk6 之前，通过<code>synchronized</code>关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使cpu在用户态和核心态之间频繁切换。随着对<code>synchronized</code>的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。在<code>mark word</code>中，锁（<code>lock</code>）标志位占用2个bit，结合1个bit偏向锁（<code>biased_lock</code>）标志位，这样通过倒数的3位，就能用来标识当前对象持有的锁的状态，并判断出其余位存储的是什么信息。</p><p>基于<code>mark word</code>的锁升级的流程如下：</p><p>1、锁对象刚创建时，没有任何线程竞争，对象处于无锁状态。在上面打印的空对象的内存布局中，根据大小端，得到最后8位是<code>00000001</code>，表示处于无锁态，并且处于不可偏向状态。这是因为在jdk中偏向锁存在延迟4秒启动，也就是说在jvm启动后4秒后创建的对象才会开启偏向锁，我们通过jvm参数取消这个延迟时间：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">BiasedLockingStartupDelay</span>=0<br></code></pre></td></tr></table></figure><p><img src="/posts/11363/640-20240315111907061.png" alt="图片"></p><p>这时最后3位为<code>101</code>，表示当前对象的锁没有被持有，并且处于可被偏向状态。</p><p>2、在没有线程竞争的条件下，第一个获取锁的线程通过<code>CAS</code>将自己的<code>threadId</code>写入到该对象的<code>mark word</code>中，若后续该线程再次获取锁，需要比较当前线程<code>threadId</code>和对象<code>mark word</code>中的<code>threadId</code>是否一致，如果一致那么可以直接获取，并且锁对象始终保持对该线程的偏向，也就是说偏向锁不会主动释放。</p><p>使用代码进行测试同一个线程重复获取锁的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    &#125;<br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/posts/11363/640-20240315111906903.png" alt="图片"></p><p>可以看到一个线程对一个对象加锁、解锁、重新获取对象的锁时，<code>mark word</code>都没有发生变化，偏向锁中的当前线程指针始终指向同一个线程。</p><p>3、当两个或以上线程交替获取锁，但并没有在对象上并发的获取锁时，偏向锁升级为轻量级锁。在此阶段，线程采取<code>CAS</code>的自旋方式尝试获取锁，避免阻塞线程造成的cpu在用户态和内核态间转换的消耗。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">synchronized</span> (user)&#123;<br>        System.out.println(<span class="hljs-string">&quot;--MAIN--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());<br>    &#125;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    thread.join();<br>    System.out.println(<span class="hljs-string">&quot;--END--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>先直接看一下结果：</p><p><img src="/posts/11363/640-20240315111907048.png" alt="图片"></p><p>整个加锁状态的变化流程如下：</p><ul><li>主线程首先对user对象加锁，首次加锁为<code>101</code>偏向锁</li><li>子线程等待主线程释放锁后，对user对象加锁，这时将偏向锁升级为<code>00</code>轻量级锁</li><li>轻量级锁解锁后，user对象无线程竞争，恢复为<code>001</code>无锁态，并且处于不可偏向状态。如果之后有线程再尝试获取user对象的锁，会直接加轻量级锁，而不是偏向锁</li></ul><p>4、当两个或以上线程并发的在同一个对象上进行同步时，为了避免无用自旋消耗cpu，轻量级锁会升级成重量级锁。这时<code>mark word</code>中的指针指向的是<code>monitor</code>对象（也被称为管程或监视器锁）的起始地址。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD1--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (user) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--THREAD2--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>查看结果：</p><p><img src="/posts/11363/640-20240315111906835.png" alt="图片"></p><p>可以看到，在两个线程同时竞争user对象的锁时，会升级为<code>10</code>重量级锁。</p><h5 id="3-1-2-其他信息"><a href="#3-1-2-其他信息" class="headerlink" title="3.1.2 其他信息"></a>3.1.2 其他信息</h5><p>对<code>mark word</code> 中其他重要信息进行说明：</p><ul><li><code>hashcode</code>：无锁态下的<code>hashcode</code>采用了延迟加载技术，在第一次调用<code>hashCode()</code>方法时才会计算写入。对这一过程进行验证：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-comment">//打印内存布局</span><br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>    <span class="hljs-comment">//计算hashCode</span><br>    System.out.println(user.hashCode());<br>    <span class="hljs-comment">//再次打印内存布局</span><br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts/11363/640-20240315111906952.png" alt="图片"></p><p>可以看到，在没有调用<code>hashCode()</code>方法前，31位的哈希值不存在，全部填充为0。在调用方法后，根据大小端，被填充的数据为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1011001001101100011010010101101<br></code></pre></td></tr></table></figure><p>将2进制转换为10进制，对应哈希值<code>1496724653</code>。需要注意，只有在调用没有被重写的<code>Object.hashCode()</code>方法或<code>System.identityHashCode(Object)</code>方法才会写入<code>mark word</code>，执行用户自定义的<code>hashCode()</code>方法不会被写入。</p><p>大家可能会注意到，当对象被加锁后，<code>mark word</code>中就没有足够空间来保存<code>hashCode</code>了，这时<code>hashcode</code>会被移动到重量级锁的<code>Object Monitor</code>中。</p><ul><li><code>epoch</code>：偏向锁的时间戳</li><li>分代年龄（<code>age</code>）：在<code>jvm</code>的垃圾回收过程中，每当对象经过一次<code>Young GC</code>，年龄都会加1，这里4位来表示分代年龄最大值为15，这也就是为什么对象的年龄超过15后会被移到老年代的原因。在启动时可以通过添加参数来改变年龄阈值：</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:MaxTenuringThreshold</span><br></code></pre></td></tr></table></figure><p>当设置的阈值超过15时，启动时会报错：</p><p><img src="/posts/11363/640-20240315111906963.png" alt="图片"></p><h4 id="3-2-Klass-Pointer-类型指针"><a href="#3-2-Klass-Pointer-类型指针" class="headerlink" title="3.2 Klass Pointer 类型指针"></a>3.2 Klass Pointer 类型指针</h4><p><code>Klass Pointer</code>是一个指向方法区中<code>Class</code>信息的指针，虚拟机通过这个指针确定该对象属于哪个类的实例。在64位的JVM中，支持指针压缩功能，根据是否开启指针压缩，<code>Klass Pointer</code>占用的大小将会不同：</p><ul><li>未开启指针压缩时，类型指针占用8B (64bit)</li><li>开启指针压缩情况下，类型指针占用4B (32bit)</li></ul><p>在<code>jdk6</code>之后的版本中，指针压缩是被默认开启的，可通过启动参数开启或关闭该功能：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#开启指针压缩：</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseCompressedOops</span><br><span class="hljs-comment">#关闭指针压缩：</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-UseCompressedOops</span><br></code></pre></td></tr></table></figure><p>还是以刚才的<code>User</code>类为例，关闭指针压缩后再次查看对象的内存布局：</p><p><img src="/posts/11363/640.png" alt="图片"></p><p>对象大小虽然还是16字节，但是组成发生了改变，8字节标记字加8字节类型指针，已经能满足对齐条件，因此不需要填充。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">8</span>B <span class="hljs-comment">(mark word)</span> + <span class="hljs-number">8</span>B <span class="hljs-comment">(klass pointer)</span> + <span class="hljs-number">0</span>B <span class="hljs-comment">(instance data)</span> + <span class="hljs-number">0</span>B <span class="hljs-comment">(padding)</span><br></code></pre></td></tr></table></figure><h5 id="3-2-1-指针压缩原理"><a href="#3-2-1-指针压缩原理" class="headerlink" title="3.2.1 指针压缩原理"></a>3.2.1 指针压缩原理</h5><p>在了解了指针压缩的作用后，我们来看一下指针压缩是如何实现的。首先在不开启指针压缩的情况下，一个对象的内存地址使用64位表示，这时能描述的内存地址范围是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>~ <span class="hljs-number">2</span>^<span class="hljs-number">64</span>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在开启指针压缩后，使用4个字节也就是32位，可以表示<code>2^32</code> 个内存地址，如果这个地址是真实地址的话，由于CPU寻址的最小单位是<code>Byte</code>，那么就是4GB内存。这对于我们来说是远远不够的，但是之前我们说过，java中对象默认使用了8字节对齐，也就是说1个对象占用的空间必须是8字节的整数倍，这样就创造了一个条件，使jvm在定位一个对象时不需要使用真正的内存地址，而是定位到由java进行了8字节映射后的地址（可以说是一个映射地址的编号）。</p><p>映射过程也非常简单，由于使用了8字节对齐后每个对象的地址偏移量后3位必定为0，所以在存储的时候可以将后3位0抹除（转化为<code>bit</code>是抹除了最后24位），在此基础上再去掉最高位，就完成了指针从8字节到4字节的压缩。而在实际使用时，在压缩后的指针后加3位0，就能够实现向真实地址的映射。</p><p><img src="/posts/11363/640-20240315111906853.png" alt="图片"></p><p>完成压缩后，现在指针的32位中的每一个<code>bit</code>，都可以代表8个字节，这样就相当于使原有的内存地址得到了8倍的扩容。所以在8字节对齐的情况下，32位最大能表示<code>2^32*8=32GB</code>内存，内存地址范围是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>~ (<span class="hljs-number">2</span>^<span class="hljs-number">32</span>-<span class="hljs-number">1</span>)*<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>由于能够表示的最大内存是32GB，所以如果配置的最大的堆内存超过这个数值时，那么指针压缩将会失效。配置jvm启动参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx32g</span><br></code></pre></td></tr></table></figure><p>查看对象内存布局：</p><p><img src="/posts/11363/640-20240315111907081.png" alt="图片"></p><p>此时，指针压缩失效，指针长度恢复到8字节。那么如果业务场景内存超过32GB怎么办呢，可以通过修改默认对齐长度进行再次扩展，我们将对齐长度修改为16字节：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">ObjectAlignmentInBytes</span>=16 -Xmx32g<br></code></pre></td></tr></table></figure><p><img src="/posts/11363/640-20240315111907016.png" alt="图片"></p><p>可以看到指针压缩后占4字节，同时对象向16字节进行了填充对齐，按照上面的计算，这时配置最大堆内存为64GB时指针压缩才会失效。</p><p>对指针压缩做一下简单总结：</p><ul><li>通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果</li><li>指针压缩能够节省内存空间，同时提高了程序的寻址效率</li><li>堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费</li><li>此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针</li></ul><h4 id="3-3-数组长度"><a href="#3-3-数组长度" class="headerlink" title="3.3 数组长度"></a>3.3 数组长度</h4><p>如果当对象是一个数组对象时，那么在对象头中有一个保存数组长度的空间，占用4字节（32bit）空间。通过下面代码进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    User[] user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//查看对象的内存布局</span><br>    System.out.println(ClassLayout.parseInstance(user).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，结果如下：</p><p><img src="/posts/11363/640-20240315111906844.png" alt="图片"></p><p>内存结构从上到下分别为：</p><ul><li>8字节<code>mark word</code></li><li>4字节<code>klass pointer</code></li><li>4字节数组长度，值为2，表示数组中有两个元素</li><li>开启指针压缩后每个引用类型占4字节，数组中两个元素共占8字节</li></ul><p>需要注意的是，在未开启指针压缩的情况下，在数组长度后会有一段对齐填充字节：</p><p><img src="/posts/11363/640-20240315111906967.png" alt="图片"></p><p>通过计算：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8B</span> (mark word) + <span class="hljs-number">8</span>B (klass pointer) + <span class="hljs-number">4</span>B (array length) + <span class="hljs-number">16</span>B (instance data)=<span class="hljs-number">36</span>B<br></code></pre></td></tr></table></figure><p>需要向8字节进行对齐，这里选择将对齐的4字节添加在了数组长度和实例数据之间。</p><h3 id="4、实例数据"><a href="#4、实例数据" class="headerlink" title="4、实例数据"></a>4、实例数据</h3><p>实例数据（<code>Instance Data</code>）保存的是对象真正存储的有效信息，保存了代码中定义的各种数据类型的字段内容，并且如果有继承关系存在，子类还会包含从父类继承过来的字段。</p><ul><li>基本数据类型：</li></ul><table><thead><tr><th align="left">Type</th><th align="left">Bytes</th></tr></thead><tbody><tr><td align="left">byte，boolean</td><td align="left">1</td></tr><tr><td align="left">char，short</td><td align="left">2</td></tr><tr><td align="left">int，float</td><td align="left">4</td></tr><tr><td align="left">long，double</td><td align="left">8</td></tr></tbody></table><ul><li>引用数据类型：</li></ul><p>开启指针压缩情况下占8字节，开启指针压缩后占4字节。</p><h4 id="4-1-字段重排序"><a href="#4-1-字段重排序" class="headerlink" title="4.1 字段重排序"></a>4.1 字段重排序</h4><p>给User类添加基本数据类型的属性字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id,age,weight;<br>    <span class="hljs-type">byte</span> sex;<br>    <span class="hljs-type">long</span> phone;<br>    <span class="hljs-type">char</span> local;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="/posts/11363/640-20240315111907034.png" alt="图片"></p><p>可以看到，在内存中，属性的排列顺序与在类中定义的顺序不同，这是因为jvm会采用<strong>字段重排序</strong>技术，对原始类型进行重新排序，以达到内存对齐的目的。具体规则遵循如下：</p><ul><li>按照数据类型的长度大小，从大到小排列</li><li>具有相同长度的字段，会被分配在相邻位置</li><li>如果一个字段的长度是L个字节，那么这个字段的偏移量（<code>OFFSET</code>）需要对齐至<code>nL</code>（n为整数）</li></ul><p>上面的前两条规则相对容易理解，这里通过举例对第3条进行解释：</p><p>因为<code>long</code>类型占8字节，所以它的偏移量必定是8n，再加上前面对象头占12字节，所以<code>long</code>类型变量的最小偏移量是16。通过打印对象内存布局可以发现，当对象头不是8字节的整数倍时（只存在<code>8n+4</code>字节情况），会按从大到小的顺序，使用4、2、1字节长度的属性进行补位。为了和对齐填充进行区分，可以称其为前置补位，如果在补位后仍然不满足8字节整数倍，会进行对齐填充。在存在前置补位的情况下，字段的排序会打破上面的第一条规则。</p><p>因此在上面的内存布局中，先使用4字节的<code>int</code>进行前置补位，再按第一条规则从大到小顺序进行排列。如果我们删除3个<code>int</code>类型的字段，再查看内存布局：</p><p><img src="/posts/11363/640-20240315111907017.png" alt="图片"></p><p><code>char</code>和<code>byte</code>类型的变量被提到前面进行前置补位，并在<code>long</code>类型前进行了1字节的对齐填充。</p><h4 id="4-2-拥有父类情况"><a href="#4-2-拥有父类情况" class="headerlink" title="4.2 拥有父类情况"></a>4.2 拥有父类情况</h4><ul><li>当一个类拥有父类时，整体遵循在父类中定义的变量出现在子类中定义的变量之前的原则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> i1,i2;<br>    <span class="hljs-type">long</span> l1,l2;<br>    <span class="hljs-type">char</span> c1,c2;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">boolean</span> b1;<br>    <span class="hljs-type">double</span> d1,d2;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="/posts/11363/640-20240315111906994.png" alt="图片"></p><ul><li>如果父类需要后置补位的情况，可能会将子类中类型长度较短的变量提前，但是整体还是遵循子类在父类之后的原则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> i1,i2;<br>    <span class="hljs-type">long</span> l1;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> i1,i2;<br>    <span class="hljs-type">long</span> l1;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="/posts/11363/640-20240315111907000.png" alt="图片"></p><p>可以看到，子类中较短长度的变量被提前到父类后进行了后置补位。</p><ul><li>父类的前置对齐填充会被子类继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">long</span> l;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">long</span> l2;<br>    <span class="hljs-type">int</span> i1;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="/posts/11363/640-20240315111907017-0472747.png" alt="图片"></p><p>当B类没有继承A类时，正好满足8字节对齐，不需要进行对齐填充。当B类继承A类后，会继承A类的前置补位填充，因此在B类的末尾也需要对齐填充。</p><h4 id="4-3-引用数据类型"><a href="#4-3-引用数据类型" class="headerlink" title="4.3 引用数据类型"></a>4.3 引用数据类型</h4><p>在上面的例子中，仅探讨了基本数据类型的排序情况，那么如果存在引用数据类型时，排序情况是怎样的呢？在<code>User</code>类中添加引用类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>     <span class="hljs-type">int</span> id;<br>     String firstName;<br>     String lastName;<br>     <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="/posts/11363/640-20240315111907056.png" alt="图片"></p><p>可以看到默认情况下，基本数据类型的变量排在引用数据类型前。这个顺序可以在<code>jvm</code>启动参数中进行修改：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">FieldsAllocationStyle</span>=0<br></code></pre></td></tr></table></figure><p>重新运行，可以看到引用数据类型的排列顺序被放在了前面：</p><p><img src="/posts/11363/640-20240315111907092.png" alt="图片"></p><p>对<code>FieldsAllocationStyle</code>的不同取值简要说明：</p><ul><li>0：先放入普通对象的引用指针，再放入基本数据类型变量</li><li>1：默认情况，表示先放入基本数据类型变量，再放入普通对象的引用指针</li></ul><h4 id="4-4-静态变量"><a href="#4-4-静态变量" class="headerlink" title="4.4 静态变量"></a>4.4 静态变量</h4><p>在上面的基础上，在类中加入静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>     <span class="hljs-type">int</span> id;<br>     <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span> local;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="/posts/11363/640-20240315111907096.png" alt="图片"></p><p>通过结果可以看到，静态变量并不在对象的内存布局中，它的大小是不计算在对象中的，因为静态变量属于类而不是属于某一个对象的。</p><h3 id="5、对齐填充字节"><a href="#5、对齐填充字节" class="headerlink" title="5、对齐填充字节"></a>5、对齐填充字节</h3><p>在<code>Hotspot</code>的自动内存管理系统中，要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须满足8字节的整数倍。因此如果实例数据没有对齐，那么需要进行对齐补全空缺，补全的<code>bit</code>位仅起占位符作用，不具有特殊含义。</p><p>在前面的例子中，我们已经对对齐填充有了充分的认识，下面再做一些补充：</p><ul><li>在开启指针压缩的情况下，如果类中有<code>long/double</code>类型的变量时，会在对象头和实例数据间形成间隙（<code>gap</code>），为了节省空间，会默认把较短长度的变量放在前边，这一功能可以通过jvm参数进行开启或关闭：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 开启</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+CompactFields</span><br><span class="hljs-comment"># 关闭</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-CompactFields</span><br></code></pre></td></tr></table></figure><p>测试关闭情况，可以看到较短长度的变量没有前移填充：</p><p><img src="/posts/11363/640-20240315111907066.png" alt="图片"></p><ul><li>在前面指针压缩中，我们提到了可以改变对齐宽度，这也是通过修改下面的jvm参数配置实现的：</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:ObjectAlignmentInBytes</span><br></code></pre></td></tr></table></figure><p>默认情况下对齐宽度为8，这个值可以修改为2~256以内2的整数幂，一般情况下都以8字节对齐或16字节对齐。测试修改为16字节对齐：</p><p><img src="/posts/11363/640-20240315111907074.png" alt="图片"></p><p>上面的例子中，在调整为16字节对齐的情况下，最后一行的属性字段只占了6字节，因此会添加10字节进行对齐填充。当然普通情况下不建议修改对齐长度参数，如果对齐宽度过长，可能会导致内存空间的浪费。</p><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>本文通过使用<code>jol</code> 对java对象的结构进行调试，学习了对象内存布局的基本知识。通过学习，能够帮助我们：</p><ul><li>掌握对象内存布局，基于此基础进行jvm参数调优</li><li>了解对象头在<code>synchronize</code> 的锁升级过程中的作用</li><li>熟悉 jvm 中对象的寻址过程</li><li>通过计算对象大小，可以在评估业务量的基础上在项目上线前预估需要使用多少内存，防止服务器频繁gc</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graylog 查询语句语法</title>
    <link href="/posts/2802.html"/>
    <url>/posts/2802.html</url>
    
    <content type="html"><![CDATA[<h2 id="编写搜索查询"><a href="#编写搜索查询" class="headerlink" title="编写搜索查询"></a>编写搜索查询</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>搜索语法非常接近 Lucene 语法。如果你没有指定要搜索的消息字段，那么默认情况下所有的消息字段都会被包括在搜索中。</p><ul><li><p>包含词汇 ssh 的消息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh</span> <br></code></pre></td></tr></table></figure></li><li><p>包含词汇 ssh 或 login 的消息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh login</span> <br></code></pre></td></tr></table></figure></li><li><p>包含精确短语 ssh login 的消息：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;ssh login&quot;</span> <br></code></pre></td></tr></table></figure></li><li><p>字段 type 包含 ssh 的消息：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span>:ssh <br></code></pre></td></tr></table></figure></li><li><p>字段 type 包含 ssh 或 login 的消息：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span>:(ssh <span class="hljs-type">OR</span> login)<br></code></pre></td></tr></table></figure><p>提示：Elasticsearch 2.x 和 5.x 在空格处分割查询，所以查询 <code>type:(ssh login)</code> 等同于 <code>type:(ssh OR login)</code>。在 Elasticsearch 6.0 中，这种情况已经不再存在，你现在必须在每个词汇之间包含一个 OR 运算符。</p></li><li><p>字段 type 包含精确短语 ssh login 的消息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span>:<span class="hljs-string">&quot;ssh login&quot;</span> <br></code></pre></td></tr></table></figure></li><li><p>具有字段 type 的消息：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">_exists_</span>:<span class="hljs-keyword">type</span> <br></code></pre></td></tr></table></figure></li><li><p>不具有字段 type 的消息：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">NOT</span> _exists_:<span class="hljs-keyword">type</span> <br></code></pre></td></tr></table></figure><p>提示：Elasticsearch 2.x 允许使用 <code>_missing_:type</code> 替代 <code>NOT _exists_:type</code>。这种查询语法在 Elasticsearch 5.0 中已被移除。</p></li><li><p>匹配正则表达式 ethernet[0-9]+ 的消息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ethernet[0-9]+/</span><br></code></pre></td></tr></table></figure><p>提示：请参考 Elasticsearch 文档中关于正则表达式语法的部分，以获取关于支持的正则表达式方言的详细信息。</p></li></ul><p>默认情况下，所有的词汇或短语都是 OR 连接的，所以所有至少有一个命中的消息都会被返回。你可以使用布尔运算符和组来控制这一点：<br>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-string">&quot;ssh login&quot;</span> <span class="hljs-keyword">AND </span>source:example.<span class="hljs-keyword">org</span><br><span class="hljs-keyword"></span>(<span class="hljs-string">&quot;ssh login&quot;</span> <span class="hljs-keyword">AND </span>(source:example.<span class="hljs-keyword">org </span><span class="hljs-keyword">OR </span>source:another.example.<span class="hljs-keyword">org)) </span><span class="hljs-keyword">OR </span>_exists_:always_find_me<br></code></pre></td></tr></table></figure><br>你也可以使用 NOT 运算符：<br>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-string">&quot;ssh login&quot;</span> <span class="hljs-keyword">AND</span> NOT source:example<span class="hljs-meta">.org</span><br>NOT example<span class="hljs-meta">.org</span><br></code></pre></td></tr></table></figure><br>请注意，AND、OR 和 NOT 是区分大小写的，必须全部使用大写字母输入。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>使用 <code>?</code> 替换单个字符或 <code>*</code> 替换零个或多个字符：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">source:</span>*<span class="hljs-meta">.org</span><br><span class="hljs-symbol">source:</span>exam?le<span class="hljs-meta">.org</span><br><span class="hljs-symbol">source:</span>exam?le.*<br></code></pre></td></tr></table></figure><p>请注意，为避免过度消耗内存，禁用了前导通配符！你可以在你的 Graylog 配置文件中启用它们：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">allow_leading_wildcard_searches</span> = <span class="hljs-literal">true</span> <br></code></pre></td></tr></table></figure><p>还要注意，默认情况下，只有 message、full_message 和 source 这三个字段会被分析。虽然通配符搜索（使用 * 和 ?）适用于所有索引的字段，但分析过的字段的行为会有些不同。详情请参见通配符和正则表达式查询。</p><h2 id="模糊性"><a href="#模糊性" class="headerlink" title="模糊性"></a>模糊性</h2><p>你可以搜索相似的词汇：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">ssh logni~  <br><span class="hljs-symbol">source:</span>exmaple<span class="hljs-meta">.org</span>~  <br></code></pre></td></tr></table></figure><p>这个例子使用了默认距离为2的 Damerau–Levenshtein 距离，将匹配 “ssh login” 和 “example.org”（查询中故意拼错）。</p><p>你可以像这样改变距离：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">source:</span>exmaple<span class="hljs-meta">.org</span>~<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>你也可以使用模糊性运算符进行接近搜索，其中短语中的词汇可以彼此有不同&#x2F;模糊的距离，而不必按照定义的顺序：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;foo bar&quot;</span><span class="hljs-symbol">~5 </span><br></code></pre></td></tr></table></figure><p>数值字段支持范围查询。方括号中的范围是包含的，花括号中的范围是排除的，甚至可以组合使用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http_response_code</span>:[<span class="hljs-number">500</span> TO <span class="hljs-number">504</span>]<br><span class="hljs-attribute">http_response_code</span>:&#123;<span class="hljs-number">400</span> TO <span class="hljs-number">404</span>&#125;<br><span class="hljs-attribute">bytes</span>:&#123;<span class="hljs-number">0</span> TO <span class="hljs-number">64</span>]<br><span class="hljs-attribute">http_response_code</span>:[<span class="hljs-number">0</span> TO <span class="hljs-number">64</span>&#125;<br></code></pre></td></tr></table></figure><p>你也可以进行一边无界的搜索：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http_response_code</span>:&gt;<span class="hljs-number">400</span><br><span class="hljs-attribute">http_response_code</span>:&lt;<span class="hljs-number">400</span><br><span class="hljs-attribute">http_response_code</span>:&gt;=<span class="hljs-number">400</span><br><span class="hljs-attribute">http_response_code</span>:&lt;=<span class="hljs-number">400</span><br></code></pre></td></tr></table></figure><p>还可以组合无界范围运算符：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http_response_code</span>:(&gt;=<span class="hljs-number">400</span> AND &lt;<span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><p>可以对日期字段进行范围查询。重要的是，时间选择器选定的时间段要符合你想要搜索的范围。如果你在过去的5分钟内搜索，但是搜索的时间是一周前，那么查询将不会返回任何内容。日期需要是 UTC 格式，格式需要像 Graylog 显示的那样：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">timestamp:[&quot;<span class="hljs-number">2019-07-23</span> <span class="hljs-number">09:53:08.175</span>&quot; TO &quot;<span class="hljs-number">2019-07-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">53:08.575</span>&quot;]<br></code></pre></td></tr></table></figure><p>Graylog 为字段 timestamp 有一个自定义的索引映射，用于以 YYYY-MM-DD HH:MM:SS.sss 的格式保存日期。如果有一个额外的字段，Elasticsearch 判断这是一个日期并使用默认的日期格式，即 YYYY-MM-DD HH:MM:SS.sss。这意味着在那个期间的搜索将会像这样：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">otherDate:[&quot;2019<span class="hljs-string">-07</span><span class="hljs-string">-23</span>T09:53:08.175&quot; TO &quot;2019<span class="hljs-string">-07</span><span class="hljs-string">-23</span>T09:53:08.575&quot;]<br></code></pre></td></tr></table></figure><p>至少在 Elasticsearch 6.x 中，你可以在时间范围中包含时区信息。查询将看起来像这样：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">otherDate:[&quot;2020<span class="hljs-string">-07</span><span class="hljs-string">-29</span>T12:00:00.000<span class="hljs-string">-05</span>:00&quot; TO &quot;2020<span class="hljs-string">-07</span><span class="hljs-string">-30</span>T15:13:00.000<span class="hljs-string">-05</span>:00&quot;] <br></code></pre></td></tr></table></figure><p>这个日期查询也可以是动态的，你总是回看指定的时间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">otherDate</span>:[now-<span class="hljs-number">5</span>d TO now-<span class="hljs-number">4</span>d]<br></code></pre></td></tr></table></figure><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>以下字符必须使用反斜杠进行转义：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">&amp;</span> <span class="hljs-operator">|</span> : \ / <span class="hljs-operator">+</span> <span class="hljs-operator">-</span> <span class="hljs-title function_">!</span> ( ) &#123; &#125; [ ] <span class="hljs-operator">^</span> <span class="hljs-string">&quot; ~ * ?</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">resource:\<span class="hljs-string">/posts</span>\<span class="hljs-string">/45326</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>正则表达式查询由 <code>regexp</code> 和 <code>query_string</code> 查询支持。Lucene 正则表达式引擎不兼容 Perl，但支持更小范围的运算符。</p><p>我们不会试图解释正则表达式，而只是解释支持的运算符。</p><h3 id="标准运算符"><a href="#标准运算符" class="headerlink" title="标准运算符"></a>标准运算符</h3><h4 id="锚定"><a href="#锚定" class="headerlink" title="锚定"></a>锚定</h4><p>大多数正则表达式引擎允许你匹配字符串的任何部分。如果你希望 regexp 模式从字符串的开始开始或在字符串的结束结束，那么你必须特别锚定它，使用 <code>^</code> 表示开始或 <code>$</code> 表示结束。</p><p>Lucene 的模式总是锚定的。提供的模式必须匹配整个字符串。对于字符串 “abcde”：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ab.*     <span class="hljs-meta"># 匹配</span><br>abcd     <span class="hljs-meta"># 不匹配</span><br></code></pre></td></tr></table></figure><h4 id="允许的字符"><a href="#允许的字符" class="headerlink" title="允许的字符"></a>允许的字符</h4><p>模式中可以使用任何 Unicode 字符，但某些字符是保留的，必须被转义。标准保留字符是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">. ? + * <span class="hljs-string">| &#123; &#125; [ ] ( ) &quot;</span> \<br></code></pre></td></tr></table></figure><p>如果你启用了可选特性（见下文），那么这些字符可能也是保留的：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># @ &amp; &lt; &gt;  ~</span><br></code></pre></td></tr></table></figure><p>任何保留字符可以用反斜杠 “*“ 转义，包括文字反斜杠字符 “\“。</p><p>此外，任何字符（除双引号外）在双引号中被解释为字面值：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">john<span class="hljs-string">&quot;@smith.com&quot;</span><br></code></pre></td></tr></table></figure><h4 id="匹配任何字符"><a href="#匹配任何字符" class="headerlink" title="匹配任何字符"></a>匹配任何字符</h4><p>句点 “.” 可用于代表任何字符。对于字符串 “abcde”：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ab.<span class="hljs-string">..</span>   <span class="hljs-comment"># 匹配</span><br>a.c.e   <span class="hljs-comment"># 匹配</span><br></code></pre></td></tr></table></figure><h4 id="一次或多次"><a href="#一次或多次" class="headerlink" title="一次或多次"></a>一次或多次</h4><p>加号 “+” 可用于重复前面的最短模式一次或多次。对于字符串 “aaabbb”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">a+<span class="hljs-keyword">b+ </span>       <span class="hljs-comment"># 匹配</span><br>aa+<span class="hljs-keyword">bb+ </span>     <span class="hljs-comment"># 匹配</span><br>a+.+        <span class="hljs-comment"># 匹配</span><br>aa+<span class="hljs-keyword">bbb+ </span>    <span class="hljs-comment"># 匹配</span><br></code></pre></td></tr></table></figure><h4 id="零次或多次"><a href="#零次或多次" class="headerlink" title="零次或多次"></a>零次或多次</h4><p>星号 “*” 可用于匹配前面的最短模式零次或多次。对于字符串 “aaabbb”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">a*<span class="hljs-keyword">b* </span>       <span class="hljs-comment"># 匹配</span><br>a*<span class="hljs-keyword">b*c* </span>     <span class="hljs-comment"># 匹配</span><br>.*<span class="hljs-keyword">bbb.* </span>    <span class="hljs-comment"># 匹配</span><br>aaa*<span class="hljs-keyword">bbb* </span>   <span class="hljs-comment"># 匹配</span><br></code></pre></td></tr></table></figure><h4 id="零次或一次"><a href="#零次或一次" class="headerlink" title="零次或一次"></a>零次或一次</h4><p>问号 “?” 使前面的最短模式变为可选。它匹配零次或一次。对于字符串 “aaabbb”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">aaa?<span class="hljs-keyword">bbb? </span>   <span class="hljs-comment"># 匹配</span><br>aaaa?<span class="hljs-keyword">bbbb? </span> <span class="hljs-comment"># 匹配</span><br>.....?.?    <span class="hljs-comment"># 匹配</span><br>aa?<span class="hljs-keyword">bb? </span>     <span class="hljs-comment"># 不匹配</span><br></code></pre></td></tr></table></figure><h4 id="最小到最大"><a href="#最小到最大" class="headerlink" title="最小到最大"></a>最小到最大</h4><p>大括号 “{}” 可用于指定前面最短模式可以重复的最小和（可选）最大次数。允许的形式是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<span class="hljs-number">5</span>&#125;     <span class="hljs-meta"># 重复5次</span><br>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;   <span class="hljs-meta"># 至少重复2次，最多5次</span><br>&#123;<span class="hljs-number">2</span>,&#125;    <span class="hljs-meta"># 至少重复2次</span><br></code></pre></td></tr></table></figure><p>对于字符串 “aaabbb”：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">a</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml">        # 匹配</span><br><span class="language-xml">a</span><span class="hljs-template-variable">&#123;2,4&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;2,4&#125;</span><span class="language-xml">    # 匹配</span><br><span class="language-xml">a</span><span class="hljs-template-variable">&#123;2,&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;2,&#125;</span><span class="language-xml">      # 匹配</span><br><span class="language-xml">.</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml">        # 匹配</span><br><span class="language-xml">a</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">        # 不匹配</span><br><span class="language-xml">a</span><span class="hljs-template-variable">&#123;4,6&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;4,6&#125;</span><span class="language-xml">    # 不匹配</span><br><span class="language-xml">a</span><span class="hljs-template-variable">&#123;4,&#125;</span><span class="language-xml">b</span><span class="hljs-template-variable">&#123;4,&#125;</span><span class="language-xml">      # 不匹配</span><br></code></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>括号 “()” 可用于形成子模式。上面列出的数量运算符作用于最短的前面的模式，这可以是一个组。对于字符串 “ababab”：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">(ab)+       # 匹配<br><span class="hljs-built_in">ab</span>(ab)+     # 匹配<br>(..)+       # 匹配<br>(...)+      # 不匹配<br>(ab)*       # 匹配<br><span class="hljs-built_in">abab</span>(ab)?   # 匹配<br><span class="hljs-built_in">ab</span>(ab)?     # 不匹配<br>(ab)&#123;<span class="hljs-number">3</span>&#125;     # 匹配<br>(ab)&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;   # 不匹配<br></code></pre></td></tr></table></figure><h4 id="交替"><a href="#交替" class="headerlink" title="交替"></a>交替</h4><p>管道符 “|” 充当 OR 运算符。如果左侧或右侧的模式匹配，匹配将成功。交替适用于最长的模式，而不是最短的。对于字符串 “aabb”：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">aabb|bbaa   <span class="hljs-comment"># 匹配</span><br>aacc|bb     <span class="hljs-comment"># 不匹配</span><br>aa(cc|bb)   <span class="hljs-comment"># 匹配</span><br><span class="hljs-keyword">a</span>+|b+       <span class="hljs-comment"># 不匹配</span><br><span class="hljs-keyword">a</span>+b+|b+<span class="hljs-keyword">a</span>+   <span class="hljs-comment"># 匹配</span><br><span class="hljs-keyword">a</span>+(b|c)+    <span class="hljs-comment"># 匹配</span><br></code></pre></td></tr></table></figure><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>可以将潜在字符的范围表示为字符类，通过在方括号 “[]” 中封闭它们。前导 ^ 对字符类取反。允许的形式是：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[abc]   <span class="hljs-meta"># <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span></span><br>[a-c]   <span class="hljs-meta"># <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span></span><br>[-abc]  <span class="hljs-meta"># <span class="hljs-string">&#x27;-&#x27;</span> 或 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span></span><br>[abc\-] <span class="hljs-meta"># <span class="hljs-string">&#x27;-&#x27;</span> 或 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span></span><br>[^abc]  <span class="hljs-meta"># 除 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span> 以外的任何字符</span><br>[^a-c]  <span class="hljs-meta"># 除 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span> 以外的任何字符</span><br>[^-abc]  <span class="hljs-meta"># 除 <span class="hljs-string">&#x27;-&#x27;</span> 或 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span> 以外的任何字符</span><br>[^abc\-] <span class="hljs-meta"># 除 <span class="hljs-string">&#x27;-&#x27;</span> 或 <span class="hljs-string">&#x27;a&#x27;</span> 或 <span class="hljs-string">&#x27;b&#x27;</span> 或 <span class="hljs-string">&#x27;c&#x27;</span> 以外的任何字符</span><br></code></pre></td></tr></table></figure><p>注意，破折号 “-“ 表示一系列字符，除非它是第一个字符或者它被反斜杠转义。</p><p>对于字符串 “abcd”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ab[<span class="hljs-built_in">cd</span>]+     <span class="hljs-comment"># 匹配</span><br>[a-d]+      <span class="hljs-comment"># 匹配</span><br>[^a-d]+     <span class="hljs-comment"># 不匹配</span><br></code></pre></td></tr></table></figure><h4 id="可选运算符"><a href="#可选运算符" class="headerlink" title="可选运算符"></a>可选运算符</h4><p>这些运算符默认可用，因为 <code>flags</code> 参数默认为 ALL。可以使用不同的标志组合（用 “|” 连接）来启用&#x2F;禁用特定运算符：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john~athon&lt;1-5&gt;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;flags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;COMPLEMENT|INTERVAL&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="补集"><a href="#补集" class="headerlink" title="补集"></a>补集</h4><p>补集可能是最有用的选项。跟在波浪线 “<del>“ 后面的最短模式是取反的。例如，”ab</del>cd” 意味着：</p><ul><li>以 a 开始</li><li>后跟 b</li><li>后跟一个任意长度的字符串，该字符串不是 c</li><li>以 d 结束</li></ul><p>对于字符串 “abcdef”：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ab~df     <span class="hljs-comment"># 匹配</span><br>ab~cf     <span class="hljs-comment"># 匹配</span><br>ab~cdef   <span class="hljs-comment"># 不匹配</span><br><span class="hljs-keyword">a</span>~(cb)def <span class="hljs-comment"># 匹配</span><br><span class="hljs-keyword">a</span>~(bc)def <span class="hljs-comment"># 不匹配</span><br></code></pre></td></tr></table></figure><p>使用 COMPLEMENT 或 ALL 标志启用。</p><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p>区间选项启用了使用尖括号 “&lt;&gt;” 封闭的数字范围。对于字符串 “foo80”：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">foo</span>&lt;<span class="hljs-number">1</span>-<span class="hljs-number">100</span>&gt;     # 匹配<br><span class="hljs-attribute">foo</span>&lt;<span class="hljs-number">01</span>-<span class="hljs-number">100</span>&gt;    # 匹配<br><span class="hljs-attribute">foo</span>&lt;<span class="hljs-number">001</span>-<span class="hljs-number">100</span>&gt;   # 不匹配<br></code></pre></td></tr></table></figure><p>使用 INTERVAL 或 ALL 标志启用。</p><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>符号 “&amp;” 连接两个模式，使它们都必须匹配。对于字符串 “aaabbb”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">aaa.+&amp;.+<span class="hljs-keyword">bbb </span>    <span class="hljs-comment"># 匹配</span><br>aaa&amp;<span class="hljs-keyword">bbb </span>       <br></code></pre></td></tr></table></figure><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>在输入查询时，请务必注意警告和异常。如果你输入了 Graylog 无法理解的查询，会出现一个带有黄色感叹号的图标，以及一条带有警告或异常的消息。它们包括：</p><ul><li>解析异常 - 当发生解析错误时，会抛出此异常。当你在搜索查询的语法中出错时，会出现这个异常。错误消息应该包含有关语法错误位置的更多信息。</li><li>无效运算符 - 当运算符拼写错误时，会出现此错误。例如，AND 是一个有效的运算符，但 and 不是。在大多数情况下，运算符是大写的。</li><li>未知字段 - 当你在搜索查询中包含一个不存在于相关索引集的字段时，会出现此警告。这是由流和索引集之间的关系决定的。</li><li>参数错误 - 当你在搜索查询中使用一个未声明的参数时，会出现此错误。</li></ul><p>参数需要在你将它们包含在搜索中之前进行定义。</p>]]></content>
    
    
    <categories>
      
      <category>graylog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graylog</tag>
      
      <tag>elastic search</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ IDEA for Mac 快捷键整理</title>
    <link href="/posts/65174.html"/>
    <url>/posts/65174.html</url>
    
    <content type="html"><![CDATA[<p>整理了 Mac 系统上 IntelliJ IDEA 的快捷键</p><span id="more"></span><h4 id="Editing-编辑"><a href="#Editing-编辑" class="headerlink" title="Editing (编辑)"></a>Editing (编辑)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+Shift+Enter</td><td align="left">自动结束代码，行末自动添加分号</td></tr><tr><td align="left">2</td><td align="left">Command+P</td><td align="left">显示方法的参数详情</td></tr><tr><td align="left">3</td><td align="left">Control+J</td><td align="left">快速查看文档</td></tr><tr><td align="left">4</td><td align="left">Command+鼠标移上去</td><td align="left">显示代码简要信息</td></tr><tr><td align="left">5</td><td align="left">Command+F1</td><td align="left">在错误或警告处显示具体描述信息</td></tr><tr><td align="left">6</td><td align="left">Command+N</td><td align="left">声称代码</td></tr><tr><td align="left">7</td><td align="left">Control+O</td><td align="left">覆盖方法(重写父类方法)</td></tr><tr><td align="left">8</td><td align="left">Control+I</td><td align="left">实现方法(实现接口中的方法)</td></tr><tr><td align="left">9</td><td align="left">Command+Option+T</td><td align="left">包围代码(使用if…else等包围选中的代码)</td></tr><tr><td align="left">10</td><td align="left">Command+&#x2F;</td><td align="left">注释&#x2F;取消注释与行注释</td></tr><tr><td align="left">11</td><td align="left">Command+Option+&#x2F;</td><td align="left">注释&#x2F;取消注释与块注释</td></tr><tr><td align="left">12</td><td align="left">Option+向上箭头</td><td align="left">连续选中代码块</td></tr><tr><td align="left">13</td><td align="left">Option+向下箭头</td><td align="left">减少当前选中的代码块</td></tr><tr><td align="left">14</td><td align="left">Command+Option+L</td><td align="left">格式化代码</td></tr><tr><td align="left">15</td><td align="left">Control+Option+O</td><td align="left">优化import</td></tr><tr><td align="left">16</td><td align="left">Control+Option+I</td><td align="left">自动缩进线</td></tr><tr><td align="left">17</td><td align="left">Tab</td><td align="left">缩进代码</td></tr><tr><td align="left">18</td><td align="left">Shift+Tab</td><td align="left">反缩进代码</td></tr><tr><td align="left">19</td><td align="left">Command+X</td><td align="left">剪切当前行或选中的块到剪贴板</td></tr><tr><td align="left">20</td><td align="left">Command+C</td><td align="left">复制当前行或选中的块到剪贴板</td></tr><tr><td align="left">21</td><td align="left">Command+V</td><td align="left">从剪贴板粘贴</td></tr><tr><td align="left">22</td><td align="left">Command+Shift+V</td><td align="left">从最近的缓冲区粘贴</td></tr><tr><td align="left">23</td><td align="left">Command+D</td><td align="left">复制当前行或选中的块</td></tr><tr><td align="left">24</td><td align="left">Command+Delete</td><td align="left">删除当前行或选中的块的行</td></tr><tr><td align="left">25</td><td align="left">Control+Shift+J</td><td align="left">智能地将代码拼接成一行</td></tr><tr><td align="left">26</td><td align="left">Shift+Enter</td><td align="left">开始新的一行</td></tr><tr><td align="left">27</td><td align="left">Command+Shift+U</td><td align="left">大小写切换</td></tr><tr><td align="left">28</td><td align="left">Option+Fn+Delete</td><td align="left">删除到单词末尾</td></tr><tr><td align="left">29</td><td align="left">Option+Delete</td><td align="left">删除到单词开始</td></tr><tr><td align="left">30</td><td align="left">Command+‘+’&#x2F;‘-’</td><td align="left">展开&#x2F;折叠代码块</td></tr><tr><td align="left">31</td><td align="left">Command+Shift+‘+’</td><td align="left">展开所有代码块</td></tr><tr><td align="left">32</td><td align="left">Command+Shift+‘-’</td><td align="left">折叠所有代码块</td></tr><tr><td align="left">33</td><td align="left">Command+W</td><td align="left">关闭活动的编辑器选项卡</td></tr></tbody></table><h4 id="Search-Replace-查询-替换"><a href="#Search-Replace-查询-替换" class="headerlink" title="Search&#x2F;Replace (查询&#x2F;替换)"></a>Search&#x2F;Replace (查询&#x2F;替换)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Double Shift</td><td align="left">查询任何东西</td></tr><tr><td align="left">2</td><td align="left">Command+F</td><td align="left">文件内查找</td></tr><tr><td align="left">3</td><td align="left">Command+G</td><td align="left">查找模式下，向下查找</td></tr><tr><td align="left">4</td><td align="left">Command+Shift+G</td><td align="left">查找模式下，向上查找</td></tr><tr><td align="left">5</td><td align="left">Command+R</td><td align="left">文件内替换</td></tr><tr><td align="left">6</td><td align="left">Command+Shift+F</td><td align="left">全局查找(根据路径)</td></tr><tr><td align="left">7</td><td align="left">Command+Shift+R</td><td align="left">全局替换(根据路径)</td></tr></tbody></table><h4 id="Usage-Search-使用查询"><a href="#Usage-Search-使用查询" class="headerlink" title="Usage Search (使用查询)"></a>Usage Search (使用查询)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Option+F7</td><td align="left">在文件中查找用法</td></tr><tr><td align="left">2</td><td align="left">Command+F7</td><td align="left">在类中查找用法</td></tr><tr><td align="left">3</td><td align="left">Command+Shift+F7</td><td align="left">在文件中突出显示的用法</td></tr></tbody></table><h4 id="Compile-and-Run-编译和运行"><a href="#Compile-and-Run-编译和运行" class="headerlink" title="Compile and Run (编译和运行)"></a>Compile and Run (编译和运行)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+F9</td><td align="left">编译项目</td></tr><tr><td align="left">2</td><td align="left">Command+Shift+F9</td><td align="left">编译选中的文件、包或模块</td></tr><tr><td align="left">3</td><td align="left">Control+Option+R</td><td align="left">弹出Run的可选择菜单</td></tr><tr><td align="left">4</td><td align="left">Control+Option+D</td><td align="left">弹出Debug的可选择菜单</td></tr><tr><td align="left">5</td><td align="left">Control+R</td><td align="left">运行</td></tr><tr><td align="left">6</td><td align="left">Control+D</td><td align="left">调试</td></tr><tr><td align="left">7</td><td align="left">Control+Shift+R</td><td align="left">从编辑器运行上下文环境配置</td></tr><tr><td align="left">8</td><td align="left">Control+Shift+D</td><td align="left">从编辑器运行上下文环境配置</td></tr></tbody></table><h4 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging (调试)"></a>Debugging (调试)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">F8</td><td align="left">进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">2</td><td align="left">F7</td><td align="left">进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">3</td><td align="left">Shift+F7</td><td align="left">智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">4</td><td align="left">Shift+F8</td><td align="left">跳出</td></tr><tr><td align="left">5</td><td align="left">Control+F9</td><td align="left">运行到光标处，如果光标前有其他断点会进入到该断点</td></tr><tr><td align="left">6</td><td align="left">Control+F8</td><td align="left">计算表达式(可以更改变量值使其生效)</td></tr><tr><td align="left">7</td><td align="left">Command+Control+R</td><td align="left">恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">8</td><td align="left">Command+F8</td><td align="left">切换断点(若光标当前行有断点则取消断点，没有则加上断点)</td></tr><tr><td align="left">9</td><td align="left">Command+Shift+F8</td><td align="left">查看断点信息</td></tr></tbody></table><h4 id="Navigation-导航"><a href="#Navigation-导航" class="headerlink" title="Navigation (导航)"></a>Navigation (导航)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+O</td><td align="left">查找类文件</td></tr><tr><td align="left">2</td><td align="left">Command+Shift+O</td><td align="left">查找所类型文件</td></tr><tr><td align="left">3</td><td align="left">Command+Shift+[&#x2F;]</td><td align="left">切换标签页</td></tr><tr><td align="left">4</td><td align="left">Esc</td><td align="left">从工具窗口进入到代码窗口</td></tr><tr><td align="left">5</td><td align="left">Command+L</td><td align="left">在当前文件跳转到某一行的指定处</td></tr><tr><td align="left">6</td><td align="left">Command+E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">7</td><td align="left">Command+Option+向左箭头&#x2F;向右箭头</td><td align="left">退回&#x2F;前进到上一个操作的位置</td></tr><tr><td align="left">8</td><td align="left">Command+Shift+Delete</td><td align="left">跳转到最后一个编辑的地方</td></tr><tr><td align="left">9</td><td align="left">Option+F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">10</td><td align="left">Command+B&#x2F;鼠标点击</td><td align="left">进入光标所在的方法&#x2F;变量的接口或是定义处</td></tr><tr><td align="left">11</td><td align="left">Command+Option+B&#x2F;鼠标点击</td><td align="left">跳转到实现处</td></tr><tr><td align="left">12</td><td align="left">Option+Space&#x2F;Command+Y</td><td align="left">快速打开光标所在方法、类的定义</td></tr><tr><td align="left">13</td><td align="left">Control+Shift+B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">14</td><td align="left">Command+U</td><td align="left">前往当前光标所在方法的父类的方法&#x2F;接口定义</td></tr><tr><td align="left">15</td><td align="left">Command+F12</td><td align="left">弹出当前文件结构层</td></tr><tr><td align="left">16</td><td align="left">Control+H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">17</td><td align="left">Control+Option+H</td><td align="left">显示调用层次结构</td></tr><tr><td align="left">18</td><td align="left">F2&#x2F;Shift+F2</td><td align="left">跳转到上一个&#x2F;下一个突出错误或者警告的位置</td></tr><tr><td align="left">19</td><td align="left">F4</td><td align="left">编辑查看代码源</td></tr><tr><td align="left">20</td><td align="left">Option+F3</td><td align="left">选中文件&#x2F;文件夹&#x2F;代码行，使用助记符添加&#x2F;取消书签</td></tr><tr><td align="left">21</td><td align="left">Command+F3</td><td align="left">显示所有标签</td></tr></tbody></table><h4 id="Refactoring-重构"><a href="#Refactoring-重构" class="headerlink" title="Refactoring (重构)"></a>Refactoring (重构)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">F5</td><td align="left">复制文件到指定目录</td></tr><tr><td align="left">2</td><td align="left">F6</td><td align="left">移动文件到指定目录</td></tr><tr><td align="left">3</td><td align="left">Command+Delete</td><td align="left">在文件上为安全删除文件，弹出确认框</td></tr><tr><td align="left">4</td><td align="left">Shift+F6</td><td align="left">重命名文件</td></tr><tr><td align="left">5</td><td align="left">Command+F6</td><td align="left">更改签名</td></tr><tr><td align="left">6</td><td align="left">Command+Option+M</td><td align="left">将选中的代码提取为方法</td></tr><tr><td align="left">7</td><td align="left">Command+Option+V</td><td align="left">提取变量</td></tr><tr><td align="left">8</td><td align="left">Command+Option+F</td><td align="left">提取字段</td></tr><tr><td align="left">9</td><td align="left">Command+Option+C</td><td align="left">提取常量</td></tr><tr><td align="left">10</td><td align="left">Command+Option+P</td><td align="left">提取参数</td></tr></tbody></table><h4 id="VCS-Local-History-版本控制-本地历史记录"><a href="#VCS-Local-History-版本控制-本地历史记录" class="headerlink" title="VCS&#x2F;Local History (版本控制&#x2F;本地历史记录)"></a>VCS&#x2F;Local History (版本控制&#x2F;本地历史记录)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+K</td><td align="left">提交代码到版本控制器</td></tr><tr><td align="left">2</td><td align="left">Command+T</td><td align="left">从版本控制器更新代码</td></tr><tr><td align="left">3</td><td align="left">Option+Shift+C</td><td align="left">查看最近的变更记录</td></tr></tbody></table><h4 id="Live-Templates-动态模板"><a href="#Live-Templates-动态模板" class="headerlink" title="Live Templates (动态模板)"></a>Live Templates (动态模板)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+Option+J</td><td align="left">弹出模板选择窗口，将选定的代码使用动态模板包住</td></tr><tr><td align="left">2</td><td align="left">Command+J</td><td align="left">插入自定义动态代码模板</td></tr></tbody></table><h4 id="General-通用"><a href="#General-通用" class="headerlink" title="General (通用)"></a>General (通用)</h4><hr><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+1…Command+9</td><td align="left">打开相应编号的工具窗口</td></tr><tr><td align="left">2</td><td align="left">Command+S</td><td align="left">保存所有</td></tr><tr><td align="left">3</td><td align="left">Command+Control+F</td><td align="left">切换全屏模式</td></tr><tr><td align="left">4</td><td align="left">Command+Shift+F12</td><td align="left">切换最大化编辑器</td></tr><tr><td align="left">5</td><td align="left">Option+Shift+F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">6</td><td align="left">Option+Shift+I</td><td align="left">检查当前文件与当前的配置文件</td></tr><tr><td align="left">7</td><td align="left">Command+,</td><td align="left">打开IDEA系统设置</td></tr><tr><td align="left">8</td><td align="left">Command+;</td><td align="left">打开项目结构对话框</td></tr><tr><td align="left">9</td><td align="left">Command+Shift+A</td><td align="left">查找动作</td></tr><tr><td align="left">10</td><td align="left">Control+Tab</td><td align="left">编辑窗口和工具窗口之间切换</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>idea</tag>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 常用扩展点</title>
    <link href="/posts/36493.html"/>
    <url>/posts/36493.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们一说到spring，可能第一个想到的是 <code>IOC</code>（控制反转） 和 <code>AOP</code>（面向切面编程）。</p><p>没错，它们是spring的基石，得益于它们的优秀设计，使得spring能够从众多优秀框架中脱颖而出。</p><p>除此之外，我们在使用spring的过程中，有没有发现它的<code>扩展能力非常强</code>。由于这个优势的存在，让spring拥有强大的包容能力，让很多第三方应用能够轻松投入spring的怀抱。比如：rocketmq、mybatis、redis等。</p><p>今天跟大家一起聊聊，在Spring中最常用的11个扩展点。<img src="/posts/36493/640-20240315112713888.png" alt="图片"></p><h2 id="1-自定义拦截器"><a href="#1-自定义拦截器" class="headerlink" title="1.自定义拦截器"></a>1.自定义拦截器</h2><p>spring mvc拦截器根spring拦截器相比，它里面能够获取<code>HttpServletRequest</code>和<code>HttpServletResponse</code>等web对象实例。</p><p>spring mvc拦截器的顶层接口是：<code>HandlerInterceptor</code>，包含三个方法：</p><ul><li>preHandle 目标方法执行前执行</li><li>postHandle 目标方法执行后执行</li><li>afterCompletion 请求完成时执行</li></ul><p>为了方便我们一般情况会用<code>HandlerInterceptor</code>接口的实现类<code>HandlerInterceptorAdapter</code>类。</p><p>假如有权限认证、日志、统计的场景，可以使用该拦截器。</p><p>第一步，继承<code>HandlerInterceptorAdapter</code>类定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandlerInterceptorAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestUrl</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (checkAuth(requestUrl)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkAuth</span><span class="hljs-params">(String requestUrl)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;===权限校验===&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，将该拦截器注册到spring容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebAuthConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> AuthInterceptor <span class="hljs-title function_">getAuthInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthInterceptor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。</p><h2 id="2-获取Spring容器对象"><a href="#2-获取Spring容器对象" class="headerlink" title="2.获取Spring容器对象"></a>2.获取Spring容器对象</h2><p>在我们日常开发中，经常需要从Spring容器中获取Bean，但你知道如何获取Spring容器对象吗？</p><h3 id="2-1-BeanFactoryAware接口"><a href="#2-1-BeanFactoryAware接口" class="headerlink" title="2.1 BeanFactoryAware接口"></a>2.1 BeanFactoryAware接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span> &#123;<br>    <span class="hljs-keyword">private</span> BeanFactory beanFactory;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) beanFactory.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>BeanFactoryAware</code>接口，然后重写<code>setBeanFactory</code>方法，就能从该方法中获取到spring容器对象。</p><h3 id="2-2-ApplicationContextAware接口"><a href="#2-2-ApplicationContextAware接口" class="headerlink" title="2.2 ApplicationContextAware接口"></a>2.2 ApplicationContextAware接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>ApplicationContextAware</code>接口，然后重写<code>setApplicationContext</code>方法，也能从该方法中获取到spring容器对象。</p><h3 id="2-3-ApplicationListener接口"><a href="#2-3-ApplicationListener接口" class="headerlink" title="2.3 ApplicationListener接口"></a>2.3 ApplicationListener接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        applicationContext = event.getApplicationContext();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3.全局异常处理"></a>3.全局异常处理</h2><p>以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/add&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不做任何处理请求add接口结果直接报错：</p><p><img src="/posts/36493/640-20240315112713892.png" alt="图片"></p><p>what？用户能直接看到错误信息？</p><p>这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/add&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        result = <span class="hljs-string">&quot;数据异常&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。</p><p>看起来挺不错的，但是有问题。。。</p><p>如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？</p><p>答案是否定的，这时全局异常处理就派上用场了：<code>RestControllerAdvice</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleException</span><span class="hljs-params">(Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ArithmeticException) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据异常&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Exception) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器内部异常&quot;</span>;<br>        &#125;<br>        retur nnull;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需在<code>handleException</code>方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。</p><h2 id="4-类型转换器"><a href="#4-类型转换器" class="headerlink" title="4.类型转换器"></a>4.类型转换器</h2><p>spring目前支持3中类型转换器：</p><ul><li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li><li>ConverterFactory&lt;S, R&gt;：将 S 类型对象转为 R 类型及子类对象</li><li>GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</li></ul><p>这3种类型转换器使用的场景不一样，我们以<code>Converter&lt;S,T&gt;为</code>例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？</p><p>第一步，定义一个实体User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Date registerDate;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，实现<code>Converter</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;String, Date&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">convert</span><span class="hljs-params">(String source)</span> &#123;<br>        <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(source)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                simpleDateFormat.parse(source);<br>            &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步，将新定义的类型转换器注入到spring容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFormatters</span><span class="hljs-params">(FormatterRegistry registry)</span> &#123;<br>        registry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateConverter</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步，调用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求接口时User对象中registerDate字段会被自动转换成Date类型。</p><h2 id="5-导入配置"><a href="#5-导入配置" class="headerlink" title="5.导入配置"></a>5.导入配置</h2><p>有时我们需要在某个配置类中引入另外一些类，被引入的类也加到spring容器中。这时可以使用<code>@Import</code>注解完成这个功能。</p><p>如果你看过它的源码会发现，引入的类支持三种不同类型。</p><p>但是我认为最好将普通类和@Configuration注解的配置类分开讲解，所以列了四种不同类型：</p><p><img src="/posts/36493/640-20240315112713945.png" alt="图片"></p><h3 id="5-1-普通类"><a href="#5-1-普通类" class="headerlink" title="5.1 普通类"></a>5.1 普通类</h3><p>这种引入方式是最简单的，被引入的类会被实例化bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Import(A.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>@Import</code>注解引入A类，spring就能自动实例化A对象，然后在需要使用的地方通过<code>@Autowired</code>注解注入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> A a;<br></code></pre></td></tr></table></figure><p>是不是挺让人意外的？不用加<code>@Bean</code>注解也能实例化bean。</p><h3 id="5-2-配置类"><a href="#5-2-配置类" class="headerlink" title="5.2 配置类"></a>5.2 配置类</h3><p>这种引入方式是最复杂的，因为<code>@Configuration</code>注解还支持多种组合注解，比如：</p><ul><li>@Import</li><li>@ImportResource</li><li>@PropertySource等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Import(B.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AConfiguration.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过@Import注解引入@Configuration注解的配置类，会把该配置类相关<code>@Import</code>、<code>@ImportResource</code>、<code>@PropertySource</code>等注解引入的类进行递归，一次性全部引入。</p><h3 id="5-3-ImportSelector"><a href="#5-3-ImportSelector" class="headerlink" title="5.3 ImportSelector"></a>5.3 ImportSelector</h3><p>这种引入方式需要实现<code>ImportSelector</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLASS_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.sue.cache.service.test13.A&quot;</span>;<br>    <br> <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;CLASS_NAME&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AImportSelector.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的好处是<code>selectImports</code>方法返回的是数组，意味着可以同时引入多个类，还是非常方便的。</p><h3 id="5-4-ImportBeanDefinitionRegistrar"><a href="#5-4-ImportBeanDefinitionRegistrar" class="headerlink" title="5.4 ImportBeanDefinitionRegistrar"></a>5.4 ImportBeanDefinitionRegistrar</h3><p>这种引入方式需要实现<code>ImportBeanDefinitionRegistrar</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">rootBeanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(A.class);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;a&quot;</span>, rootBeanDefinition);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AImportBeanDefinitionRegistrar.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是最灵活的，能在<code>registerBeanDefinitions</code>方法中获取到<code>BeanDefinitionRegistry</code>容器注册对象，可以手动控制BeanDefinition的创建和注册。</p><h2 id="6-项目启动时"><a href="#6-项目启动时" class="headerlink" title="6.项目启动时"></a>6.项目启动时</h2><p>有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，该怎么办呢？</p><p>好消息是springboot提供了：</p><ul><li>CommandLineRunner</li><li>ApplicationRunner</li></ul><p>这两个接口帮助我们实现以上需求。</p><p>它们的用法还是挺简单的，以<code>ApplicationRunner</code>接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoadDataService loadDataService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        loadDataService.load();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>ApplicationRunner</code>接口，重写<code>run</code>方法，在该方法中实现自己定制化需求。</p><p>如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？</p><p>答案是使用<code>@Order(n)</code>注解，n的值越小越先执行。当然也可以通过<code>@Priority</code>注解指定顺序。</p><h2 id="7-修改BeanDefinition"><a href="#7-修改BeanDefinition" class="headerlink" title="7.修改BeanDefinition"></a>7.修改BeanDefinition</h2><p>Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到<code>BeanDefinition</code>对象中，然后通过BeanDefinition对象，实例化Bean对象。</p><p>如果想修改BeanDefinition对象中的属性，该怎么办呢？</p><p>答：我们可以实现<code>BeanFactoryPostProcessor</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">defaultListableBeanFactory</span> <span class="hljs-operator">=</span> (DefaultListableBeanFactory) configurableListableBeanFactory;<br>        <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">beanDefinitionBuilder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(User.class);<br>        beanDefinitionBuilder.addPropertyValue(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">123</span>);<br>        beanDefinitionBuilder.addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;苏三说技术&quot;</span>);<br>        defaultListableBeanFactory.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinitionBuilder.getBeanDefinition());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在postProcessBeanFactory方法中，可以获取BeanDefinition的相关对象，并且修改该对象的属性。</p><h2 id="8-初始化Bean前后"><a href="#8-初始化Bean前后" class="headerlink" title="8.初始化Bean前后"></a>8.初始化Bean前后</h2><p>有时，你想在初始化Bean前后，实现一些自己的逻辑。</p><p>这时可以实现：<code>BeanPostProcessor</code>接口。</p><p>该接口目前有两个方法：</p><ul><li>postProcessBeforeInitialization 该在初始化方法之前调用。</li><li>postProcessAfterInitialization 该方法再初始化方法之后调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> User) &#123;<br>            ((User) bean).setUserName(<span class="hljs-string">&quot;苏三说技术&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果spring中存在User对象，则将它的userName设置成：苏三说技术。</p><p>其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。</p><h2 id="9-初始化方法"><a href="#9-初始化方法" class="headerlink" title="9.初始化方法"></a>9.初始化方法</h2><p>目前spring中使用比较多的初始化bean的方法有：</p><ol><li>使用@PostConstruct注解</li><li>实现InitializingBean接口</li></ol><h3 id="9-1-使用-PostConstruct注解"><a href="#9-1-使用-PostConstruct注解" class="headerlink" title="9.1 使用@PostConstruct注解"></a>9.1 使用@PostConstruct注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AService</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;===初始化===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在需要初始化的方法上增加<code>@PostConstruct</code>注解，这样就有初始化的能力。</p><h3 id="9-2-实现InitializingBean接口"><a href="#9-2-实现InitializingBean接口" class="headerlink" title="9.2 实现InitializingBean接口"></a>9.2 实现InitializingBean接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;===初始化===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>InitializingBean</code>接口，重写<code>afterPropertiesSet</code>方法，该方法中可以完成初始化功能。</p><h2 id="10-关闭容器前"><a href="#10-关闭容器前" class="headerlink" title="10.关闭容器前"></a>10.关闭容器前</h2><p>有时候，我们需要在关闭spring容器前，做一些额外的工作，比如：关闭资源文件等。</p><p>这时可以实现<code>DisposableBean</code>接口，并且重写它的<code>destroy</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, DisposableBean &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;DisposableBean destroy&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;InitializingBean afterPropertiesSet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样spring容器销毁前，会调用该destroy方法，做一些额外的工作。</p><p>通常情况下，我们会同时实现InitializingBean和DisposableBean接口，重写初始化方法和销毁方法。</p><h2 id="11-自定义作用域"><a href="#11-自定义作用域" class="headerlink" title="11.自定义作用域"></a>11.自定义作用域</h2><p>我们都知道spring默认支持的<code>Scope</code>只有两种：</p><ul><li>singleton 单例，每次从spring容器中获取到的bean都是同一个对象。</li><li>prototype 多例，每次从spring容器中获取到的bean都是不同的对象。</li></ul><p>spring web又对Scope进行了扩展，增加了：</p><ul><li>RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。</li><li>SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。</li></ul><p>即便如此，有些场景还是无法满足我们的要求。</p><p>比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？</p><p>这就需要自定义Scope了。</p><p>第一步实现Scope接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Scope</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">THREAD_LOCAL_SCOPE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> THREAD_LOCAL_SCOPE.get();<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> objectFactory.getObject();<br>        THREAD_LOCAL_SCOPE.set(object);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(String name)</span> &#123;<br>        THREAD_LOCAL_SCOPE.remove();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDestructionCallback</span><span class="hljs-params">(String name, Runnable callback)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveContextualObject</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConversationId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步将新定义的Scope注入到spring容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        beanFactory.registerScope(<span class="hljs-string">&quot;threadLocalScope&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalScope</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步使用新定义的Scope：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(&quot;threadLocalScope&quot;)</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>家庭 Nas 打造全自动追剧流程</title>
    <link href="/posts/52833.html"/>
    <url>/posts/52833.html</url>
    
    <content type="html"><![CDATA[<p><strong>一套本地的追剧系统</strong></p><span id="more"></span><h3 id="Indexer-种子索引"><a href="#Indexer-种子索引" class="headerlink" title="Indexer 种子索引"></a>Indexer 种子索引</h3><h4 id="Jackett"><a href="#Jackett" class="headerlink" title="Jackett"></a>Jackett</h4><ul><li>Docker: <a href="https://hub.docker.com/r/linuxserver/jackett">linuxserver&#x2F;jackett:latest</a></li></ul><p><strong>Jackett</strong> 是一个流行的开源应用程序，用于充当多种种子站点（<em>Torrent</em>站点）的中央索引器，以便它们可以被<em>Sonarr</em>、<em>Radarr</em>、<em>Lidarr</em>、<em>CouchPotato</em>等自动下载工具使用。</p><p>简而言之，Jackett允许你在流行的种子站点上进行搜索，并提供一个统一的API，使得你可以通过其他下载和媒体管理软件访问这些站点的内容。这对于那些希望将下载过程自动化的人来说非常有用，因为他们可以利用 <em>Jackett</em> 来连接这些站点，然后再将其与其他下载工具集成</p><p>主要功能包括：</p><ol><li><p>多种子站点支持：Jackett 支持众多种子站点，包括一些受欢迎的私人和公共站点，使你可以通过单一的界面搜索这些站点。</p></li><li><p>API接口：Jackett 提供了一个RESTful API，允许其他应用程序通过HTTP请求来搜索种子站点和获取搜索结果。</p></li><li><p>配置灵活：你可以通过 Jackett 的Web界面轻松添加、删除或配置种子站点，这样可以根据你的喜好和需求定制索引列表。</p></li><li><p>安全代理：Jackett 可以充当安全代理，以便你可以通过它来访问私人种子站点，而无需将敏感凭据直接提供给其他应用程序。</p></li><li><p>开源：Jackett 是一个开源项目，这意味着任何人都可以查看其源代码，对其进行审查、修改和改进。</p></li></ol><p>需要注意的是，Jackett本身并不提供种子下载功能，它只是一个搜索引擎，用于帮助你找到想要下载的内容，并将结果提供给其他下载工具处理</p><p><img src="/posts/52833/image-20230725180625744.png" alt="image-20230725180625744"></p><h5 id="使用-Docker-部署-Jackett"><a href="#使用-Docker-部署-Jackett" class="headerlink" title="使用 Docker 部署 Jackett"></a>使用 Docker 部署 Jackett</h5><p>根据自身情况适当修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>  --name=jackett \<br>  -e PUID=1000 \<br>  -e PGID=1000 \<br>  -e TZ=Asia/Shanghai \<br>  -e AUTO_UPDATE=true `#optional` \<br>  -p 9117:9117 \<br>  -v /share/Container/jackett/config:/config \<br>  -v /share/Container/jackett/torrent:/downloads \<br>  --restart unless-stopped \<br>  linuxserver/jackett:amd64-latest<br></code></pre></td></tr></table></figure><p>部署完成后在本地的9117端口上就能看到 Jackett 的 web 页面（如上图）</p><h5 id="添加-Index"><a href="#添加-Index" class="headerlink" title="添加 Index"></a>添加 Index</h5><p><img src="/posts/52833/image-20230725181407939.png" alt="image-20230725181407939"></p><p>因为我们追剧主要就是电视剧和动画片，个人比较推荐的就是</p><p><img src="/posts/52833/image-20230725181535744.png" alt="image-20230725181535744"></p><p>其他的也可以自己去尝试，但是有些网站不能直接访问（需要魔法🪄）</p><p>另外还有些是 Private 的 Indexer，一般需要登陆才能够访问，例如：</p><p><img src="/posts/52833/image-20230725181708630.png" alt="image-20230725181708630"></p><p>需要在小扳手里填写自己的账号信息</p><p>Jackett 中我们需要几个参数，<code>API KEY</code>，<code>category</code> 和 <code>index</code> 地址，这里面的 index 地址我们选择<strong>Torznab Feed</strong>，这是 <strong>Sonarr</strong> 和 <strong>Raddar</strong> 都支持的 API，点击 <code>Copy Torznab Feed</code> 后即可拿到 index 地址，之后有用</p><p>获得 <code>category</code>，点击扳手获取</p><p><img src="/posts/52833/image-20230725181937918.png" alt="image-20230725181937918"></p><h3 id="剧集管理"><a href="#剧集管理" class="headerlink" title="剧集管理"></a>剧集管理</h3><h4 id="Sonarr"><a href="#Sonarr" class="headerlink" title="Sonarr"></a>Sonarr</h4><ul><li>Docker: <a href="https://hub.docker.com/r/linuxserver/sonarr">linuxserver&#x2F;sonarr</a></li></ul><p><em>Sonarr</em> 是一个开源的电视剧系列自动下载工具，它允许用户自动搜索、下载和管理电视剧的新剧集</p><p><em>Sonarr</em> 具有以下主要功能：</p><ol><li><p><strong>自动搜索和下载：</strong> Sonarr 可以定期检查你想要追踪的电视剧，一旦有新的剧集可用，它会自动搜索并下载这些剧集。用户可以配置 Sonarr 使用的种子站点和下载器，以便将下载任务发送到指定的下载客户端（如qBittorrent、Deluge、Transmission等）</p></li><li><p><strong>RSS Feed 支持：</strong> Sonarr 支持 RSS Feed，这意味着它可以通过订阅电视剧的 RSS Feed 来获取最新剧集的信息，并根据用户的设置自动下载新的剧集</p></li><li><p><strong>定制化：</strong> 用户可以根据自己的需求和喜好对 Sonarr 进行定制。你可以选择要监视哪些电视剧，设置下载质量和规则，选择下载器和种子站点等等</p></li><li><p><strong>质量管理：</strong> Sonarr 允许你设置首选的剧集质量，比如高清、标清、WEB-DL、Blu-ray等，然后它会尽量自动下载符合你要求的版本</p></li><li><p><strong>自动整理：</strong> Sonarr 可以将下载好的剧集自动整理到你指定的目录中，并根据设定的命名规则进行命名，以便更好地组织你的媒体文件库</p></li><li><p><strong>通知和提醒：</strong> Sonarr 支持各种通知和提醒方式，如电子邮件、Slack、Pushbullet等，这样你可以及时了解下载状态和新剧集的到来</p></li><li><p><strong>历史记录和统计：</strong> Sonarr 提供下载历史记录和统计信息，方便用户查看过去的下载活动和性能</p></li></ol><p>Sonarr 的用户界面简洁友好，容易上手。它是一个功能强大且广受欢迎的自动下载工具，适用于那些喜欢追踪并自动获取电视剧的人</p><h5 id="使用-Docker-部署"><a href="#使用-Docker-部署" class="headerlink" title="使用 Docker 部署"></a>使用 Docker 部署</h5><p>根据自身情况适当修改，所有的影视目录都需要这样分门别类的挂载，后面的 qBittorrent 也要这样，这里至关重要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>  --name=sonarr \<br>  -e PUID=1000 \<br>  -e PGID=1000 \<br>  -e TZ=Asia/Shanghai \<br>  -p 8989:8989 \<br>  -v /share/Container/sonarr/config:/config \<br>  -v /share/Multimedia/TVseries:/tv \<br>  -v /share/Multimedia/Movie:/movie \<br>  --restart unless-stopped \<br>  linuxserver/sonarr:amd64-latest<br></code></pre></td></tr></table></figure><p>这里的 <code>/share/Multimedia/TVseries</code> 和 <code>/share/Multimedia/Movie</code> 就是之后存放剧集和电影的宿主机目录，<code>/tv</code> 和 <code>/movie</code> 是挂载的路径，也是之后配置中<strong>需要添加的目录</strong></p><p>安装成功后可以在本地8989端口上看到 Sonarr 的 web 界面</p><h5 id="Media-Management-配置"><a href="#Media-Management-配置" class="headerlink" title="Media Management 配置"></a>Media Management 配置</h5><p><img src="/posts/52833/image-20230725182845996.png" alt="image-20230725182845996"></p><p>打开 <code>Settings</code> - <code>Media Management</code>，选择 <code>Add Root Folder</code> 将之前的目录都添加上去</p><h5 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h5><p><img src="/posts/52833/image-20230725183140921.png" alt="image-20230725183140921"></p><p><code>Any</code> 的配置根据自己的需要修改，表示了影片的质量，Upgrade Until 根据个人需要可开可不开，这个是在有更好质量的文件的时候会自动再下载更好质量的文件做替换</p><p><code>Language Profiles</code> 语言这里只下美剧不用改，下动画片需要多加个中文</p><h5 id="Indexers"><a href="#Indexers" class="headerlink" title="Indexers"></a>Indexers</h5><p>Index 我这里用了这几个，从 Jackett 中获取，可以根据个人需要增加&#x2F;减少</p><p><img src="/posts/52833/image-20230725183440342.png" alt="image-20230725183440342"></p><p>点击 + 号添加一个新配置，选择 Torznab，将我们之前在 Jackett 中复制的链接复制进去</p><p><img src="/posts/52833/image-20230725183608559.png" alt="image-20230725183608559"></p><p><strong>API key</strong> 在 Jackett web 页面的右上方</p><p>关于 <strong>Categories</strong> 要填写对应的，电视剧就填写电视剧的，动画片就填写动画片的，用英文逗号做分隔符，添加完毕后可以点击下方的 <code>Test</code> 按钮测试，测试通过就行</p><h5 id="Download-Clients"><a href="#Download-Clients" class="headerlink" title="Download Clients"></a>Download Clients</h5><p>我用的 <em>qBittorrent</em></p><p><img src="/posts/52833/image-20230725183928292.png" alt="image-20230725183928292"></p><p>这里的配置在之后安装好了 qBittorrent 之后就懂了，Category 这个配置可配可不配</p><p><strong>Sonarr</strong> 的基本设置就结束了</p><h5 id="Sonarr-使用"><a href="#Sonarr-使用" class="headerlink" title="Sonarr 使用"></a>Sonarr 使用</h5><p><img src="/posts/52833/image-20230725184535580.png" alt="image-20230725184535580"></p><p>直接搜索即可，尽量用英文，或者用 TVDB ID 搜索，比如 tvdb:71663</p><p><img src="/posts/52833/image-20230725184726020.png" alt="image-20230725184726020"></p><p><img src="/posts/52833/image-20230725184955435-0282196.png" alt="image-20230725184955435"></p><p><img src="/posts/52833/image-20230725185234880.png" alt="image-20230725185234880"></p><p><strong>monitor</strong> 常用的一般有两种，<code>All Episodes</code>，<code>Future Episodes</code></p><ul><li>All Episodes，下载已播出的全部剧集</li><li>Future Episodes，将要更新的剧集，已播出的不下载</li></ul><p><img src="/posts/52833/image-20230725185304847.png" alt="image-20230725185304847"></p><p>添加成功后会自动搜索 Indexers 中的种子，然后调用 qBittorrent 下载，最重要的是 <strong>sonarr 会自动检测剧集更新</strong>，一旦更新会自动下载，然后将下载好的剧集移到对应位置</p><p><img src="/posts/52833/image-20230725185832991.png" alt="image-20230725185832991"></p><p><strong>已播出剧集的剧集下载</strong></p><p>在已播出的整季剧集上，点season栏的放大镜是自动搜索并下载，人像是交互式搜索选择自己想要的文件下载</p><p><img src="/posts/52833/image-20230725190016563.png" alt="image-20230725190016563"></p><p>每一集剧情的小放大镜是那一集的自动搜索并下载，同理，小人像是那一集的交互式搜索选择自己想要的文件下载</p><p><strong>导入剧集</strong></p><p><img src="/posts/52833/image-20230725203519880.png" alt="image-20230725203519880"></p><p>将其他地方下载好的剧集目录放入之前挂载的目录下，比如 <code>新世纪福音战士.Neon.Genesis.Evangelion.1995.S01.1080p.NF.WEB-DL.H264.DDP5.1-YingWEB</code> 放到之前的 <code>/share/Multimedia/TVseries</code> 下，然后在 <code>Library Import</code> 中选择对应的 <code>/tv</code> 目录，会看到如上画面。</p><p>Sonarr 会自动寻找匹配的剧集，如果不对可以自己在最后手动修改，然后点击下面 <code>Import 1 Series</code></p><p>之后就在 Series 中看到导入的剧集</p><p><img src="/posts/52833/image-20230725203953310.png" alt="image-20230725203953310"></p><p><img src="/posts/52833/image-20230725204016562.png" alt="image-20230725204016562"></p><p>上面选项 Preview Rename 可以按照统一格式修改文件命名，Refresh &amp; Scan 可以重新刷新&amp;扫描</p><h3 id="BT下载工具"><a href="#BT下载工具" class="headerlink" title="BT下载工具"></a>BT下载工具</h3><blockquote><p>qBittorrent下载，种子分类整理较好，但占用资源，内存较多</p><p>Transmissoin种子整理分类远不如qBittorrent，但资源占用低</p></blockquote><h4 id="qBittorrent"><a href="#qBittorrent" class="headerlink" title="qBittorrent"></a>qBittorrent</h4><ul><li>Docker：<a href="https://hub.docker.com/r/linuxserver/qbittorrent">linuxserver&#x2F;qbittorrent</a></li></ul><p>qBittorrent 是一个开源的 <em>BitTorrent</em> 客户端，用于下载和共享种子文件，它是μTorrent（uTorrent）的一个替代选择</p><p>qBittorrent 具有以下主要特点和功能：</p><ol><li><p><strong>免费且开源：</strong> qBittorrent是完全免费的，并且它是开源软件，这意味着任何人都可以查看、修改和贡献代码</p></li><li><p><strong>轻量级和跨平台：</strong> qBittorrent 软件本身体积较小且资源占用较少，因此可以在各种计算机和操作系统上运行，包括Windows、macOS、Linux以及FreeBSD等</p></li><li><p><strong>无广告：</strong> 与一些其他BitTorrent客户端不同，qBittorrent 不包含任何广告或附加软件，提供纯净的下载体验</p></li><li><p><strong>IP过滤和阻止：</strong> qBittorrent 允许用户使用IP过滤器来阻止某些IP地址或IP范围的连接，提高下载安全性和隐私保护</p></li><li><p><strong>优先级管理：</strong> 用户可以设置下载任务的优先级，以便调整下载顺序和速度</p></li><li><p><strong>种子管理：</strong> qBittorrent 提供直观的界面来管理种子文件，你可以暂停、取消、删除或重新检查种子的完整性</p></li><li><p><strong>Web界面：</strong> qBittorrent 还有一个基于Web的界面，让你可以通过浏览器远程管理和监控你的下载任务</p></li><li><p><strong>加密支持：</strong> qBittorrent 支持协议加密来保护用户的隐私和数据安全</p></li><li><p><strong>RSS订阅：</strong> qBittorrent 允许用户订阅RSS Feed，以便自动获取最新的种子和内容</p></li></ol><p>总体而言，qBittorrent 是一个功能齐全、稳定可靠的BitTorrent客户端，提供了许多高级选项和配置，同时简单易用</p><h5 id="使用-Docker-部署-1"><a href="#使用-Docker-部署-1" class="headerlink" title="使用 Docker 部署"></a>使用 Docker 部署</h5><p>建议用<strong>下面的</strong>，linuxserver 的 webUI 会401，网上的解决方法不太稳定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>  --name=qbittorrent \<br>  -e PUID=1000 \<br>  -e PGID=1000 \<br>  -e TZ=Asia/Shanghai \<br>  -e WEBUI_PORT=8081 \<br>  -p 8081:8080 \<br>  -p 6881:6881 \<br>  -p 6881:6881/udp \<br>  -v /share/Container/qbittorrent/config:/config \<br>  -v /share/Container/qbittorrent/data:/downloads \<br>  -v /share/Multimedia/Movie:/movie \<br>  -v /share/Multimedia/TVseries:/tv \<br>  --restart unless-stopped \<br>  linuxserver/qbittorrent:amd64-latest<br><br><br>docker run -d  \<br>    --name=qbittorrent  \<br>    -e WEBUIPORT=8081  \<br>    -e PUID=1000 \<br>    -e PGID=1000 \<br>    -e TZ=Asia/Shanghai \<br>    -p 6881:6881  \<br>    -p 6881:6881/udp  \<br>    -p 8081:8080  \<br>    -v /share/Container/qbittorrent/config:/config \<br>    -v /share/Container/qbittorrent/data:/downloads \<br>    -v /share/Multimedia/Movie:/movie \<br>    -v /share/Multimedia/TVseries:/tv \<br>    --restart unless-stopped \<br>    superng6/qbittorrent:latest<br></code></pre></td></tr></table></figure><p>除了 config 和 data 文件夹之外， <strong>sonarr</strong> 挂载了什么目录，<strong>qBittorrent</strong> 就挂载什么目录，并且位置必须一致</p><h5 id="qBittorrent-配置"><a href="#qBittorrent-配置" class="headerlink" title="qBittorrent 配置"></a>qBittorrent 配置</h5><p>打开本地8081端口可以看到 qBittorrent web 界面</p><p>选择 <code>Tools</code> - <code>Options</code> - <code>WebUI</code>，将语言改成中文</p><p><img src="/posts/52833/image-20230725192339628.png" alt="image-20230725192339628"></p><p>这里的配置填入到之前 Sonarr 的 [Download Clients](#Download Clients) 中</p><p><img src="/posts/52833/image-20230725192442921.png" alt="image-20230725192442921"></p><p>将这个选项取消，qBittorrent 的配置基本完成</p><h3 id="多媒体中心"><a href="#多媒体中心" class="headerlink" title="多媒体中心"></a>多媒体中心</h3><h4 id="Plex"><a href="#Plex" class="headerlink" title="Plex"></a>Plex</h4><ul><li>Docker：<a href="https://hub.docker.com/r/linuxserver/plex">linuxserver&#x2F;plex</a></li></ul><p>Plex 是一个流媒体服务器软件，它允许你将个人媒体文件（如电影、电视剧、音乐、照片等）存储在中央服务器上，并通过各种设备在家庭网络中进行流媒体传输和共享。Plex 提供了一个用户友好的界面，使你能够在多种设备上访问和播放你的媒体内容</p><p>Plex 的主要特点和功能：</p><ol><li><p><strong>媒体服务器：</strong> Plex 提供了一个媒体服务器，你可以在其中组织和存储你的媒体文件。它支持多种媒体类型，包括视频、音乐、照片和播客等</p></li><li><p><strong>多平台支持：</strong> Plex 可以在各种平台上运行，包括Windows、macOS、Linux、iOS、Android、Apple TV、Roku、PlayStation、Xbox等。这样，你可以在不同的设备上访问和播放你的媒体</p></li><li><p><strong>美观的用户界面：</strong> Plex 提供了一个漂亮、直观的用户界面，使你能够轻松地浏览和搜索你的媒体库，并快速找到想要观看或收听的内容</p></li><li><p><strong>远程访问：</strong> 你可以通过Plex账号登录，在任何拥有互联网连接的设备上访问你的媒体库，无论你身在何处</p></li><li><p><strong>实时转码：</strong> Plex 可以根据你设备的性能和网络条件，实时对媒体文件进行转码，以确保流畅播放。这意味着你可以在不同设备上流畅地观看高清视频，无需为设备兼容性而担心</p></li><li><p><strong>共享库：</strong> 你可以创建多个用户，并为每个用户设置独立的访问权限，从而共享你的媒体库给家庭成员或朋友</p></li><li><p><strong>元数据和海报：</strong> Plex 自动从互联网数据库中获取元数据（如电影信息、剧集信息、歌曲信息等）和海报，为你的媒体内容增加美观的展示效果</p></li><li><p><strong>频道和插件：</strong> Plex 支持各种频道和插件，你可以通过它们获得来自互联网的额外内容，如在线视频、网络电视等</p></li></ol><h5 id="使用-Docker-部署-2"><a href="#使用-Docker-部署-2" class="headerlink" title="使用 Docker 部署"></a>使用 Docker 部署</h5><p>根据自身情况适当修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>  --name=plex \<br>  --net=host \<br>  -e PUID=1000 \<br>  -e PGID=1000 \<br>  -e TZ=Asia/Shanghai \<br>  -e VERSION=docker \<br>  -e PLEX_CLAIM= `<span class="hljs-comment">#optional` \</span><br>  -v /path/to/library:/config \<br>  -v /path/to/tvseries:/tv \<br>  -v /path/to/movies:/movies \<br>  --restart unless-stopped \<br>  lscr.io/linuxserver/plex:latest<br></code></pre></td></tr></table></figure><p><code>/path/to/tvseries</code> 和 <code>/path/to/movies </code> 改为之前挂载的目录</p><h5 id="安装插件（可选）"><a href="#安装插件（可选）" class="headerlink" title="安装插件（可选）"></a>安装插件（可选）</h5><ul><li>XBMCnfoMoviesImporter</li></ul><p><a href="https://github.com/gboudreau/XBMCnfoMoviesImporter.bundle">https://github.com/gboudreau/XBMCnfoMoviesImporter.bundle</a></p><p>下载插件<a href="https://github.com/gboudreau/XBMCnfoMoviesImporter.bundle/archive/master.zip">压缩包</a>，解压出来重命名为<strong>XBMCnfoMoviesImporter.bundle</strong>，找到 Plex Media Server data 目录（找不到的可以看<a href="https://support.plex.tv/articles/202915258-where-is-the-plex-media-server-data-directory-located/">这里</a>参考），将 .bundle 文件夹放进 Plug-ins 目录下重启 Plex</p><p>注意事项：</p><blockquote><ol><li>XBMCnfoMoviesImporter.bundle 不会出现在插件里面，媒体库代理里面安装成功后直接能用</li><li>XBMCnfoMoviesImporter.bundle 安装后，能识别本地nfo里面的元数据</li></ol></blockquote><h5 id="添加媒体库"><a href="#添加媒体库" class="headerlink" title="添加媒体库"></a>添加媒体库</h5><p>点击 Plex 右上角的扳手按钮，找到左边目录下的媒体库</p><p><img src="/posts/52833/image-20230725202156430.png" alt="image-20230725202156430"></p><p>选择添加你自己的媒体库，比如之前 Sonarr 挂载的剧集和电影目录</p><p><img src="/posts/52833/image-20230725202328051.png" alt="image-20230725202328051"></p><p>如果你要使用 Sonarr 刮削的剧集信息（也就是本地自己刮削的nfo信息），就在代理里选择XBMC插件的代理，电影资料选择 XBMCnfoMoviesImporter ，电视剧集选择 XBMCnfoTVImporter，也可以直接用 Plex 提供的 Plex moive 和 Plex TV Series</p><p><img src="/posts/52833/image-20230725202641854.png" alt="image-20230725202641854"></p><p>等到扫描完成后，效果如图</p><p><img src="/posts/52833/image-20230725203058018.png" alt="image-20230725203058018"></p><h4 id="Emby"><a href="#Emby" class="headerlink" title="Emby"></a>Emby</h4><h4 id="Jellyfin"><a href="#Jellyfin" class="headerlink" title="Jellyfin"></a>Jellyfin</h4><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><h4 id="Home管理"><a href="#Home管理" class="headerlink" title="Home管理"></a>Home管理</h4><h5 id="homarr"><a href="#homarr" class="headerlink" title="homarr"></a>homarr</h5><h4 id="漫画管理"><a href="#漫画管理" class="headerlink" title="漫画管理"></a>漫画管理</h4><h5 id="mylar3"><a href="#mylar3" class="headerlink" title="mylar3"></a>mylar3</h5><h5 id="komga"><a href="#komga" class="headerlink" title="komga"></a>komga</h5><h5 id="manga"><a href="#manga" class="headerlink" title="manga"></a>manga</h5><h4 id="图书管理"><a href="#图书管理" class="headerlink" title="图书管理"></a>图书管理</h4><h5 id="readarr"><a href="#readarr" class="headerlink" title="readarr"></a>readarr</h5><h5 id="calibre"><a href="#calibre" class="headerlink" title="calibre"></a>calibre</h5><h4 id="Docker管理"><a href="#Docker管理" class="headerlink" title="Docker管理"></a>Docker管理</h4><h5 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h5>]]></content>
    
    
    <categories>
      
      <category>Nas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 基础</title>
    <link href="/posts/27273.html"/>
    <url>/posts/27273.html</url>
    
    <content type="html"><![CDATA[<p><strong>Redis</strong>（<em>Remote Dictionary Server</em>）是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。它也被称为<strong>数据结构服务器</strong>，支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）等</p><span id="more"></span><p>Redis主要用于缓存、会话存储、实时分析、消息队列等场景，以及在需要快速读写访问的应用中</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis 提供了丰富的数据类型，常见的有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</strong>之后又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong></p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 是其中一种最基本的数据类型之一，它是一个二进制安全的字符串，可以包含任意数据，例如文本、整数、浮点数等。Redis 的 String 类型非常灵活，可以用于多种用途</p><p>String 类型的主要特点和操作：</p><ol><li><p>存储任意数据：String 类型可以存储任意的二进制数据，不仅仅限于文本，这使得它在缓存和存储数据方面非常有用</p></li><li><p>原子性操作：Redis 提供了一系列原子性操作，可以对 String 类型进行操作，如设置值、获取值、增加值、减少值等</p></li><li><p>设置和获取值：使用 SET 命令可以设置 String 类型的值，使用 GET 命令可以获取 String 类型的值</p></li><li><p>自增和自减：使用 INCR 和 DECR 命令可以对存储的整数值进行自增和自减操作</p></li><li><p>设置过期时间：可以为 String 类型设置过期时间，即在一定时间后自动删除</p></li><li><p>批量操作：Redis 支持批量操作多个 String 类型的数据，以提高性能和减少网络开销</p></li><li><p>计算长度：使用 STRLEN 命令可以计算存储在 String 类型中的字符串的长度</p></li><li><p>位操作：Redis 还支持对存储在 String 类型中的二进制数据进行位操作，如AND、OR、XOR等</p></li></ol><p>String 类型是 Redis 最常用的数据类型之一，它的简单和高效使得它成为了在缓存、计数器、会话存储等方面的理想选择。由于 String 类型的值是二进制安全的，因此它可以用于存储各种形式的数据，并在需要的时候通过 GET、SET 等命令进行操作。需要根据具体应用场景来选择合适的数据类型，String 类型适用于大多数简单的键值对存储需求</p><h5 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h5><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）</p><p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据</li><li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code></li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题</li></ul><p>字符串对象的内部编码（<em>encoding</em>）有 3 种 ：<strong>int、raw和 embstr</strong></p><p><img src="/posts/27273/string.png" alt="string"></p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为<code>int</code></p><p><img src="/posts/27273/int.png" alt="img"></p><p>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式：</p><p><img src="/posts/27273/embstr.png" alt="img"></p><p>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code>：</p><p><img src="/posts/27273/raw.png" alt="img"></p><p>注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：</p><ul><li>redis 2.+ 是 32 字节</li><li>redis 3.0-4.0 是 39 字节</li><li>redis 5.0 是 44 字节</li></ul><p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处：</p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li><li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul><p>但是 embstr 也有缺点的：</p><ul><li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List（列表）是一种有序的字符串集合，它可以包含多个字符串元素，每个元素都有一个索引位置。Redis的List是一个双向链表结构，它支持在列表的两端进行插入和删除操作，因此可以用来实现队列（<em>Queue</em>）和栈（<em>Stack</em>）等数据结构</p><p>List 的主要特点和操作：</p><ol><li><p>有序集合：List 中的元素是有序的，每个元素都有一个整数索引，索引从0开始</p></li><li><p>双向链表：List 是一个双向链表，它允许在列表的两端进行插入和删除操作</p></li><li><p>常用操作：List 支持从头部和尾部插入元素（LPUSH、RPUSH命令），从头部和尾部弹出元素（LPOP、RPOP命令），以及获取指定索引位置的元素（LINDEX命令）等操作</p></li><li><p>获取范围元素：可以使用 LRANGE 命令获取列表中指定范围的元素，例如获取列表的前N个元素或后N个元素</p></li><li><p>元素重复：List 中的元素是可以重复的，它允许包含相同的字符串元素</p></li><li><p>阻塞操作：List 还支持阻塞式的弹出操作（BLPOP、BRPOP命令），如果列表为空，阻塞直到有元素可供弹出</p></li><li><p>可用作队列和栈：由于支持从两端插入和弹出操作，List可以用作队列（先进先出）或栈（先进后出）的数据结构</p></li></ol><p>List 是 Redis 中非常实用的数据类型之一，它广泛应用于消息队列、任务队列、实时数据处理等场景。在处理有序数据集合，并需要支持快速插入和删除操作时，List 是一个非常好的选择。Redis 提供了丰富的List操作命令，可以满足各种复杂的业务需求</p><h5 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h5><p>List 类型的底层数据结构是由<strong>双向链表</strong>或<strong>压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong></p><p>TODO</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash（哈希）是一种用于存储字段和值之间映射关系的数据结构。Hash 是一个键值对的集合，其中每个键对应一个字段（field），每个字段又对应一个值（value）。Redis 的 Hash 类型类似于字典或关联数组，它可以用来表示对象、实体或存储多个属性的数据</p><p>Hash类型主要特点和操作：</p><ol><li><p>哈希键（Hash Key）：Hash 类型使用一个键来标识和存储多个字段和对应的值。一个 Hash 键可以对应多个字段和值的映射关系</p></li><li><p>字段和值：在 Hash 中，每个字段都是一个唯一的字符串，而对应的值可以是字符串、整数、浮点数等数据类型</p></li><li><p>单个字段操作：Hash 支持对单个字段进行读取（HGET 命令）和设置（HSET 命令）操作</p></li><li><p>多字段操作：Hash 支持同时设置多个字段和值（HMSET 命令）以及同时获取多个字段的值（HMGET 命令）</p></li><li><p>自增和自减：可以对 Hash 中的某个字段进行自增和自减操作（HINCRBY 命令）</p></li><li><p>获取所有字段：可以使用 HKEYS 命令获取 Hash 中所有字段的名称</p></li><li><p>获取所有值：可以使用 HVALS 命令获取 Hash 中所有字段对应的值</p></li><li><p>获取所有字段和值：可以使用 HGETALL 命令获取 Hash 中所有字段和值的映射关系</p></li></ol><p>Hash 类型在 Redis 中非常实用，特别适用于存储和表示对象、实体或属性数据。它可以有效地将多个相关属性组织在一起，并且支持快速查找和访问。在需要存储和处理多个属性的数据时，Hash类型是一个很好的选择。在一些场景中，例如存储用户信息、缓存对象、存储商品信息等，Hash类型都可以提供便捷的数据组织和高效的查询性能</p><h5 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h5><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p><p>TODO</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set（集合）是一种无序且不重复的数据结构，它存储了一组唯一的元素。Set 类型类似于数学上的集合，它可以用来表示多个元素的集合，并且可以进行集合间的交集、并集、差集等操作</p><p>Set 类型的主要特点和操作：</p><ol><li><p>无序性：Set 中的元素是无序的，每个元素都是唯一的，不会出现重复的元素。</p></li><li><p>唯一性：Set 确保其中的每个元素都是唯一的，重复的元素将被自动去重。</p></li><li><p>添加元素：使用 SADD 命令可以向 Set 中添加一个或多个元素。</p></li><li><p>移除元素：使用 SREM 命令可以从 Set 中移除一个或多个元素。</p></li><li><p>获取所有元素：使用 SMEMBERS 命令可以获取 Set 中所有的元素。</p></li><li><p>随机获取元素：使用 SRANDMEMBER 命令可以随机获取 Set 中的一个或多个元素。</p></li><li><p>判断元素是否存在：使用 SISMEMBER 命令可以判断某个元素是否存在于 Set 中。</p></li><li><p>集合运算：Redis 还支持对多个 Set 进行集合运算，包括交集（SINTER）、并集（SUNION）和差集（SDIFF）等操作。</p></li></ol><p>Set 类型在 Redis 中非常实用，特别适用于存储一组唯一的元素，并且在元素的去重和查找方面具有高效性能。常见的应用场景包括社交网络关注关系、标签系统、统计不重复访问 IP 等。通过 Set 类型，可以快速地对多个元素进行去重、查找和集合运算，是实现这些功能的理想数据结构之一</p><h5 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h5><p>Set 类型的底层数据结构是由<strong>哈希表</strong>或<strong>整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构</li></ul><p>TODO</p><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h4><p>ZSet（有序集合，Sorted Set）是一种有序且不重复的数据结构，它与 Set 类型类似，都是存储一组唯一的元素。不同之处在于 ZSet 中的每个元素都会关联一个分数（score），通过分数来对元素进行排序，使得 ZSet 成为一个按照分数排序的集合</p><p>以下是 Redis 中 ZSet 类型的一些主要特点和操作：</p><ol><li><p>有序性：ZSet 中的元素是有序的，每个元素都关联一个分数，通过分数来对元素进行排序</p></li><li><p>唯一性：ZSet 确保其中的每个元素都是唯一的，不会出现重复的元素</p></li><li><p>添加元素：使用 ZADD 命令可以向 ZSet 中添加一个元素，并指定其对应的分数</p></li><li><p>获取元素：使用 ZRANGE 命令可以按照分数范围获取 ZSet 中的元素，也可以通过索引位置来获取指定位置的元素</p></li><li><p>获取分数：使用 ZSCORE 命令可以获取 ZSet 中指定元素的分数</p></li><li><p>移除元素：使用 ZREM 命令可以从 ZSet 中移除一个或多个元素</p></li><li><p>排序：ZSet 根据元素的分数进行排序，支持升序和降序两种排序方式</p></li><li><p>集合运算：Redis 还支持对多个 ZSet 进行集合运算，包括求交集（ZINTERSTORE）、求并集（ZUNIONSTORE）等操作</p></li></ol><p>ZSet 类型在 Redis 中非常实用，特别适用于需要按照分数进行排序的场景。常见的应用场景包括排行榜、计分系统、最新消息列表等。通过ZSet，可以高效地对元素按照分数排序，并且支持根据分数范围获取元素，以及进行集合运算。这使得ZSet成为了实现类似排行榜和计分系统的首选数据结构</p><h5 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h5><p>Zset 类型的底层数据结构是由<strong>压缩列表</strong>或<strong>跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p><p>TODO</p><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>Bitmap（位图）是一种特殊的数据结构，用于对大量的位（bit）进行高效的存储和操作。Bitmap 可以看作是由二进制位组成的一个数组，其中每个位可以表示某个对象的状态或标记</p><p>Bitmap 的特点和操作：</p><ol><li><p>存储二进制位：Bitmap 实际上是由二进制位组成的数组，每个位可以表示某个对象的状态，例如在线&#x2F;离线状态、签到记录等</p></li><li><p>压缩存储：由于 Bitmap 存储的数据通常具有稀疏性（大部分位为0），Redis 对 Bitmap 进行了优化，采用了紧凑的存储方式，减少了存储空间的占用</p></li><li><p>设置位：使用 SETBIT 命令可以设置指定位置上的二进制位的值为0或1</p></li><li><p>获取位：使用 GETBIT 命令可以获取指定位置上的二进制位的值</p></li><li><p>计数：使用 BITCOUNT 命令可以计算 Bitmap 中值为1的二进制位的个数</p></li><li><p>位运算：Redis 支持对多个 Bitmap 进行位运算，包括与（AND）、或（OR）、异或（XOR）等操作</p></li></ol><p>Bitmap 在 Redis 中可以非常高效地存储大量的位信息，并且支持快速的位设置和获取操作。常见的应用场景包括：</p><ul><li><p>在线&#x2F;离线状态记录：可以使用 Bitmap 记录用户的在线&#x2F;离线状态，每个用户用一个位来表示状态，1表示在线，0表示离线</p></li><li><p>签到记录：可以使用 Bitmap 记录用户的签到情况，每天用一个位来表示签到状态，1表示已签到，0表示未签到</p></li><li><p>统计用户活跃度：可以使用 Bitmap 统计用户在某段时间内的活跃度，每天用一个位来表示用户是否有活动，1表示有活动，0表示没有活动</p></li><li><p>浏览次数统计：可以使用 Bitmap 记录网页或文章的浏览次数，每次浏览用一个位来表示，1表示浏览过，0表示未浏览过</p></li></ul><p>Bitmap 在以上场景中都可以提供高效的存储和查询，同时占用较小的存储空间，是一种非常实用的数据结构</p><h5 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h5><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>HyperLogLog 是一种用于基数（<em>cardinality</em>）估算的概率性数据结构。基数是指集合中不重复元素的数量。HyperLogLog 通过使用非常少的内存来估算大规模集合的基数，它在计算基数时，占用的内存固定且非常小，而且估算的结果误差很小</p><p>HyperLogLog 的特点和操作如下：</p><ol><li><p>基数估算：HyperLogLog 用于估算大规模集合中不重复元素的数量，即基数</p></li><li><p>占用固定内存：HyperLogLog 使用的内存量是固定的，不会随着集合元素数量的增加而增加，因此它适用于处理大规模的数据</p></li><li><p>误差率可控：HyperLogLog 的计算结果是概率性的，可以通过调整内存分配来控制估算的误差率</p></li><li><p>不支持元素查询：HyperLogLog 不支持查询具体的元素，它只用于估算基数，无法获取集合中的具体元素</p></li><li><p>高性能：HyperLogLog 对于基数估算有着非常高的性能，估算结果可以在很短的时间内得到</p></li></ol><p>HyperLogLog 适用于一些需要估算大规模集合中不重复元素数量的场景，比如：</p><ul><li><p>统计网站的UV（独立访客数）：通过使用 HyperLogLog 估算用户的访问 IP 数量，可以估算出网站的独立访客数</p></li><li><p>统计活跃用户数：在大规模的用户行为日志中，使用 HyperLogLog 估算不同用户的数量，可以快速统计活跃用户数</p></li><li><p>去重：通过 HyperLogLog 可以对大规模的数据进行去重，找出不重复的元素</p></li></ul><p>需要注意的是，虽然 HyperLogLog 适用于估算大规模集合的基数，但是估算的结果并不是精确值，而是概率性的。根据实际应用场景，可以通过调整内存分配来控制估算的误差率，使得 HyperLogLog 在估算基数时达到较高的准确性和效率</p><h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>GEO（地理空间）类型是用于存储地理位置信息的数据结构。GEO 类型允许将地理位置（经度和纬度）与名称或标识符关联起来，同时支持对地理位置进行距离计算和地理位置范围查询</p><p>GEO 类型在Redis中是通过有序集合（Sorted Set）来实现的，每个成员（member）都有一个对应的经度和纬度值，成员在有序集合中的分数（score）用于保存地理位置的距离值，可以根据这个距离值进行排序</p><p>GEO 类型特点和操作：</p><ol><li><p>存储地理位置：使用 GEOADD 命令可以将地理位置（经度和纬度）与成员关联，并将其存储在有序集合中</p></li><li><p>获取地理位置：使用 GEOPOS 命令可以获取指定成员的地理位置（经度和纬度）</p></li><li><p>计算距离：使用 GEODIST 命令可以计算两个成员之间的地理位置距离</p></li><li><p>查询范围：使用 GEORADIUS 命令可以根据给定的地理位置和距离范围，查询在这个范围内的成员</p></li><li><p>查询范围并排序：使用 GEORADIUS 命令可以根据距离对查询结果进行排序</p></li><li><p>查询范围并限制数量：使用 GEORADIUS 命令可以对查询结果数量进行限制</p></li></ol><p>GEO 类型在 Redis 中非常实用，特别适用于存储和查询地理位置信息。常见的应用场景包括：</p><ul><li><p>附近的人或商家查询：可以根据用户的当前地理位置，查询附近的其他用户或商家</p></li><li><p>地理位置推荐：可以根据用户的地理位置信息，为其推荐附近的兴趣点、热门活动等</p></li><li><p>配送和距离计算：可以根据商家和用户的地理位置信息，计算配送距离，帮助选择最近的商家进行配送</p></li></ul><p>GEO 类型为应用程序提供了强大的地理位置处理能力，是处理地理位置信息的理想选择。通过 GEO 类型，可以高效地存储和查询地理位置信息，为地理位置相关的应用场景提供支持</p><h5 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h5><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求</p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Stream（流）类型是 Redis 5.0 版本中引入的一种新的数据结构，用于支持消息发布与订阅的高级数据类型。Stream 提供了一个持久化的日志数据结构，可以用于消息队列、事件发布订阅、日志记录等场景</p><p>Stream 类型特点和操作：</p><ol><li><p>消息的顺序和持久化：Stream 以日志形式持久化消息，每条消息都有一个全局唯一的 ID，保证了消息的顺序和不丢失</p></li><li><p>多个消费者：可以有多个消费者（消费者组）订阅同一个 Stream，并且每个消息只会被消费者组中的一个消费者处理，实现了消息的多播（message broadcasting）</p></li><li><p>消息确认：消费者在处理完消息后，可以向 Stream 发送确认（ACK）来表示消息已经被处理，这样消息会被从 Stream 中删除</p></li><li><p>消息超时：可以为每个消息设置过期时间，一旦消息过期，将会被自动删除</p></li><li><p>消息阻塞：消费者可以使用 XREAD 命令阻塞等待新消息到达 Stream，实现实时的订阅</p></li><li><p>消息范围查询：可以使用 XRANGE 命令查询 Stream 中的消息，支持按消息 ID 范围查询</p></li><li><p>消息消费者信息：可以使用 XINFO 命令查询 Stream 中的消费者信息，包括消费者组、待处理消息等</p></li></ol><p>Stream 类型在 Redis 中为实时消息传递和事件处理提供了一种可靠的解决方案。它可以用于构建消息队列、实现发布&#x2F;订阅模式，以及记录事件和日志等。通过 Stream，应用程序可以高效地处理和传递大量的实时数据，并支持多个消费者同时订阅和处理消息，是一个非常实用的数据结构</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 支持几种主要的持久化机制，分别是 <strong>RDB（<em>Redis Database File</em>）持久化</strong>，<strong>AOF（<em>Append-Only File</em>）持久化</strong>和 <strong>RDB + AOF 的混合持久化</strong>。这三种机制可以用来将内存中的数据持久化到磁盘，以确保在Redis 重启或宕机后数据不会丢失</p><ol><li><p><strong>RDB 持久化</strong>：</p><ul><li>RDB 持久化是将 Redis 的数据在某个时间点生成快照，保存到磁盘上的一个二进制文件中。这个文件以 <code>.rdb</code> 为后缀，因此通常被称为 RDB 文件。</li><li>RDB 持久化是通过 fork 子进程来实现的，子进程会复制父进程的内存数据，然后将数据写入到磁盘上的 RDB 文件中。这个过程称为 <em><strong>fork-on-save</strong></em></li><li>RDB 持久化的优点是生成的 RDB 文件非常紧凑，适用于备份和恢复数据，且对恢复速度较快。同时由于是快照机制，适用于设置不同的持久化频率，如定期持久化或手动触发持久化</li><li>缺点是在发生宕机时，可能会丢失最后一次持久化后的数据</li></ul></li><li><p><strong>AOF 持久化</strong>：</p><ul><li>AOF 持久化是将 Redis 的写操作以日志的形式追加到 AOF 文件中，这样可以保证数据的持久化和数据完整性</li><li>AOF 文件保存了所有对 Redis 进行修改的命令，因此可以通过重放 AOF 文件中的命令来恢复数据</li><li>AOF 持久化有两种策略：<em><strong>appendfsync always</strong></em> 和 <em><strong>appendfsync everysec</strong></em>。前者每次写入都会立即刷写到磁盘，保证数据的完整性，但可能影响性能；后者每秒刷写一次，牺牲一定的数据完整性来换取更好的性能</li><li>AOF 持久化的优点是对于写操作的数据完整性较好，即使发生宕机，只会丢失最后一次写入 AOF 文件的数据</li><li>缺点是 AOF 文件相对于 RDB 文件较大，恢复速度可能较慢</li></ul></li></ol><p>通常，可以根据应用的需求来选择适合的持久化机制。如果追求<strong>较好的数据完整性</strong>，可以选择AOF持久化；如果对于<strong>备份和恢复速度有较高要求</strong>，可以选择RDB持久化。有些情况下，也可以<strong>同时使用RDB和AOF持久化</strong>，以提供更可靠的数据保护</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB 中的核心思路是 <em><strong>Copy-on-Write</strong></em>，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面 Redis 主进程会 <strong>fork 一个新的快照进程</strong>专门来做这个事情，这样保证了 Redis 服务不会停止对客户端包括写请求在内的任何响应。另一方面<strong>这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域</strong>，待快照操作结束后才会同步到原来的内存区域</p><p>举个例子：</p><p>执行 bgsave 命令的时候，会通过 fork（）创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会<strong>复制父进程的页表</strong>，但是页表<strong>指向的物理内存还是一个</strong>，由于共享父进程的所有数据，可以直接读取主线程里的内存数据，并将数据写入到 RDB 文件。此时如果主线程执行<strong>读操作</strong>，则主线程和 bgsave 子进程<strong>互相不影响</strong>。如果主线程要<strong>修改共享数据里的某一块数据，就会发生写时复制，数据的物理内存就会被复制一份</strong>，主线程在这个数据副本进行修改操作。与此同时，子进程可以继续把原来的数据写入到 RDB 文件</p><p><img src="/posts/27273/redis-x-aof-42.jpg" alt="rdb"></p><h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><h6 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h6><blockquote><p>手动触发分别对应 save 和 bgsave 命令</p></blockquote><ul><li><p><strong>save 命令</strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</p></li><li><p><strong>bgsave 命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p><ul><li><p>具体流程如下：</p><ul><li><p>redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令</p></li><li><p>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回</p></li><li><p>如果不存在正在执行的子进程，那么就 fork 一个新的子进程进行持久化数据，fork 过程是阻塞的，fork 操作完成后主进程即可执行其他操作</p></li><li><p>子进程先将数据写入到临时的 rdb 文件中，待快照数据写入完成后再原子替换旧的 rdb 文件</p></li><li><p>同时发送信号给主进程，通知主进程 rdb 持久化完成，主进程更新相关的统计信息（info Persitence下的 rdb_* 相关选项）</p></li></ul></li></ul></li></ul><h6 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h6><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li>redis.conf 中配置 <code>save m n</code>，即在 m 秒内有 n 次修改时，自动触发 bgsave 生成 rdb 文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发 bgsave 操作，生成当时的快照发送到从节点；</li><li>执行 debug reload 命令重新加载 redis 时也会触发 bgsave 操作；</li><li>默认情况下执行 shutdown 命令时，如果没有开启 aof 持久化，那么也会触发 bgsave 操作；</li></ul><h5 id="RDB-配置"><a href="#RDB-配置" class="headerlink" title="RDB 配置"></a>RDB 配置</h5><blockquote><p>redis.conf</p></blockquote><p><strong>快照周期</strong>：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><ul><li><strong>Redis中默认的周期新设置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 周期性执行条件的设置格式为</span><br>save &lt;seconds&gt; &lt;changes&gt;<br><br><span class="hljs-comment"># 默认的设置为：</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><br><span class="hljs-comment"># 以下设置方式为关闭RDB快照功能</span><br>save <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照</li><li>如果300秒内有10条Key信息发生变化，则进行快照</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整</li><li><strong>其它相关配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件名称</span><br>dbfilename dump.rdb<br><br><span class="hljs-comment"># 文件保存路径</span><br><span class="hljs-built_in">dir</span> /home/work/app/redis/data/<br><br><span class="hljs-comment"># 如果持久化出错，主进程是否停止写入</span><br>stop-writes-on-bgsave-error <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 是否压缩</span><br>rdbcompression <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 导入时是否检查</span><br>rdbchecksum <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p><code>dbfilename</code>：RDB文件在磁盘上的名称</p><p><code>dir</code>：RDB文件的存储路径。默认设置为“.&#x2F;”，也就是Redis服务的主目录</p><p><code>stop-writes-on-bgsave-error</code>：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no</p><p><code>rdbcompression</code>：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”</p><p><code>rdbchecksum</code>：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><strong>优点</strong><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p><strong>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</strong></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p><strong>AOF</strong>（<em><strong>Append-Only File</strong></em>）是 Redis 持久化机制中的一种方式，用于将 Redis 的写操作以日志的形式追加到 AOF 文件中，保证数据的持久化和数据完整性。AOF持久化相较于RDB持久化更加可靠，因为它记录了每个写命令，可以完整地恢复Redis的状态</p><p>默认情况下 Redis 没有开启 AOF 方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的</p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code></p><p>AOF日志采用写后日志，即<strong>先写内存，后写日志</strong></p><p><img src="/posts/27273/redis-x-aof-41.jpg" alt="aof"></p><p><strong>为什么采用写后日志</strong></p><p>Redis要求高性能，采用写日志有两方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞</strong>当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li></ul><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>AOF 持久化功能的实现可以简单分为 5 步：</p><ol><li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中</li><li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘</li><li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化</li><li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复</li></ol><blockquote><p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p></blockquote><p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p><ul><li><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I&#x2F;O 缓冲区的状态。</li><li><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li></ul><p>AOF 工作流程图如下：</p><p><img src="/posts/27273/20191010084730557.png" alt="redis aof持久化详解"></p><h5 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h5><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p><ol><li><strong>appendfsync</strong> <em><strong>always</strong></em>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）</li><li><strong>appendfsync</strong> <em><strong>everysec</strong></em>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li><li><strong>appendfsync</strong> <em><strong>no</strong></em>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）</li></ol><p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong></p><p>为了兼顾数据和写入性能，可以考虑 <strong>appendfsync</strong> <em><strong>everysec</strong></em> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度</p><p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p><ul><li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个</li><li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个</li><li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除</li></ul><h5 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h5><p>因为 AOF 持久化是通过保存被执行的写命令来记录 Redis 状态的，所以随着 Redis 长时间运行，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 甚至宿主计算机造成影响</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写( rewrite) 功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的荣誉命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多</p><p><img src="/posts/27273/redis-x-aof-1.jpg" alt="aof rewrite"></p><p>如上图所示，重写前要记录名为<code>list</code>的键的状态，AOF 文件要保存五条命令，而重写后，则只需要保存一条命令</p><p>AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理</p><p>在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超过 REDIS_AOF_REWRITE_ITEMS_PER_CMD ( 一般为64 )常量，则使用多条命令记录该键的值，而不是一条命令</p><p>rewrite 的触发机制主要有一下三个：</p><ul><li>手动调用 bgrewriteaof 命令，如果当前有正在运行的 rewrite 子进程，则本次rewrite 会推迟执行，否则，直接触发一次 rewrite</li><li>通过配置指令手动开启 AOF 功能，如果没有 RDB 子进程的情况下，会触发一次 rewrite，将当前数据库中的数据写入 rewrite 文件</li><li>在 Redis 定时器中，如果有需要退出执行的 rewrite 并且没有正在运行的 RDB 或者 rewrite 子进程时，触发一次或者 AOF 文件大小已经到达配置的 rewrite 条件也会自动触发一次</li></ul><p>AOF 重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以 <strong>Redis 在子进程</strong>中执行 AOF 重写操作</p><ul><li>子进程进行 AOF 重写期间，Redis 进程可以继续处理客户端命令请求</li><li>子进程带有父进程的内存数据拷贝副本，在不适用锁的情况下，也可以保证数据的安全性</li></ul><p>但是，在子进程进行 AOF 重启期间，Redis接收客户端命令，会对现有数据库状态进行修改，从而导致数据当前状态和 重写后的 AOF 文件所保存的数据库状态不一致</p><p>为此，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区</p><p><img src="/posts/27273/redis-x-aof-2.jpg" alt="aof bgrewrite"></p><p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接收到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容写入到新的 AOF 文件中，保证新 AOF 文件保存的数据库状态和服务器当前状态一致</li><li>对新的 AOF 文件进行改名，原子地覆盖现有 AOF 文件，完成新旧文件的替换</li><li>继续处理客户端请求命令</li></ul><p><strong>在重写日志整个过程时，主线程有哪些地方会被阻塞</strong></p><ol><li>fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。</li><li>主进程有 bigkey 写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。</li><li>子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞</li></ol><h4 id="RDB-和-AOF-混合方式"><a href="#RDB-和-AOF-混合方式" class="headerlink" title="RDB 和 AOF 混合方式"></a>RDB 和 AOF 混合方式</h4><blockquote><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p></blockquote><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销</p><p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了</p><p><img src="/posts/27273/redis-x-rdb-4.jpg" alt="rdb &amp; aof mixed"></p><p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。</p><h4 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h4><blockquote><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p></blockquote><p>其实想要从这些文件中恢复数据，只需要重新启动 Redis 即可。我们还是通过图来了解这个流程：</p><p><img src="/posts/27273/redis-x-aof-5.png" alt="recover"></p><ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul><p>那么为什么会优先加载 AOF 呢？因为 AOF 保存的数据更完整，通过上面的分析我们知道 AOF 基本上最多损失 1s 的数据</p><h4 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h4><p>通过上面的分析，我们都知道 RDB 的快照、AOF 的重写都需要 fork，这是一个重量级操作，会对 Redis 造成阻塞。因此为了不影响 Redis 主进程响应，我们需要尽可能降低阻塞。</p><ul><li>降低 fork 的频率，比如可以手动来触发 RDB 生成快照、与 AOF 重写；</li><li>控制 Redis 最大使用内存，防止 fork 耗时过长；</li><li>使用更牛的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ul><p>在线上该怎么做？</p><ul><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>RDB持久化与AOF持久化可以同时存在，配合使用</li></ul><h4 id="RDB-与-AOF-比较"><a href="#RDB-与-AOF-比较" class="headerlink" title="RDB 与 AOF 比较"></a>RDB 与 AOF 比较</h4><p><strong>RDB 比 AOF 优秀的地方</strong>：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong>：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态</li></ul><p><strong>综上</strong>：</p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务</title>
    <link href="/posts/35975.html"/>
    <url>/posts/35975.html</url>
    
    <content type="html"><![CDATA[<p><strong>事务</strong>（Transaction）是数据库管理系统（DBMS）中的一个重要概念，用于确保数据库中数据的一致性、可靠性和完整性。它是由一系列数据库操作组成的逻辑单位，这些操作要么全部执行成功，要么全部不执行，不允许部分执行。如果事务中的任何操作失败，整个事务将回滚（Rollback）到最初的状态，就像没有执行过一样，保持数据的一致性</p><span id="more"></span><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>事务通常有以下四个标准特性，通常称为 <strong>ACID</strong> 特性：</p><ol><li><p><strong>原子性（Atomicity）</strong>：事务是原子的，要么全部执行，要么全部不执行。如果事务中的任何操作失败，整个事务将被回滚，保持数据库的一致性</p><blockquote><p>就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去</p></blockquote></li><li><p><strong>一致性（Consistency）</strong>：事务开始之前和结束之后，数据库的状态应该保持一致。这意味着事务的执行不会破坏数据库的完整性约束，如唯一性、外键约束等</p><blockquote><p>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）</p></blockquote></li><li><p><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的</p><blockquote><p>也就是说，消费者购买商品这个事务，是不影响其他消费者购买的</p></blockquote></li><li><p><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，即使发生系统故障或崩溃，也不会丢失提交的数据</p></li></ol><blockquote><p><strong>先写在前面</strong></p><p> InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的</li><li>原子性是通过 undo log（回滚日志） 来保证的</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的</li><li>一致性则是通过持久性 + 原子性 + 隔离性来保证</li></ul></blockquote><h4 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h4><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况</p><p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong></p><p><strong>脏读</strong>：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读</p><p><strong>不可重复读</strong>：对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新操作</p><p><strong>幻读</strong>：幻读是针对数据插入操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，让用户感觉感觉出现了幻觉，这就叫幻读</p><blockquote><p><strong>可重复读</strong>：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的</p></blockquote><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>事务的隔离级别是数据库管理系统中用于<strong>控制多个并发事务之间相互影响程度</strong>的一种机制。由于数据库系统常常有多个用户同时访问和修改数据，为了保证事务的隔离性和数据的一致性，引入了不同的隔离级别。数据库管理系统通常支持以下四个标准的隔离级别：</p><ol><li><p><strong>读未提交（Read Uncommitted）</strong>：这是最低的隔离级别。在该级别下，一个事务可以读取到另一个事务尚未提交的修改。这可能导致脏读（<em>Dirty Read</em>），即读取到未经确认的数据，可能是无效的数据</p></li><li><p><strong>读提交（Read Committed）</strong>：在该级别下，一个事务只能读取到已经提交的数据。这避免了脏读，但可能会导致不可重复读（<em>Non-repeatable Read</em>）。不可重复读指的是，在同一个事务中，由于其他事务的修改，同一数据行的值可能会发生变化</p></li><li><p><strong>可重复读（Repeatable Read）</strong>：在该级别下，一个事务在执行期间多次读取同一数据，将看到一致的结果。其他事务修改数据时，不会影响当前事务的读取结果。但是，仍然可能发生幻读（<em>Phantom Read</em>）。幻读指的是在同一个事务中，由于其他事务插入新数据，导致之前的查询结果发生变化</p></li><li><p><strong>串行化（Serializable）</strong>：这是最高的隔离级别。在该级别下，所有事务按照顺序逐个执行，相当于将并发执行转换为串行执行。这样可以避免脏读、不可重复读和幻读，但并发性能会受到极大影响，通常只在特殊情况下使用</p></li></ol><p>需要注意的是，隔离级别越高，事务的隔离性越好，但并发性能也会降低。因此，在选择隔离级别时，需要根据具体应用场景的要求进行权衡</p><p><strong>不同的事务隔离级别下会有不同的现象</strong></p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题</li></ul><h4 id="并发事务控制"><a href="#并发事务控制" class="headerlink" title="并发事务控制"></a>并发事务控制</h4><ul><li><strong>读-读</strong>：即并发事务相继读取同一记录</li><li><strong>写-写</strong>：即并发事务相继对同一记录做出修改</li><li><strong>写-读</strong>或<strong>读-写</strong>：即两个并发事务对同一记录分别进行读操作和写操作</li></ul><h5 id="读-读"><a href="#读-读" class="headerlink" title="读-读"></a>读-读</h5><p>因为读取记录并不会对记录造成任何影响，所以同个事务并发读取同一记录也就不存在任何安全问题，所以允许这种操作。</p><h5 id="写-写"><a href="#写-写" class="headerlink" title="写-写"></a>写-写</h5><p>如果允许并发事务都读取同一记录，并相继基于旧值对这一记录做出修改，那么就会出现前一个事务所做的修改被后面事务的修改覆盖，即出现<strong>提交覆盖</strong>的问题。</p><p>另外一种情况，并发事务相继对同一记录做出修改，其中一个事务提交之后之后另一个事务发生回滚，这样就会出现已提交的修改因为回滚而丢失的问题，即<strong>回滚覆盖</strong>问题。</p><p>这两种问题都造成丢失更新，其中回滚覆盖称为<strong>第一类丢失更新</strong>问题，提交覆盖称为<strong>第二类丢失更新</strong>问题</p><h5 id="写-读或读-写"><a href="#写-读或读-写" class="headerlink" title="写-读或读-写"></a><strong>写-读</strong>或<strong>读-写</strong></h5><p>这种情况较为复杂，也最容易出现问题</p><p>如果一个事务读取了另一个事务尚未提交的修改记录，那么就出现了<strong>脏读</strong>的问题；</p><p>如果我们加以控制使得一个事务只能读取其他已提交事务的修改的数据，那么这个事务在另一事物提交修改前后读取到的数据是不一样的，这就意味着发生了<strong>不可重复读</strong>；</p><p>如果一个事务根据一些条件查询到一些记录，之后另一事物向表中插入了一些记录，原先的事务以相同条件再次查询时发现得到的结果跟第一次查询得到的结果不一致，这就意味着发生了<strong>幻读</strong>。</p><h4 id="传统隔离级别的实现"><a href="#传统隔离级别的实现" class="headerlink" title="传统隔离级别的实现"></a>传统隔离级别的实现</h4><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li>共享锁（<code>Shared Locks</code>）：简称 <strong>S锁</strong>，事务对一条记录进行读操作时，需要先获取该记录的共享锁</li><li>排他锁（<code>Exclusive Locks</code>）：简称 <strong>X锁</strong>，事务对一条记录进行写操作时，需要先获取该记录的排他锁</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁 (table-level locking)</strong> 和 <strong>行级锁 (row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</p><p>在<strong>基于锁</strong>的实现方式下，四种隔离级别的区别就在于加锁方式的区别：</p><ul><li><strong>读未提交</strong>：读操作不加锁，读读，读写，写读并行；写操作加<code>X锁</code>且直到事务提交后才释放</li><li><strong>读已提交</strong>：读操作加<code>S锁</code>，写操作加<code>X锁</code>且直到事务提交后才释放；读操作不会阻塞其他事务读或写，写操作会阻塞其他事务写和读，因此可以防止脏读问题</li><li><strong>可重复读</strong>：读操作加<code>S锁</code>且直到事务提交后才释放，写操作加<code>X锁</code>且直到事务提交后才释放；读操作不会阻塞其他事务读但会阻塞其他事务写，写操作会阻塞其他事务读和写，因此可以防止脏读、不可重复读</li><li><strong>串行化</strong>：读操作和写操作都加<code>X锁</code>且直到事务提交后才释放，粒度为表锁，也就是严格串行</li></ul><blockquote><p><strong>值得注意的点</strong></p><ul><li>如果锁获取之后直到事务提交后才释放，这种锁称为<strong>长锁</strong>；如果锁在操作完成之后就被释放，这种锁称为<strong>短锁</strong>。例如，在读已提交隔离级别下，读操作所加<code>S锁</code>为短锁，写操作所加<code>X锁</code>为长锁。</li><li>对于可重复读和串行化隔离级别，读操作所加<code>S锁</code>和写操作所加<code>X锁</code>均为长锁，即事务获取锁之后直到事务提交后才能释放，这种把获取锁和释放锁分为两个不同的阶段的协议称为<strong>两阶段锁</strong>协议（<code>2-phase locking</code>）。两阶段锁协议规定在加锁阶段，一个事务可以获得锁但是不能释放锁；而在解锁阶段事务只可以释放锁，并不能获得新的锁。两阶段锁协议能够保证事务串行化执行，解决事务并发问题，但也会导致死锁发生的概率大大提升</li></ul></blockquote><h4 id="MySQL-innodb隔离级别的实现"><a href="#MySQL-innodb隔离级别的实现" class="headerlink" title="MySQL innodb隔离级别的实现"></a>MySQL innodb隔离级别的实现</h4><p>不同数据库对于 <code>SQL</code> 标准中规定的隔离级别支持是不一样的，数据库引擎实现隔离级别的方式虽然都在尽可能地贴近标准的隔离级别规范，但和标准的预期还是有些不一样的地方。</p><p>MySQL（<strong>innodb</strong>）支持的4种隔离级别，与标准的各级隔离级别允许出现的问题有些出入，比如<code>MySQL</code>在可重复读隔离级别下可以防止幻读的问题出现，但也会出现提交覆盖的问题</p><p>相对于传统隔离级别基于锁的实现方式，<code>MySQL</code> 是通过<code>MVCC</code>（多版本并发控制）来实现读-写并发控制，又是通过两阶段锁来实现写-写并发控制的。<code>MVCC</code>是一种无锁方案，用以解决事务<strong>读-写</strong>并发的问题，能够极大提升<strong>读-写</strong>并发操作的性能</p><h5 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h5><p>为了方便描述，首先我们创建一个表 <code>book</code>，就三个字段，分别是主键 <code>book_id</code>, 名称 <code>book_name</code>, 库存 <code>stock</code>。然后向表中插入一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;数据结构&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;C++指南&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;精通Java&#x27;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h6 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h6><p>对于使用 <code>InnoDB</code> 存储引擎的表，其聚簇索引记录中包含了两个重要的隐藏列：</p><ul><li>事务ID（<code>DB_TRX_ID</code>）：每当事务对聚簇索引中的记录进行修改时，都会把当前事务的事务id记录到 <code>DB_TRX_ID</code> 中</li><li>回滚指针（<code>DB_ROLL_PTR</code>）：每当事务对聚簇索引中的记录进行修改时，都会把该记录的旧版本记录到 <code>undo</code> 日志中，通过 <code>DB_ROLL_PTR</code> 这个指针可以用来获取该记录旧版本的信息</li></ul><p>如果在一个事务中多次对记录进行修改，则每次修改都会生成 <code>undo</code> 日志，并且这些 <code>undo</code> 日志通过 <code>DB_ROLL_PTR</code> 指针串联成一个版本链，版本链的头结点是该记录最新的值，尾结点是事务开始时的初始值</p><p>例如，我们在表 <code>book</code> 中做以下修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">300</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>那么 <code>id=1</code> 的记录此时的版本链就如下图所示：</p><p><img src="/posts/35975/mysql-concurrency-control-1.png" alt="img"></p><h6 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h6><p>对于使用 <code>Read Uncommitted</code> 隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；对于使用 <code>Serializable</code> 隔离级别的事务来说，<code>InnoDB</code> 使用加锁的方式来访问记录。而 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下，版本链中哪个版本是能被当前事务读取的。于是 <code>ReadView</code> 的概念被提出以解决这个问题</p><p><code>ReadView</code> 相当于某个时刻表记录的一个快照，在这个快照中我们能获取到与当前记录相关的事务中，哪些事务是已提交的<strong>稳定事务</strong>，哪些是<strong>正在活跃的事务</strong>，哪些是<strong>生成快照之后才开启的事务</strong>。由此我们就能根据<strong>可见性比较算法</strong>判断出版本链中能被读取的最新版本记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadView</span> &#123;</span><br>  <span class="hljs-comment">/* ... */</span><br>private:<br>  <span class="hljs-type">trx_id_t</span> m_low_limit_id;      <span class="hljs-comment">/* 大于等于这个 ID 的事务均不可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_up_limit_id;       <span class="hljs-comment">/* 小于这个 ID 的事务均可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_creator_trx_id;    <span class="hljs-comment">/* 创建该 Read View 的事务ID */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_low_limit_no;      <span class="hljs-comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span><br><br>  <span class="hljs-type">ids_t</span> m_ids;                  <span class="hljs-comment">/* 创建 Read View 时的活跃事务列表 */</span><br><br>  m_closed;                     <span class="hljs-comment">/* 标记 Read View 是否 close */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可见性比较算法</strong>是基于事务ID的比较算法。首先我们需要知道的一个事实是：<strong>事务 <code>id</code> 是递增分配的</strong>。从 <code>ReadView</code> 中我们能获取到生成快照时刻系统中活跃的事务中最小和最大的事务 <code>id</code>（最大的事务<code>id</code>实际上是系统中将要分配给下一个事务的 <code>id</code> 值），这样我们就得到了一个活跃事务 <code>id</code> 的范围，我们可称之为 <code>ACTIVE_TRX_ID_RANGE</code>。那么小于这个范围的事务id对应的事务都是已提交的稳定事务，大于这个范围的事务都是在快照生成之后才开启的事务，而在 <code>ACTIVE_TRX_ID_RANGE</code> 范围内的事务中除了正在活跃的事务，也都是已提交的稳定事务</p><p>有了以上信息之后，我们顺着版本链从头结点开始查找最新的可被读取的版本记录：</p><p>1、首先判断版本记录的 <code>DB_TRX_ID</code> 字段与生成 <code>ReadView</code> 的事务对应的事务ID是否相等。如果相等，那就说明该版本的记录是在当前事务中生成的，自然也就能够被当前事务读取；否则进行第2步</p><p>2、如果版本记录的 <code>DB_TRX_ID</code> 字段小于范围 <code>ACTIVE_TRX_ID_RANGE</code>，表明该版本记录是已提交事务修改的记录，即对当前事务可见；否则进行下一步</p><p>3、如果版本记录的 <code>DB_TRX_ID</code> 字段位于范围 <code>ACTIVE_TRX_ID_RANGE</code> 内，如果该事务ID对应的不是活跃事务，表明该版本记录是已提交事务修改的记录，即对当前事务可见；如果该事务ID对应的是活跃事务，那么对当前事务不可见，则读取版本链中下一个版本记录，重复以上步骤，直到找到对当前事务可见的版本</p><p>如果某个版本记录经过以上步骤判断确定其对当前事务可见，则查询结果返回此版本记录；否则读取下一个版本记录继续按照上述步骤进行判断，直到版本链的尾结点。如果遍历完版本链没有找到对当前事务可见的版本，则查询结果为空</p><p>在 <code>MySQL</code> 中，<code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下的区别就是它们<strong>生成 <code>ReadView</code> 的时机不同</strong></p><h5 id="MVCC实现不同隔离级别"><a href="#MVCC实现不同隔离级别" class="headerlink" title="MVCC实现不同隔离级别"></a>MVCC实现不同隔离级别</h5><p>之前说到 <code>ReadView</code> 的机制只在 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下生效，所以只有这两种隔离级别才有 <strong>MVCC</strong>。<br>在 <code>Read Committed</code> 隔离级别下，每次读取数据时都会生成 <code>ReadView</code>；而在 <code>Repeatable Read</code> 隔离级别下只会在事务首次读取数据时生成 <code>ReadView</code>，之后的读操作都会沿用此 <code>ReadView</code>。</p><p>下面我们通过例子来看看 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下 <strong>MVCC</strong> 的不同表现。我们继续以表 <code>book</code> 为例进行演示。</p><h6 id="Read-Committed-隔离级别分析"><a href="#Read-Committed-隔离级别分析" class="headerlink" title="Read Committed 隔离级别分析"></a>Read Committed 隔离级别分析</h6><p>假设在 <code>Read Committed</code> 隔离级别下，有如下事务在执行，事务 <code>id</code> 为10：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">10</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">300</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>此时该事务尚未提交，<code>id</code>为2的记录版本链如下图所示：</p><p><img src="/posts/35975/mysql-concurrency-control-2.png" alt="img"></p><p>然后我们开启一个事务对<code>id</code>为2的记录进行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>当执行 <code>SELECT</code> 语句时会生成一个 <code>ReadView</code>，该 <code>ReadView</code> 中的 <code>ACTIVE_TRX_ID_RANGE</code> 为 <code>[10, 11)</code>，当前事务ID <code>creator_trx_id</code> 为<code>0</code>（因为事务中当执行写操作时才会分配一个单独的事务 <code>id</code>，否则事务<code>id</code>为<code>0</code>）。按照我们之前所述 <code>ReadView</code> 的工作原理，我们查询到的版本记录为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span>-----------<span class="hljs-code">+-------+</span><br><span class="hljs-section">| book_id  | book_name | stock |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br><span class="hljs-section">| 2        | C++指南    |  100  |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br></code></pre></td></tr></table></figure><p>然后我们将事务<code>id</code>为10的事务提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">10</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">300</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>同时开启执行另一事务<code>id</code>为<code>11</code>的事务，但不提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">11</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">400</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>此时<code>id</code>为2的记录版本链如下图所示：</p><p><img src="/posts/35975/mysql-concurrency-control-3.png" alt="img"></p><p>然后我们回到刚才的查询事务中再次查询<code>id</code>为2的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 此时Transaction <span class="hljs-number">10</span> 未提交<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 此时Transaction <span class="hljs-number">10</span> 已提交<br></code></pre></td></tr></table></figure><p>当第二次执行 <code>SELECT</code> 语句时会再次生成一个 <code>ReadView</code>，该 <code>ReadView</code> 中的 <code>ACTIVE_TRX_ID_RANGE</code> 为<code>[11, 12)</code>，当前事务ID <code>creator_trx_id</code> 依然为<code>0</code>。按照 <code>ReadView</code> 的工作原理进行分析，我们查询到的版本记录为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span>-----------<span class="hljs-code">+-------+</span><br><span class="hljs-section">| book_id  | book_name | stock |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br><span class="hljs-section">| 2        | C++指南    | 300   |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br></code></pre></td></tr></table></figure><p>从上述分析可以发现，因为每次执行查询语句都会生成新的 <code>ReadView</code>，所以在 <code>Read Committed</code> 隔离级别下的事务读取到的是查询时刻表中已提交事务修改之后的数据。</p><h6 id="Repeatable-Read隔离级别分析"><a href="#Repeatable-Read隔离级别分析" class="headerlink" title="Repeatable Read隔离级别分析"></a>Repeatable Read隔离级别分析</h6><p>我们在 <code>Repeatable Read</code> 隔离级别下重复上面的事务操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">20</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">300</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>此时该事务尚未提交，然后我们开启一个事务对<code>id</code>为2的记录进行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>当事务第一次执行 <code>SELECT</code> 语句时会生成一个 <code>ReadView</code>，该 <code>ReadView</code> 中的 <code>ACTIVE_TRX_ID_RANGE</code> 为 <code>[10, 11)</code> ，当前事务ID <code>creator_trx_id</code> 为<code>0</code>。根据 <code>ReadView</code> 的工作原理，我们查询到的版本记录为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span>-----------<span class="hljs-code">+-------+</span><br><span class="hljs-section">| book_id  | book_name | stock |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br><span class="hljs-section">| 2        | C++指南    |  100  |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br></code></pre></td></tr></table></figure><p>然后我们将事务 <code>id</code> 为20的事务提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">20</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">300</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>同时开启执行另一事务<code>id</code>为21的事务，但不提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 开启Transaction <span class="hljs-number">21</span><br><br><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">400</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>然后我们回到刚才的查询事务中再次查询<code>id</code>为2的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 此时Transaction <span class="hljs-number">10</span> 未提交<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 此时Transaction <span class="hljs-number">10</span> 已提交<br></code></pre></td></tr></table></figure><p>当第二次执行 <code>SELECT</code> 语句时不会生成新的 <code>ReadView</code>，依然会使用第一次查询时生成 <code>ReadView</code>。因此我们查询到的版本记录跟第一次查询到的结果是一样的：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span>-----------<span class="hljs-code">+-------+</span><br><span class="hljs-section">| book_id  | book_name | stock |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br><span class="hljs-section">| 2        | C++指南    |  100  |</span><br><span class="hljs-section">+----------+-----------+-------+</span><br></code></pre></td></tr></table></figure><p>从上述分析可以发现，因为在 <code>Repeatable Read</code> 隔离级别下的事务只会在第一次执行查询时生成 <code>ReadView</code>，该事务中后续的查询操作都会沿用这个 <code>ReadView</code>，因此此隔离级别下一个事务中多次执行同样的查询，其结果都是一样的，这样就实现了可重复读。</p><h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h5><h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h6><p>在 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下，普通的 <code>SELECT</code> 查询都是读取 <code>MVCC</code> 版本链中的一个版本，相当于读取一个快照，因此称为<strong>快照读</strong>。这种读取方式不会加锁，因此读操作时非阻塞的，因此也叫<strong>非阻塞读</strong>。</p><p>在标准的 <code>Repeatable Read</code> 隔离级别下读操作会加 <code>S锁</code>，直到事务结束，因此可以阻止其他事务的写操作；但在 <code>MySQL</code> 的 <code>Repeatable Read</code> 隔离级别下读操作没有加锁，不会阻止其他事务对相同记录的写操作，因此在后续进行写操作时就有可能写入基于版本链中的旧数据计算得到的结果，这就导致了提交覆盖的问题。想要避免此问题，就需要另外加锁来实现。</p><h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h6><p>之前提到 <code>MySQL</code> 有两种锁定读的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 读取时对记录加S锁，直到事务结束<br><br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 读取时对记录加X锁，直到事务结束<br></code></pre></td></tr></table></figure><p>这种读取方式读取的是记录的当前最新版本，称为<strong>当前读</strong>。另外对于<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>操作，也是需要先读取记录，获取记录的<code>X锁</code>，这个过程也是一个当前读。由于需要对记录进行加锁，会阻塞其他事务的写操作，因此也叫<strong>加锁读</strong>或<strong>阻塞读</strong>。</p><p>当前读不仅会对当前记录加<strong>行记录锁</strong>，还会对查询范围空间的数据加<strong>间隙锁</strong>（<code>GAP LOCK</code>），因此可以<strong>阻止幻读</strong>问题的出现</p><h5 id="快照读是如何避免幻读的？"><a href="#快照读是如何避免幻读的？" class="headerlink" title="快照读是如何避免幻读的？"></a>快照读是如何避免幻读的？</h5><p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p><p>做个实验，数据库表 t_stu 如下，其中 id 为主键。</p><p><img src="/posts/35975/7f9df142b3594daeaaca495abb7133f5.png" alt="img"></p><p>然后在可重复读隔离级别下，有两个事务的执行顺序如下：</p><p><img src="/posts/35975/e576e047dccc47d5a59636ea342750b8.png" alt="在这里插入图片描述"></p><p>从这个实验结果可以看到，即使事务 B 中途插入了一条记录，事务 A 前后两次查询的结果集都是一样的，并没有出现所谓的幻读现象。</p><h5 id="当前读是如何避免幻读的？"><a href="#当前读是如何避免幻读的？" class="headerlink" title="当前读是如何避免幻读的？"></a>当前读是如何避免幻读的？</h5><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p><p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p>接下来，我们假设<code>select ... for update</code>当前读是不会加锁的（实际上是会加锁的），在做一遍实验。</p><p><img src="/posts/35975/1f872ff92b644b5f81cee2dd9188b199.png" alt="img"></p><p>这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读</p><p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁</strong></p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p><img src="/gap%E9%94%81.drawio.png" alt="img"></p><p>举个具体例子，场景如下：</p><p><img src="/posts/35975/3af285a8e70f4d4198318057eb955520.png" alt="img"></p><p>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 <strong>next-key lock</strong>（next-key lock 是间隙锁+记录锁的组合）</p><p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象</p><h5 id="幻读被完全解决了吗？"><a href="#幻读被完全解决了吗？" class="headerlink" title="幻读被完全解决了吗？"></a>幻读被完全解决了吗？</h5><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p><p>我举例一个可重复读隔离级别发生幻读现象的场景。</p><h6 id="第一个发生幻读现象的场景"><a href="#第一个发生幻读现象的场景" class="headerlink" title="第一个发生幻读现象的场景"></a>第一个发生幻读现象的场景</h6><p>还是以这张表作为例子：</p><p><img src="/posts/35975/7f9df142b3594daeaaca495abb7133f5-20230309222119359.png" alt="img"></p><p>事务 A 执行查询 id &#x3D; 5 的记录，此时表中是没有该记录的，所以查询不出来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 事务 A<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_stu <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>然后事务 B 插入一条 id &#x3D; 5 的记录，并且提交了事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 事务 B<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_stu <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;小美&#x27;</span>, <span class="hljs-number">18</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">commit</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>此时，<strong>事务 A 更新 id &#x3D; 5 这条记录，对没错，事务 A 看不到 id &#x3D; 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id &#x3D; 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 事务 A<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">update</span> t_stu <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小林coding&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.01</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_stu <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> age  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> 小林coding   <span class="hljs-operator">|</span>   <span class="hljs-number">18</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>整个发生幻读的时序图如下：</p><p><img src="/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h6 id="第二个发生幻读现象的场景"><a href="#第二个发生幻读现象的场景" class="headerlink" title="第二个发生幻读现象的场景"></a>第二个发生幻读现象的场景</h6><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>MySQL</strong> <strong>InnoDB</strong> 引擎的<strong>可重复读</strong>隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读</li><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读</li></ul><p>我举例了两个发生幻读场景的例子。</p><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读</p><p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生</strong></p><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
      <category>Transaction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>Transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/posts/64800.html"/>
    <url>/posts/64800.html</url>
    
    <content type="html"><![CDATA[<p><strong>MySQL</strong>（官方发音为<a href="https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99">&#x2F;maɪ ˌɛskjuːˈɛl&#x2F;</a> “My S-Q-L”，但也经常被读作 <a href="https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99">&#x2F;maɪ ˈsiːkwəl&#x2F;</a> “My Sequel”）是一种开源的关系型数据库管理系统(RDBMS)，由瑞典公司MySQL AB开发。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。MySQL 在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在 Internet 上的中小型网站中</p><span id="more"></span><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库是一种使用<strong>关系模型</strong>（也称为表格模型）来组织和存储数据的数据库管理系统。它是一种基于关系的数据结构，使用表格来表示和存储数据，其中每个表格被称为一个”关系”，每个关系由行和列组成。每一行表示一个数据记录，每一列表示一个属性（也称为字段或属性）</p><p>关系型数据库通过使用结构化查询语言(<strong>SQL</strong>)来处理对数据的操作。SQL是一种标准化的查询语言，用于定义、管理和操作关系型数据库中的数据。SQL提供了各种操作，包括插入（INSERT）、查询（SELECT）、更新（UPDATE）、删除（DELETE）等，以及用于创建和修改表格结构的命令（如CREATE TABLE、ALTER TABLE等）</p><p>关系型数据库具有以下特点：</p><ol><li><p><strong>表格结构</strong>：数据<strong>以表格形式存储，每个表格由行和列组成</strong>。每一行代表一个数据记录，每一列代表一个属性。</p></li><li><p><strong>主键</strong>：每个表格通常都会定义一个主键，<strong>用于唯一标识表格中的每一行</strong>。主键确保数据的唯一性和完整性。</p></li><li><p><strong>外键</strong>：关系型数据库<strong>支持外键约束，用于建立表格之间的关系</strong>。外键是另一个表格的主键，它用来确保数据之间的关联性。</p></li><li><p><strong>数据完整性</strong>：关系型数据库通过<strong>各种约束（如唯一约束、非空约束等）来保持数据的完整性</strong>，防止数据不一致或无效的情况。</p></li><li><p><strong>数据查询</strong>：通过SQL查询语言，可以方便地执行各种复杂的数据查询和操作，包括数据的筛选、排序、聚合等。</p></li><li><p><strong>数据安全性</strong>：关系型数据库提供用户权限管理，管理员可以控制用户对数据库和表格的访问权限，确保数据的安全性。</p></li><li><p><strong>事务支持</strong>：关系型数据库支持事务处理，确保数据库操作的<strong>原子性、一致性、隔离性和持久性</strong>（ACID特性）。</p></li></ol><p>一些著名的关系型数据库管理系统包括MySQL、Oracle、Microsoft SQL Server、PostgreSQL等。这些数据库系统被广泛用于各种应用场景，从个人项目到大型企业应用，关系型数据库一直是最常见和重要的数据存储解决方案之一</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL 是一种结构化查询语言 ( <em>Structured Query Language</em> )，是一种用于管理和操作关系型数据库的标准化查询语言。它是一种声明性的语言，用于定义、管理和操作数据库中的数据。SQL允许用户通过简单的命令来执行各种操作，如<strong>插入、查询、更新、删除</strong>等，以及管理数据库的结构，例如创建和修改表格、索引等</p><p>SQL 的一些主要特点和用途包括：</p><ol><li><p><strong>数据查询</strong>：通过SQL，用户可以从数据库中查询数据。最常见的查询是使用SELECT语句来检索特定的数据行或列。</p></li><li><p><strong>数据插入、更新和删除</strong>：SQL允许用户使用INSERT、UPDATE和DELETE语句来向数据库中插入、修改和删除数据。</p></li><li><p><strong>数据定义</strong>：用户可以使用SQL的CREATE、ALTER和DROP语句来定义数据库、表格、索引和其他数据库对象的结构。</p></li><li><p><strong>数据完整性</strong>：SQL支持约束（如PRIMARY KEY、UNIQUE、NOT NULL等）来保持数据的完整性和一致性。</p></li><li><p><strong>数据管理</strong>：通过SQL，用户可以管理数据库用户、角色和权限，控制数据的访问和安全性。</p></li><li><p><strong>数据聚合</strong>：SQL支持用于对数据进行聚合和计算的函数，如SUM、COUNT、AVG、MAX、MIN等。</p></li></ol><p>SQL的基本语法通常包括以下几个部分：</p><ul><li>SELECT：用于查询数据。</li><li>FROM：指定要查询的表格。</li><li>WHERE：可选部分，用于筛选特定的数据行。</li><li>INSERT INTO：用于向表格中插入数据。</li><li>UPDATE：用于更新表格中的数据。</li><li>DELETE FROM：用于从表格中删除数据。</li><li>CREATE TABLE：用于创建新表格。</li><li>ALTER TABLE：用于修改现有表格的结构。</li><li>DROP TABLE：用于删除表格。</li></ul><p>SQL是一种强大且灵活的查询语言，它在关系型数据库管理中扮演着核心角色，使用户可以轻松地进行数据管理和操作。无论是简单的数据库查询还是复杂的数据处理，SQL都是数据库开发和管理中不可或缺的工具</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul><li>数值类型：<ul><li>INT：用于存储整数，可以指定整数的范围，如 <code>INT(10)</code></li><li>TINYINT：用于存储范围较小的整数，如 <code>TINYINT(4)</code></li><li>BIGINT：用于存储大整数，如 <code>BIGINT(20)</code></li><li>DECIMAL：用于存储高精度的小数，可以指定小数位数，如 <code>DECIMAL(10, 2)</code></li><li>FLOAT：用于存储单精度浮点数</li><li>DOUBLE：用于存储双精度浮点数</li></ul></li></ul><ol start="2"><li><p>字符串类型：</p><ul><li>CHAR：固定长度字符串，指定最大长度，如 <code>CHAR(50)</code></li><li>VARCHAR：可变长度字符串，指定最大长度，如 <code>VARCHAR(255)</code></li><li>TEXT：用于存储大文本数据，如文章内容</li><li>ENUM：用于定义枚举类型，可从预定义的选项中选择一个值</li></ul></li><li><p>日期和时间类型：</p><ul><li>DATETIME：用于存储日期和时间，格式为 <code>&#39;YYYY-MM-DD HH:MM:SS&#39;</code></li><li>TIMESTAMP：用于存储时间戳，通常用于记录数据的创建或修改时间</li></ul></li><li><p>布尔类型：</p><ul><li>BOOL 或 BOOLEAN：用于存储布尔值，可以取值为 <code>TRUE/FALSE</code> 或 <code>1/0</code></li></ul></li><li><p>二进制类型：</p><ul><li>BLOB：用于存储二进制大对象，如图像、视频等</li><li>BINARY：固定长度的二进制数据</li><li>VARBINARY：可变长度的二进制数据</li></ul></li><li><p>其他类型：</p><ul><li>JSON：用于存储 <code>JSON</code> 格式的数据</li></ul></li></ol><h5 id="VARCHAR-和-CHAR"><a href="#VARCHAR-和-CHAR" class="headerlink" title="VARCHAR 和 CHAR"></a>VARCHAR 和 CHAR</h5><p>VARCHAR 是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内</p><p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储</p><p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理</p><p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等</p><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符</p><h5 id="VARCHAR-10-和-VARCHAR-200"><a href="#VARCHAR-10-和-VARCHAR-200" class="headerlink" title="VARCHAR(10) 和 VARCHAR(200)"></a>VARCHAR(10) 和 VARCHAR(200)</h5><blockquote><p>使用VARCHAR(10)和VARCHAR(200)存储”hello”的空间开销是一样的。那么使用更短的列有什么优势吗？</p></blockquote><p>VARCHAR(10) 和 VARCHAR(200) 都是变长类型，表示能存储最多 10 个字符和 200 个字符。因此，VARCHAR(200) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10) 存储超过 10 个字符时，就需要修改表结构才可以</p><p>虽说 VARCHAR(10) 和 VARCHAR(200) 能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点</p><p>不过，VARCHAR(200) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(200) 是按照 200 这个长度来进行的，也就会消耗更多内存</p><h5 id="BLOB-和-TEXT"><a href="#BLOB-和-TEXT" class="headerlink" title="BLOB 和 TEXT"></a>BLOB 和 TEXT</h5><p>BLOB 和 TEXT 都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储</p><p>与其他类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象去处理。当 BLOB 和 TEXT 值太大时，InnoDB会使用专门的 “外部” 存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值</p><p>MySQL 对 BLOB 和 TEXT 列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引</p><blockquote><p>为什么不推荐用 TEXT 和 BLOB？</p><ul><li>不能有默认值</li><li>在遇到使用临时表的情况时，无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》这本书有提到）</li><li>检索效率比 CHAR 和 VARCHAR 低</li><li>不能直接创建索引，需要指定前缀长度</li><li>会消耗大量的网络和 IO 带宽</li><li>可能会导致表上的 DML 操作都变得较慢</li></ul></blockquote><h5 id="DATETIME-和-TIMESTAMP"><a href="#DATETIME-和-TIMESTAMP" class="headerlink" title="DATETIME 和 TIMESTAMP"></a>DATETIME 和 TIMESTAMP</h5><p>DateTime 类型没有时区信息，Timestamp 和时区有关</p><p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小</p><ul><li>DateTime：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h5 id="NULL-和-‘’-的区别"><a href="#NULL-和-‘’-的区别" class="headerlink" title="NULL 和 ‘’ 的区别"></a>NULL 和 ‘’ 的区别</h5><p><code>NULL</code> 跟 <code>&#39;&#39;</code> (空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值，就算是两个 <code>NULL</code>，它俩也不一定相等。例如，<code>SELECT NULL = NULL</code> 的结果为 false，但是在我们使用 <code>DISTINCT</code> ，<code>GROUP BY</code>， <code>ORDER BY</code>时，<code>NULL</code>又被认为是相等的</li><li><code>&#39;&#39; </code>的长度是 0，是不占用空间的，而 <code>NULL</code> 是需要占用空间的</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的</li></ul><h4 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h4><p><img src="/posts/64800/0d2070e8f84c4801adbfa03bda1f98d9-1550568677558-1584367387960.png" alt="mysql 基础架构"></p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层</strong>和<strong>存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引</li></ul><p>MySQL 的基础架构是由多个组件组成的，每个组件都有不同的功能，共同构成了 MySQL 数据库管理系统的整体架构。下面是 MySQL 基础架构的主要组件：</p><ol><li><strong>连接器</strong>（Connection Manager）：<br>连接管理器负责处理客户端应用程序与MySQL服务器之间的连接请求。当客户端应用程序需要与MySQL进行通信时，它会向连接管理器请求连接，然后连接管理器负责建立和维护与MySQL服务器的连接。连接管理器还负责认证用户身份和处理连接的断开和关闭</li><li><strong>查询分析器和优化器</strong>（Query Parser and Optimizer）：<br>当客户端应用程序发送SQL查询语句到MySQL服务器时，查询分析器负责解析这些查询，并将其转换为可执行的内部表示形式。优化器则负责分析查询，并尝试找到最优的执行计划，以提高查询性能。优化器会考虑索引、表格关联、数据分布等因素来生成最佳执行计划</li><li><strong>查询缓存</strong>（Query Cache）：<br>查询缓存用于存储已经执行过的查询和其结果集。如果客户端发送了一个已经存在于查询缓存中的查询，MySQL可以直接返回缓存中的结果，而无需再次执行查询和优化。然而，查询缓存的使用也受到一些限制，因为在写操作后，相关的查询缓存将被自动失效，可能导致性能下降</li><li><strong>查询执行器</strong>（Query Executor）：<br>查询执行器负责执行查询的执行计划，并从存储引擎获取数据。它会将查询结果返回给连接管理器，然后连接管理器将结果返回给客户端应用程序</li><li><strong>存储引擎</strong>（Storage Engines）：<br>MySQL支持多种存储引擎，存储引擎负责实际的数据存储和检索。不同的存储引擎具有不同的特性和适用场景。常见的存储引擎包括InnoDB、MyISAM、Memory等</li><li><strong>日志管理</strong>（Log Manager）：<br>MySQL维护多种日志来记录数据库的操作和变更。主要的日志包括二进制日志（Binary Log）、事务日志（Transaction Log）和错误日志（Error Log）。这些日志对于数据恢复、复制和故障排除都非常重要</li></ol><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p><img src="/posts/64800/image-20220510105408703.png" alt="MySQL 提供的所有存储引擎"></p><ul><li><strong>InnoDB</strong>（默认引擎）：<br>InnoDB是MySQL的默认存储引擎，它支持事务处理（ACID特性），具有高并发性和数据完整性，适合用于大型应用和需要数据完整性的场景。InnoDB也支持行级锁定，可以提供更好的并发性能</li><li><strong>MyISAM</strong>：<br>MyISAM是MySQL的另一个常用的存储引擎，它不支持事务处理，但在读取频繁、写入较少的场景下性能表现较好。MyISAM表格适合用于静态数据，例如日志表格等</li><li><strong>MEMORY</strong>：<br>MEMORY存储引擎将表格数据存储在内存中，适用于临时表格和缓存数据。由于数据存储在内存中，读写速度非常快，但数据会在服务器重启时丢失</li><li><strong>Archive</strong>：<br>Archive存储引擎适用于存储大量历史数据，它使用高压缩比来减少磁盘空间占用，但不支持索引和直接的更新操作，通常用于数据归档</li><li><strong>CSV</strong>：<br>CSV存储引擎将数据存储在CSV（逗号分隔值）格式文件中，适合用于导入和导出数据</li><li><strong>NDB Cluster</strong>（MySQL Cluster）：<br>NDB Cluster是一种高可用性和高容错性的存储引擎，适用于集群环境，支持分布式数据存储和并行查询</li><li><strong>Blackhole</strong>：<br>Blackhole存储引擎接收写入操作后，会将数据丢弃，但可以用于测试和复制场景</li><li><strong>Federated</strong>：<br>Federated存储引擎允许在不同MySQL服务器之间进行数据共享，类似于分布式数据库</li></ul><p>可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SELECT VERSION();<br>+-----------+<br>| VERSION() |<br>+-----------+<br>| 8.0.27    |<br>+-----------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>你也可以通过 <code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SHOW VARIABLES  LIKE <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br>+---------------------------------+-----------+<br>| Variable_name                   | Value     |<br>+---------------------------------+-----------+<br>| default_storage_engine          | InnoDB    |<br>| default_tmp_storage_engine      | InnoDB    |<br>| disabled_storage_engines        |           |<br>| internal_tmp_mem_storage_engine | TempTable |<br>+---------------------------------+-----------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><h6 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h6><p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong></p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h6 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h6><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</p><p>提供了大量的特性，包括压缩表、空间数据索引等</p><p><strong>不支持事务</strong></p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</p><p><strong>区别总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别</li><li>MyISAM 不支持外键，而 InnoDB 支持</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持</li><li>InnoDB 的性能比 MyISAM 更强大</li></ul><h3 id="InnoDB-1"><a href="#InnoDB-1" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="数据存放位置"><a href="#数据存放位置" class="headerlink" title="数据存放位置"></a>数据存放位置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;datadir&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> datadir       <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>我们每创建一个 database（数据库） 都会在 <code>/var/lib/mysql/</code> 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里</p><p>比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表</p><p><img src="/posts/64800/database.png" alt="my_test"></p><p>进入 <code>/var/lib/mysql/my_test</code> 目录，看看里面文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@xiaolin ~]#ls /var/lib/mysql/my_test<br>db.opt  <br>t_order.frm  <br>t_order.ibd<br></code></pre></td></tr></table></figure><p>可以看到，共有三个文件，这三个文件分别代表着：</p><ul><li><strong>db.opt</strong>，用来存储当前数据库的默认字符集和字符校验规则</li><li><strong>t_order.frm</strong> ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义</li><li><strong>t_order.ibd</strong>，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件</li></ul><p>一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件</p><h4 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h4><p>从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间内，称为表空间，而表空间由段（sengment）、区（extent）、页（page）组成</p><blockquote><p>ps：页在一些文档中又称块（block）</p></blockquote><p>InnoDB存储引擎的逻辑存储结构大致如下：</p><p>　　<img src="/posts/64800/1062001-20180806105300673-894487905.png" alt="innoDB 存储引擎逻辑结构"></p><p><strong>表空间（table space）</strong></p><p>表空间分为了两种，这里简单的概括一下：</p><ol><li><strong>独立表空间</strong>：每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中</li><li><strong>共享表空间</strong>： Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。</li></ol><p>InnoDB把数据保存在表空间内，表空间可以看作是InnoDB存储引擎逻辑结构的最高层。本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间并不只是存储表和索引，还保存了回滚段、双写缓冲区等</p><p><strong>段（segment）</strong></p><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据</li></ul><p><strong>区（extent）</strong></p><p>区是由连续的页（Page）组成的空间，在任何情况下每个区大小都为1MB，为了保证页的连续性，InnoDB存储引擎每次从磁盘一次申请4-5个区。默认情况下，InnoDB存储引擎的页大小为16KB，即一个区中有64个连续的页（1MB／16KB&#x3D;64）</p><p>InnoDB1.0.x版本开始引入压缩页，每个页的大小可以通过参数KEY_BLOCK_SIZE设置为2K、4K、8K，因此每个区对应的页尾512、256、128.</p><p>InnpDB1.2.x版本新增了参数innodb_page_size，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据不是压缩的</p><p>但是有时候为了节约磁盘容量的开销，创建表默认大小是96KB，区中是64个连续的页（对于一些小表）</p><p><strong>页（Page）</strong></p><p>页是InnoDB存储引擎磁盘管理的最小单位，每个页默认<strong>16KB</strong>；InnoDB存储引擎从1.2.x版本碍事，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p><p>innoDB存储引擎中，常见的页类型有：</p><ol><li>数据页（B-tree Node)</li><li>undo页（undo Log Page）</li><li>系统页 （System Page）</li><li>事物数据页 （Transaction System Page）</li><li>插入缓冲位图页（Insert Buffer Bitmap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li><li>压缩的二进制大对象页 （compressed BLOB Page）</li></ol><p><strong>行（row）</strong></p><p>InnoDB存储引擎是面向列的（row-oriented)，也就是说数据是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放16KB&#x2F;2-200，即7992行记录</p><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>InnoDB 存储引擎支持不同的行格式(Compact、Redundant、Dynamic和Compressed)</p><p>以Compact行格式为例，下边是其存储示意图：</p><p><img src="/posts/64800/COMPACT.drawio.png" alt="compact 行格式"></p><p>一条记录数据的存储可以分为两部分：<strong>额外信息</strong>和<strong>真实数据</strong>。 额外信息用来描述记录，分为变长字段列表、NULL值列表和记录头信息：</p><ul><li><strong>变长字段列表</strong>：MySQL支持的一些变长的数据类型，比如 VARCHAR(M)、TEXT 等。这些变长字段中存储的字节数量是不固定的，存储这个数据的真实字节数很有必要，这在解析数据的时候，数据库就知道从真实数据区域取出哪部分数据了。所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，形成一个变长字段长度列表，<strong>各变长字段数据占用的字节数按照列的顺序逆序存放。</strong></li></ul><blockquote><p>我们在项目使用到 char 类型，比如使用 char(32) 来存储用户的密码，那么使用 char 类型的字段会被添加到变长字段列表中吗？答案是有可能会！因为项目中数据表使用的字符集是不确定的，最常用的 utf8mb4 使用1～4个变长字节来编码数据，中文和英文所占用的字节数是不同的。</p></blockquote><blockquote><p>对于项目中绝大多数使用存储量小的字段，比如说 varchar(32)，tinyint(4) 等，假设使用utf8字符集，这种字段存储的真实数据长度一定不会超过255，使用一个字节表示就可以了。但是如果字段的真实数据可能会超过了255该怎么表示呢？分为两种情况：当真实数据字节数小于127的时候，用1个字节表示，大于127的时候使用2个字节表示，也就是说字节的最高位表示该字节表示的是一个变长数据的一部分还是全部</p></blockquote><ul><li><strong>NULL值列表</strong>：数据表中的某些列可能存储NULL值，把这些NULL值都放到记录的真实数据中存储很浪费存储空间，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中。在表中，主键列和使用NOT NULL修改过的列不允许存储NULL值，其他的列如果也没有NULL值，那么NULL值列表也就不存在了，也就是说NULL值列表并不总是存在的，上边说到的变长字段列表也是一样。标示一条记录中的数据是否为NULL使用一个二进制位就可以搞定了，1为NULL，0为非NULL，<strong>NULL值列表标示也是按照记录列的顺序逆序存放的。</strong></li></ul><blockquote><p>问:变长字段长度列表、NULL值列表中的信息之所以按照列的顺序逆序存放？答:这样可以使记录中位置靠前的字段和它们对应的字段长度信息加载到内存中时，位置距离更近，可能会提高高速缓存的命中率。</p></blockquote><ul><li><strong>记录头信息</strong>：记录头信息由5个固定的字节组成,5个字节是40个二进制位，这40个二进制位描述了记录的不同属性信息，这些信息非常重要</li></ul><h5 id="变长字段列表"><a href="#变长字段列表" class="headerlink" title="变长字段列表"></a>变长字段列表</h5><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的</p><p>为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> ascii ROW_FORMAT <span class="hljs-operator">=</span> COMPACT;<br></code></pre></td></tr></table></figure><p>现在 t_user 表里有这三条记录：</p><p><img src="/posts/64800/t_test.png" alt="img"></p><p>接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的</p><p>先来看第一条记录：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」</p><p><img src="/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p><p>同样的道理，我们也可以得出<strong>第二条记录</strong>的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：</p><p><img src="/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82.png" alt="img"></p><p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度</p><p><img src="/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A83.png" alt="img"></p><blockquote><p>为什么「变长字段长度列表」的信息要按照逆序存放？</p></blockquote><p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong></p><p>同样的道理， NULL 值列表的信息也需要逆序存放</p><blockquote><p>每个数据库表的行格式都有「变长字段字节数列表」吗？</p></blockquote><p>其实变长字段字节数列表不是必须的</p><p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间</p><p>所以「变长字段长度列表」只出现在数据表有变长字段的时候</p><h5 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h5><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code></p><p>还是以 t_user 表的这三条记录作为例子：</p><p><img src="/posts/64800/t_test.png" alt="img"></p><p>接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的</p><p>先来看<strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：</p><p><img src="/null%E5%80%BC%E5%88%97%E8%A1%A81.png" alt="img"></p><p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：</p><p><img src="/null%E5%80%BC%E5%88%97%E8%A1%A82.png" alt="img"></p><p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00</p><p>接下来看<strong>第二条记录</strong>，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04</p><p><img src="/null%E5%80%BC%E5%88%97%E8%A1%A83.png" alt="img"></p><p>最后<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06</p><p><img src="/null%E5%80%BC%E5%88%97%E8%A1%A84.png" alt="img"></p><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><p><img src="/null%E5%80%BC%E5%88%97%E8%A1%A85.png" alt="img"></p><blockquote><p>每个数据库表的行格式都有「NULL 值列表」吗？</p></blockquote><p>NULL 值列表也不是必须的</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong></p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）</p><blockquote><p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p></blockquote><p>「NULL 值列表」的空间不是固定 1 字节的</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推</p><h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><ul><li><strong>delete_mask</strong> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li><strong>next_record</strong>：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li><strong>record_type</strong>：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p><p><img src="/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png" alt="img"></p><ul><li>row_id</li></ul><p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节</p><ul><li>trx_id</li></ul><p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节</p><ul><li>roll_pointer</li></ul><p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节</p><h5 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h5><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong></p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示</p><p><img src="/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p><p>上面这个是 Compact 行格式在发生行溢出后的处理</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><p><img src="/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png" alt="img"></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构</strong></p><p>索引的作用就相当于书的目录，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong></p><p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 <strong>B+树</strong>作为索引结构</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按照四个角度来分类索引：</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong></li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong></li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong></li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong></li></ul><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，每个节点里的数据是<strong>按主键顺序存放</strong>的。在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O</p><p><img src="/posts/64800/dd076212a7637b9032c97a615c39dcd7.png" alt="B+tree"></p><p>B+树和B树相比：</p><ul><li>B+树所有关键码都存放在叶节点中，上层的非叶节点的关键码是其子树中最小关键码的复写</li><li>B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接</li><li>B+树在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支</li></ul><p><strong>优势</strong>：</p><ul><li><strong>单点查询</strong>：B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到。从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，数据量相同的情况下，B+树的非叶子节点可以存放更多的索引，查询底层节点的磁盘 I&#x2F;O次数会更少</li><li><strong>插入和删除效率</strong>：B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形</li><li><strong>范围查询</strong>：B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，范围查询效率不如 B+ 树。<strong>B+ 树的插入和删除效率更高</strong>。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB</li></ul><p><strong>对比</strong></p><ul><li><strong>B+Tree 对比 B Tree</strong>：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点</li><li><strong>B+Tree 对比 二叉树</strong>：对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数。在实际的应用当中， d 值是大于100的，即使数据达到千万级别时，B+Tree 的高度依然维持在 3 - 4 层左右，一次数据查询操作只需要做 3 - 4 次的磁盘 I&#x2F;O 操作就能查询到。二叉树的每个父节点的儿子节点个数是 2 个，意味着其搜索复杂度为 O(logN)，二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多</li><li><strong>B+Tree 对比 Hash</strong>：Hash在做等值查询的时候效率高，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询</li></ul><h4 id="聚簇索引和非聚簇索引（二级索引）"><a href="#聚簇索引和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引和非聚簇索引（二级索引）"></a>聚簇索引和非聚簇索引（二级索引）</h4><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引（理由：数据一旦存储，顺序只能有一种）</p><p><strong>聚簇索引和非聚簇索引的区别是:</strong></p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据</li><li>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要<strong>回表</strong>查询多次。当然，如果是<strong>索引覆盖</strong>的话，查一次即可</li></ul><blockquote><p>注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引</p></blockquote><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据</p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>索引覆盖（covering index ，或称为覆盖索引）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了<strong>回表</strong>的产生减少了树的搜索次数，显著提升性能</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>MySQL 可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了<code>&quot;name，age，school&quot;</code>的联合索引，那么索引的排序为: 先按照 name 排序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序</p><p>当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整</p><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>MySQL 5.6 引入了索引下推优化。默认开启，使用 <code>SET optimizer_switch = ‘index_condition_pushdown=off’;</code> 可以将其关闭</p><ul><li>有了索引下推优化，可以在<strong>减少回表次数</strong></li><li>在 InnoDB 中只针对<strong>二级索引</strong>有效</li></ul><p>官方文档中给的例子和解释如下：</p><p>在 people_table中有一个二级索引(zipcode，lastname，address)，查询是<code>SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;</code></p><ul><li>如果没有使用索引下推技术，则MySQL会通过 zipcode&#x3D;’95054’ 从存储引擎中查询对应的数据，返回到 MySQL 服务端，然后MySQL服务端基于 <code>lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’</code> 来判断数据是否符合条件</li><li>如果使用了索引下推技术，则MYSQL首先会返回符合 zipcode&#x3D;’95054’ 的索引，然后根据 <code>lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’</code> 来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接 reject 掉</li></ul><h4 id="索引创建注意"><a href="#索引创建注意" class="headerlink" title="索引创建注意"></a>索引创建注意</h4><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高</li><li>选择合适的字段创建索引<ul><li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代</li><li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段</li><li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引</li><li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率</li></ul></li></ul><h4 id="分析语句是否走索引"><a href="#分析语句是否走索引" class="headerlink" title="分析语句是否走索引"></a>分析语句是否走索引</h4><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>     <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> cus_order <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">997572</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</li></ul><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式</p><p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息</p><p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息</p><p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息</p><p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-operator">+</span> <span class="hljs-keyword">SELECT</span> 查询语句；<br></code></pre></td></tr></table></figure><p>我们简单来看下一条查询语句的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(emp_no)<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>    <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key     <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>     <span class="hljs-operator">|</span> dept_emp <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>            <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">331143</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> SUBQUERY    <span class="hljs-operator">|</span> dept_emp <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> index <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>,dept_no <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-operator">|</span> <span class="hljs-number">16</span>      <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">331143</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><h4 id="EXPLAIN-字段"><a href="#EXPLAIN-字段" class="headerlink" title="EXPLAIN 字段"></a>EXPLAIN 字段</h4><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p><p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p><ul><li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li><li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li><li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li><li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li><li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li><li><strong>UNION RESULT</strong>：UNION 查询的结果。</li></ul><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p><ul><li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li><li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。 -<strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li></ul><h5 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h5><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li><li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><strong>ALL</strong>：全表扫描。</li></ul><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p><h5 id="key（重要）"><a href="#key（重要）" class="headerlink" title="key（重要）"></a>key（重要）</h5><p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p><h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p><h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p><h5 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h5><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li><li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li><strong>Using join buffer</strong> (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属 MySQL 二进制日志 <code>binlog</code>（归档日志）和 innoDB 事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>MySQL Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong></p><p>在完成一条更新操作后，Server 层会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件。binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作</p><h5 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h5><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><p><strong>STATEMENT</strong>：每一条修改数据的 SQL 都会被记录到 binlog 中，主从复制中 slave 端再根据 SQL 语句重现</p><blockquote><p>STATEMENT 有动态函数的问题，比如用了 uuid 或者 now 这些函数，在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致</p></blockquote></li><li><p><strong>ROW</strong>：记录行数据最终被修改成什么样了，不会出现 STATEMENT 下动态函数的问题</p><blockquote><p>但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句</p></blockquote></li><li><p><strong>MIXED</strong>：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式</p></li></ul><h5 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h5><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p><p><code>binlog</code>日志刷盘流程如下</p><p><img src="/posts/64800/04-20220305234747840.png" alt="img"></p><ul><li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code></p><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code></p><p><img src="/posts/64800/05-20220305234754405.png" alt="img"></p><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失</p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样</p><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code></p><p><img src="/posts/64800/06-20220305234801592.png" alt="img"></p><p>在出现 <code>IO</code> 瓶颈的场景里，将 <code>sync_binlog</code> 设置成一个比较大的值，可以提升性能</p><p>同样的，如果机器宕机，会丢失最近 <code>N </code>个事务的 <code>binlog</code> 日志</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是Innodb存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和MVCC</strong>。</p><p>在事务没提交之前，Innodb会先记录更新前的数据到undo log中，回滚时利用 undo log 来进行回滚。每当进行一条记录进行操作(修改、删除、新增)时，要把回滚时需要的信息都记录到 undo log 里：原理是执行一条相反的操作。undo log 有两个参数：roll_pointer 指针和一个 trx_id 事务id，通过 trx_id 可以知道该记录是被哪个事务修改的；通过 roll_pointer 指针可以将这些 undo log 串成一个链表，形成版本链</p><p>innodb 存储引擎也通过 ReadView + undo log 实现 MVCC (多版本并发控制)</p><blockquote><p><strong>undo log 的作用</strong></p><p><strong>实现事务回滚，保障事务的原子性</strong>：如果出现了错误或者用户执行了 ROLLBACK 语句，可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</p><p><strong>实现 MVCC关键因素之一</strong>：MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，在执行快照读的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</p></blockquote><p>这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。undo log主要分为3种：</p><ul><li><strong>Insert undo log</strong> ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li><strong>Update undo log</strong>：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li><strong>Delete undo log</strong>：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了<ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的</li></ul></li></ul><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作</p><p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查</p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链</li></ul><p><img src="/posts/64800/1722113-20220428134318157-1726363318.png" alt="版本链"></p><p>另外，<strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong></p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。具体的实现可以看这篇文章：<a href="https://sugayoiya.github.io/posts/35975.html">MySQL 事务</a></p><p>因此，undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录</li></ul><blockquote><p>很多人疑问 undo log 是如何刷盘（持久化到磁盘）的？</p><p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p><p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的</p></blockquote><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log 是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生一条或者多条物理日志。在事务提交时，先将redo log持久化到磁盘即可，不需要等到将缓存在Buffer Pool里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化但是redo log已经持久化，可以<strong>根据 redo log 的内容，将所有数据恢复到最新的状态</strong></p><p><img src="/posts/64800/02.png" alt="redo log 恢复数据"></p><p>redo log 实现了事务中的持久性，主要用于掉电等故障恢复。发生更新的时候，InnoDB会先更新内存，同时标记为脏页，然后将本次对这个页的修改以redo log的形式记录下来。InnoDB引擎会在适当的时候，由后台线程将缓存在Buffer Pool的脏页刷新到磁盘里，实现<strong>WAL技术</strong></p><blockquote><p><strong>WAL技术</strong></p><p>WAL技术指的是，MySQL的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</p></blockquote><blockquote><p><strong>crash-safe</strong></p><p>redo log + WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失</p></blockquote><p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><p><img src="/posts/64800/03.png" alt="img"></p><blockquote><p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p></blockquote><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><blockquote><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><h5 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h5><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong>：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong>：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong>：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p><p><img src="/posts/64800/04.png" alt="img"></p><p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p><p><strong>为什么？</strong></p><p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p><p><img src="/posts/64800/05.png" alt="img"></p><p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p><p>下面是不同刷盘策略的流程图</p><h5 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;0"></a>innodb_flush_log_at_trx_commit&#x3D;0</h5><p><img src="/posts/64800/06.png" alt="img"></p><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p><h5 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;1"></a>innodb_flush_log_at_trx_commit&#x3D;1</h5><p><img src="/posts/64800/07.png" alt="img"></p><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p><h5 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;2"></a>innodb_flush_log_at_trx_commit&#x3D;2</h5><p><img src="/posts/64800/09.png" alt="img"></p><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><h5 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h5><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><p><img src="/posts/64800/10.png" alt="img"></p><p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ul><li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li><li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p><p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p><p><img src="/posts/64800/11.png" alt="img"></p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><p><img src="/posts/64800/12.png" alt="img"></p><h5 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h5><p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式</p><p>现在我们来思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p><p>它们不都是刷盘么？差别在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> Byte = 8bit<br><span class="hljs-number">1</span> KB = <span class="hljs-number">1024</span> Byte<br><span class="hljs-number">1</span> MB = <span class="hljs-number">1024</span> KB<br><span class="hljs-number">1</span> GB = <span class="hljs-number">1024</span> MB<br><span class="hljs-number">1</span> TB = <span class="hljs-number">1024</span> GB<br></code></pre></td></tr></table></figure><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><blockquote><p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p></blockquote><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力</p><p><code>binlog</code>（归档日志）保证了 <code>MySQL</code> 集群架构的数据一致性</p><p>虽然它们都属于持久化的保证，但是侧重点不同</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p><img src="/posts/64800/01-20220305234816065.png" alt="img"></p><p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p><p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p><p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p><p><img src="/posts/64800/02-20220305234828662.png" alt="img"></p><p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p><p><img src="/posts/64800/03-20220305235104445.png" alt="img"></p><p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p><img src="/posts/64800/04-20220305234956774.png" alt="img"></p><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p><img src="/posts/64800/05-20220305234937243.png" alt="img"></p><p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p><p><img src="/posts/64800/06-20220305234907651.png" alt="img"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlockingQueue 原理与使用</title>
    <link href="/posts/29247.html"/>
    <url>/posts/29247.html</url>
    
    <content type="html"><![CDATA[<p><code>BlockingQueue</code> 是 Java 并发包（<em>java.util.concurrent</em>）中提供的一个接口，它代表了一个支持阻塞操作的队列。它是一个特殊的队列，当队列为空时，获取元素的操作会被阻塞，直到队列中有可用元素；当队列已满时，插入元素的操作会被阻塞，直到队列有空闲位置</p><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列（Queue）是一种常用的数据结构，它遵循先进先出（First-In-First-Out，FIFO）的原则。队列可以理解为一个有序的线性表，其中元素的插入（入队）只能在队尾进行，元素的删除（出队）只能在队头进行。队列常用于在多线程和并发编程中实现任务调度、消息传递等场景</p><p>队列的主要操作包括：</p><ol><li>入队（enqueue）：将元素添加到队列的末尾。</li><li>出队（dequeue）：从队列的头部删除并返回元素。</li><li>获取队头元素（peek&#x2F;front）：查看队头元素，但不进行删除操作。</li></ol><p>队列的常见用途包括：</p><ul><li>实现线程池任务调度：线程池通过队列来保存待执行的任务，每个线程从队列中获取任务进行执行。</li><li>消息传递：在多线程或分布式系统中，可以使用队列来实现消息的传递和通信。</li><li>广度优先搜索：在图遍历算法中，广度优先搜索（BFS）可以使用队列来实现节点的遍历顺序。</li></ul><h4 id="Java-中的-Queue"><a href="#Java-中的-Queue" class="headerlink" title="Java 中的 Queue"></a>Java 中的 Queue</h4><p>在Java中，<code>Queue</code> 是一个接口，它是Java集合框架中的一部分。<code>Queue</code> 接口继承自 <code>Collection</code> 接口</p><h5 id="Queue接口定义如下："><a href="#Queue接口定义如下：" class="headerlink" title="Queue接口定义如下："></a>Queue接口定义如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Queue接口中，定义基本的元素插入和删除的方法，主要方法及其含义分别如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向队列中添加一个元素；如果有空间则添加成功返回true，否则则抛出<code>IllegalStateException</code>异常</td></tr><tr><td><code>boolean offer(E e)</code></td><td>向队列中添加一个元素；如果有空间则添加成功返回true，否则返回false</td></tr><tr><td><code>E remove()</code></td><td>从队列中删除一个元素；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>E poll();</code></td><td>从队列中删除一个元素；如果元素存在则返回队首元素，否则返回null</td></tr><tr><td><code>E element()</code></td><td>从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>E peek()</code></td><td>从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</td></tr></tbody></table><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>**<code>Deque</code>*<em>（</em>Double-Ended Queue*）是Java集合框架中的一种双端队列，它继承自<code>Queue</code>接口。与普通的队列（Queue）不同，<code>Deque</code>允许在队列的两端进行元素的插入和删除操作，因此可以在队头和队尾都进行入队和出队操作。<code>Deque</code>可以作为栈（先进后出，LIFO）或队列（先进先出，FIFO）来使用，因此它是一种非常灵活的数据结构</p><p><code>Deque</code> 接口定义了一系列双端队列的操作方法，包括以下主要方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void addFirst(E e)</code></td><td>在队头插入元素</td></tr><tr><td><code>boolean offerFirst(E e)</code></td><td>在队头插入元素</td></tr><tr><td><code>void addLast(E e)</code></td><td>在队尾插入元素</td></tr><tr><td><code>boolean offerLast(E e)</code></td><td>在队尾插入元素</td></tr><tr><td><code>E removeFirst()</code></td><td>移除并返回队头元素</td></tr><tr><td><code>E pollFirst()</code></td><td>移除并返回队头元素</td></tr><tr><td><code>E removeLast()</code></td><td>移除并返回队尾元素</td></tr><tr><td><code>E pollLast()</code></td><td>移除并返回队尾元素</td></tr><tr><td><code>E getFirst()</code></td><td>返回队头元素但不移除</td></tr><tr><td><code>boolean removeFirstOccurrence(Object o)</code></td><td>如果元素o存在，则从队列中删除第一次出现的该元素</td></tr><tr><td><code>boolean removeLastOccurrence(Object o)</code></td><td>如果元素o存在，则从队列中删除最后一次出现的该元素</td></tr></tbody></table><p>除了上述方法，<code>Deque</code> 还继承了 <code>Queue</code> 接口的方法，因此它可以作为普通队列使用。此外，<code>Deque</code> 还提供了栈相关的方法，如 <code>push(E e)</code> 和 <code>pop()</code>，用于在栈的头部进行入栈和出栈操作</p><h4 id="Queue-的实现"><a href="#Queue-的实现" class="headerlink" title="Queue 的实现"></a>Queue 的实现</h4><ul><li><code>LinkedList</code>: 可以实现<code>Queue</code>接口，即可作为队列使用</li><li><code>ArrayDeque</code>: 双端队列的实现，也可以作为队列使用</li><li><code>PriorityQueue</code>: 优先级队列的实现，不是严格的FIFO队列，而是根据元素的优先级来决定出队顺序</li></ul><p>在Java并发包（java.util.concurrent）中，还有<code>BlockingQueue</code>接口的实现，它提供了阻塞式的队列操作，常用于多线程环境下的任务调度和消息传递。常见的<code>BlockingQueue</code>实现类有：</p><ul><li><code>ArrayBlockingQueue</code>: 基于数组的有界阻塞队列</li><li><code>LinkedBlockingQueue</code>: 基于链表的可选有界阻塞队列</li><li><code>SynchronousQueue</code>: 容量为1的阻塞队列，用于直接传递元素</li></ul><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><code>BlockingQueue</code> 其实就是阻塞队列，是基于阻塞机制实现的线程安全的队列。而阻塞机制的实现是通过在入队和出队时加锁的方式避免并发操作</p><p><code>BlockingQueue</code> 不同于普通的 <code>Queue</code> 的区别主要是：</p><ol><li>通过在入队和出队时进行加锁，保证了队列线程安全</li><li>支持阻塞的入队和出队方法：当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素</li></ol><p><code>BlockingQueue</code> 常用于<strong>生产者-消费者模型</strong>中，往队列里添加元素的是生产者，从队列中获取元素的是消费者；通常情况下生产者和消费者都是由多个线程组成；下图所示则为一个最常见的<strong>生产者-消费者模型</strong>，生产者和消费者之间通过队列平衡两者的的处理能力、进行解耦等</p><p><img src="/posts/29247/734446-20221017141624292-2029330202.png" alt="image"></p><h4 id="BlockingQueue-接口定义"><a href="#BlockingQueue-接口定义" class="headerlink" title="BlockingQueue 接口定义"></a>BlockingQueue 接口定义</h4><p><code>BlockingQueue</code> 接口定义了以下几个主要的方法：</p><ol><li><code>put(E element)</code>: 将指定的元素插入队列，如果队列已满，则阻塞直到队列有空闲位置</li><li><code>take()</code>: 获取并移除队列的头部元素，如果队列为空，则阻塞直到队列有可用元素</li><li><code>offer(E element)</code>: 将指定的元素插入队列，如果队列已满，则立即返回false，不会阻塞</li><li><code>poll()</code>: 获取并移除队列的头部元素，如果队列为空，则立即返回null，不会阻塞</li><li><code>offer(E element, long timeout, TimeUnit unit)</code>: 将指定的元素插入队列，如果队列已满，则等待指定的时间，超时后返回false</li><li><code>poll(long timeout, TimeUnit unit)</code>: 获取并移除队列的头部元素，如果队列为空，则等待指定的时间，超时后返回null</li></ol><p><code>BlockingQueue </code>主要提供了四类方法，如下表所示：</p><table><thead><tr><th>方法</th><th>抛出异常</th><th>返回特定值</th><th>阻塞</th><th>阻塞特定时间</th></tr></thead><tbody><tr><td>入队</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td>出队</td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td>获取队首元素</td><td><code>element()</code></td><td><code>peek()</code></td><td>不支持</td><td>不支持</td></tr></tbody></table><h4 id="BlockingQueue实现类及原理"><a href="#BlockingQueue实现类及原理" class="headerlink" title="BlockingQueue实现类及原理"></a>BlockingQueue实现类及原理</h4><p>常见的实现<code>BlockingQueue</code>的类有：</p><ul><li><code>ArrayBlockingQueue</code>: 基于数组的有界阻塞队列，需要指定队列的容量</li><li><code>LinkedBlockingQueue</code>: 基于链表的可选有界阻塞队列，默认大小为<code>Integer.MAX_VALUE</code></li><li><code>PriorityBlockingQueue</code>: 支持优先级排序的无界阻塞队列</li><li><code>DelayQueue</code>: 延迟队列，其中的元素只有在其指定的延迟时间过后才能从队列中获取</li><li><code>SynchronousQueue</code>: 容量为1的阻塞队列，用于直接传递元素，通常用于线程池等场景</li></ul><p>使用<code>BlockingQueue</code>可以有效地进行线程间通信和协作，让多线程编程更加简单和安全。它是在并发编程中常用的工具之一，能够很好地处理生产者-消费者问题以及其他队列相关的任务</p><p>其中在日常开发中用的比较多的是 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>，本文也将主要介绍这两个实现类的原理</p><h4 id="ArrayBlockingQueue的用法和原理"><a href="#ArrayBlockingQueue的用法和原理" class="headerlink" title="ArrayBlockingQueue的用法和原理"></a>ArrayBlockingQueue的用法和原理</h4><h5 id="ArrayBlockingQueue的类定义"><a href="#ArrayBlockingQueue的类定义" class="headerlink" title="ArrayBlockingQueue的类定义"></a>ArrayBlockingQueue的类定义</h5><p><img src="/posts/29247/image-20230726190657928.png" alt="image-20230726190657928"></p><p>实现了 <code>BlockingQueue</code> 接口，并继承了抽象队列类 <code>AbstractQueue</code>（封装了部分通用方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ArrayBlockingQueue类属性"><a href="#ArrayBlockingQueue类属性" class="headerlink" title="ArrayBlockingQueue类属性"></a>ArrayBlockingQueue类属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来存放数据的数组</span><br><span class="hljs-keyword">final</span> Object[] items;<br><br><span class="hljs-comment">// 下次取数据的数组下标位置</span><br><span class="hljs-type">int</span> takeIndex;<br><br><span class="hljs-comment">// 下次放数据的数组下标位置</span><br><span class="hljs-type">int</span> putIndex;<br><br><span class="hljs-comment">// 当前已有元素的个数</span><br><span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">// 独占锁，用来保证存取数据安全</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">// 取数据的条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">// 放数据的条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure><p>在 ArrayBlockingQueue 中，还定义了队列元素存储以及入队、出队操作的属性。</p><ul><li><code>final Object[] items</code>：由于ArrayBlockingQueue是基于数组实现的阻塞队列，所以使用<code>items</code>数组，存储队列中的元素</li><li><code>int takeIndex</code>和<code>int putIndex</code>：两个items数组的索引值，分别指向出队元素的索引值以及将要入队元素的索引值；通过这两个索引，可以控制元素从<code>items</code>数组中如何进行出队和入队</li><li><code>int count</code>：当前队列中的元素数量，通过该值实现了队列有界性</li></ul><p>除了上述几个属性，还需要部分属性进行并发控制，在BlockingQueue中使用了<code>双Condition算法</code>进行并发控制，主要通过如下几个变量实现：</p><ul><li><code>ReentrantLock lock</code>：这里使用了ReetrantLock作为独占锁，进行并发控制</li><li><code>Condition notEmpty</code>和<code>Condition notFull</code>：定义了两个阻塞唤醒条件，分别表示<code>等待出队的条件</code>和<code>等待入队的条件</code></li></ul><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>在 ArrayBlockingQueue 构造方法中，主要功能时初始化元素数组以及锁和 condition 条件；可以通过<code>capacity</code> 变量指定有界队列的元素数量，以及通过 <code>fair</code> 指定是否使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 指定队列元素数量capacity，并使用非公平锁进行并发控制 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>  <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** 指定队列元素数量capacity，并通过fair变量指定使用公平锁/非公平锁进行并发控制*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>  <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity]; <span class="hljs-comment">// 初始化元素数组</span><br>  lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<span class="hljs-comment">// 初始化锁</span><br>  notEmpty = lock.newCondition(); <span class="hljs-comment">// 初始化出队条件</span><br>  notFull =  lock.newCondition();<span class="hljs-comment">// 初始化入队条件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ArrayBlockingQueue 中4组存取数据的方法实现也是大同小异，本次以put和take方法进行解析</p><h5 id="入队逻辑"><a href="#入队逻辑" class="headerlink" title="入队逻辑"></a>入队逻辑</h5><p><strong>put</strong></p><p><img src="/posts/29247/734446-20221017141642920-1859955829.png" alt="image"></p><p>无论是放数据还是取数据都是从队头开始，逐渐往队尾移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 放数据，如果队列已满，就一直阻塞，直到有其他线程从队列中取走数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 校验元素不能为空</span><br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>  <span class="hljs-comment">// 加锁，加可中断的锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果队列已满，就一直阻塞，直到被唤醒</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>      <span class="hljs-comment">// 如果队列未满，就往队列添加元素</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 结束后，别忘了释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际往队列添加数据的方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-comment">// 获取数组</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-comment">// putIndex 表示本次插入的位置</span><br>    items[putIndex] = x;<br>    <span class="hljs-comment">// ++putIndex 计算下次插入的位置</span><br>    <span class="hljs-comment">// 如果本次插入的位置，正好是队尾，下次插入就从 0 开始</span><br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 元素数量加一</span><br>    count++;<br>    <span class="hljs-comment">// 唤醒因为队列空等待的线程</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中有个有意思的设计，添加元素的时候如果已经到了队尾，下次就从队头开始添加，相当于做成了一个循环队列。像下面这样：</p><p><img src="/posts/29247/734446-20221017141654461-590102834.png" alt="image"></p><h5 id="出队逻辑"><a href="#出队逻辑" class="headerlink" title="出队逻辑"></a>出队逻辑</h5><p><strong>take</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 取数据，如果队列为空，就一直阻塞，直到有其他线程往队列中放数据</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>  <span class="hljs-comment">// 加锁，加可中断的锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果队列为空，就一直阻塞，直到被唤醒</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-comment">// 如果队列不为空，就从队列取数据</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 结束后，别忘了释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际从队列取数据的方法</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 获取数组</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-comment">// takeIndex 表示本次取数据的位置，是上一次取数据时计算好的</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    <span class="hljs-comment">// 取完之后，就把队列该位置的元素删除</span><br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// ++takeIndex 计算下次取数据的位置</span><br>    <span class="hljs-comment">// 如果本次取数据的位置，正好是队尾，下次就从 0 开始取数据</span><br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 元素数量减一</span><br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    <span class="hljs-comment">// 唤醒被队列满所阻塞的线程</span><br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="阻塞实现"><a href="#阻塞实现" class="headerlink" title="阻塞实现"></a><strong>阻塞实现</strong></h5><p>通过上面的描述，我们了解了基于数组的阻塞队列的入队和出队实现逻辑，但是我们还剩下最后一个疑问，当入队和出队时，如果无法直接进行入队和出队操作，需要进行阻塞等待，那么阻塞是如何实现的呢？在 <code>ArrayBlockingQueue</code> 中主要是使用独占锁 <code>ReentrantLock</code> 以及两个条件队列 <code>notFull</code> 和 <code>notEmpty </code>实现的。</p><p>我们首先看一下阻塞入队的方法 <code>put(E e)</code>，下面是其代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>          <span class="hljs-comment">// 如果队列已满，线程阻塞，并添加到notFull条件队列中等待唤醒</span><br>          notFull.await();<br>        &#125;<br>        <span class="hljs-comment">// 如果队列未满，则调用enqueue方法进行入队操作</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>put</code> 方法进行阻塞式入队的基本流程为：</p><ul><li>首先，在进行入队操作前，使用 <code>ReentrantLock</code> 进行加锁操作，保证只有一个线程执行入队或出队操作；如果锁被其他线程占用，则等待；</li><li>如果加锁成功，则首先判断队列是否满，也就是 <code>while(count == items.length)</code>；如果队列已满，则调用 <code>notFull.await()</code>，将当前线程阻塞，并添加到 <code>notFull条件队列</code> 中等待唤醒；如果队列不满，则直接调用 <code>enqueue</code> 方法，进行元素插入；</li><li>当前线程添加到 <code>notFull</code> 条件队列中后，只有当其他线程有出队操作时，会调用 <code>notFull.signal()</code> 方法唤醒等待的线程；当前线程被唤醒后，还需要再次进行一次队列是否满的判断，如果此时队列不满才可以进行 <code>enqueue</code> 操作，否则仍然需要再次阻塞等待，这也就是为什么在判断队列是否满时使用 <code>while</code> 的原因，即避免当前线程被意外唤醒，或者唤醒后被其他线程抢先完成入队操作。</li><li>最后，当完成入队操作后，在finally代码块中进行锁释放 <code>lock.unlock</code>，完成 <code>put</code>入队操作</li></ul><p>下面我们再来看下阻塞出队方法 <code>take()</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 判断队列是否为空，如果为空则线程阻塞，添加到notEmpty条件队列等待</span><br>            notEmpty.await();<br>        <span class="hljs-comment">// 队列不为空，进行出队操作</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实<code>take</code>方法与<code>put</code>方法类似，主要流程也是先加锁，然后循环判断队列是否为空，如果为空则添加到notEmpty条件队列等待，如果不为空则进行出队操作；最后进行锁释放。</p><h5 id="指定等待时间的阻塞实现"><a href="#指定等待时间的阻塞实现" class="headerlink" title="指定等待时间的阻塞实现"></a>指定等待时间的阻塞实现</h5><p>OK，到这里我们了解了如何进行阻塞的入队和出队操作，在 <code>ArrayBlockingQueue</code> 中还支持指定等待时间的阻塞式入队和出队操作，分别是 <code>offer(e, time, unit)</code>和 <code>poll(time, unit)</code>方法。这里我们就只要看下 <code>offer(e, time, unit)</code>的实现逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-comment">// 获取剩余等待时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 判断队列是否满</span><br>        <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 入队队列满，等待时间为0，则入队失败，返回false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果队列满，等待时间大于0，且未到等待时间，则继续等待nanos</span><br>            nanos = notFull.awaitNanos(nanos);<br>        &#125;<br>        <span class="hljs-comment">// 队列不满，进行入队操作</span><br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，我们重点看下 <code>while</code> 循环中判断队列是否满的条件：</p><ul><li>当队列满时，则首先判断剩余等待时间是否为0，如果为0表示已经到了等待时间，此时入队失败，直接返回 <code>false</code></li><li>当剩余等待时间大于0时，则需要继续等待，即调用 <code>nanos = notFull.awaitNanos(nanos)</code>，当该线程被唤醒时，<code>awaitNanos </code> 会返回剩余的等待时间 <em>nanos</em>，根据 <em>nanos</em> 则可以判断是否已经到等待时间</li></ul><p>在出队方法 <code>poll(time, unit)</code> 方法中，实现逻辑类似，这里不再赘述，有兴趣的小伙伴可以自行查看源码研究哦。</p><h5 id="ArrayBlockingQueue-原理总结"><a href="#ArrayBlockingQueue-原理总结" class="headerlink" title="ArrayBlockingQueue 原理总结"></a>ArrayBlockingQueue 原理总结</h5><ul><li>ArrayBlockingQueue 是一个有界阻塞队列，初始化时需要指定容量大小</li><li>在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用 ArrayBlockingQueue 是个不错选择；当如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞</li><li>使用独占锁 ReentrantLock 实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈</li></ul><h4 id="LinkedBlockingQueue的用法和原理"><a href="#LinkedBlockingQueue的用法和原理" class="headerlink" title="LinkedBlockingQueue的用法和原理"></a>LinkedBlockingQueue的用法和原理</h4><h5 id="LinkedBlockingQueue类定义"><a href="#LinkedBlockingQueue类定义" class="headerlink" title="LinkedBlockingQueue类定义"></a>LinkedBlockingQueue类定义</h5><p><img src="/posts/29247/image-20230726190624089.png" alt="image-20230726190624089"></p><p>LinkedBlockingQueue实现了BlockingQueue接口，并继承了AbstractQueue类，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br><br><span class="hljs-comment">/** 队列的容量，如果不传则默认Integer.MAX_VALUE */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-comment">/** 当前队列中元素数量 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表的头指针，head.item = null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表的尾指针 last.next = null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">/** 出队操作锁 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** 出队条件：非空队列 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">/** 入队锁 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** 入队条件：非满队列 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在LinkedBlockingQueue中定义的变量及其含义如下：</p><ul><li><code>capacity</code>：该变量表示队列的容量，设置该值则变为一个有界队列；如果不设置的话默认取值为Integer.MAX_VALUE，也可以认为是无界队列</li><li><code>count</code>：当前队列中元素的数量</li><li><code>head</code>和<code>last</code>：分别表示链表的头尾节点，其中头结点<code>head</code>不存储元素，<code>head.item = null</code></li><li><code>takeLock</code>和<code>notEmpty</code>：出队的锁以及出队条件</li><li><code>putLock</code>和<code>notFull</code>：入队的锁以及入队条件</li></ul><p>可以看出与<code>ArrayBlockingQueue</code>不同的是，在<code>LinkedBlockingQueue</code>中，入队和出队分别使用两个锁，两个锁可以分别认为是毒写锁和读锁，这里的具体原因在后面会进行详细描述</p><h5 id="链表节点定义"><a href="#链表节点定义" class="headerlink" title="链表节点定义"></a>链表节点定义</h5><p><code>LinkedBlockingQueue</code>是基于链表实现的，所以链表的节点定义如下，在<code>Node&lt;E&gt;</code>节点中分别定义了元素<code>item</code>以及后继节点<code>next</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br><br>    <span class="hljs-comment">// 后继节点，</span><br>    Node&lt;E&gt; next;<br><br>    Node(E x) &#123; item = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="构造方法定义"><a href="#构造方法定义" class="headerlink" title="构造方法定义"></a>构造方法定义</h5><p>然后我们再来看一下构造方法定义，在<code>LinkedBlockingQueue</code>中提供了三个构造方法，分别是默认构造方法、指定队列容量的构造方法、基于集合的构造方法；</p><p>在构造方法中，需要设置队列的容量，并初始化链表的头尾节点；基于集合的构造方法，会根据输入的集合，构建一个非空的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认构造方法，队列容量为Integer.MAX_VALUE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指定队列容量的构造方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    <span class="hljs-comment">// 初始化链表的头尾节点</span><br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于集合构建队列，默认容量为Integer.MAX_VALUE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>    putLock.lock(); <span class="hljs-comment">// Never contended, but necessary for visibility</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (E e : c) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>            <span class="hljs-keyword">if</span> (n == capacity)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>            enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e));<br>            ++n;<br>        &#125;<br>        count.set(n);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="入队逻辑-1"><a href="#入队逻辑-1" class="headerlink" title="入队逻辑"></a>入队逻辑</h5><p><strong>put 方法定义如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-comment">// Note: convention in all put/take/etc is to preset local var</span><br>        <span class="hljs-comment">// holding count negative to indicate failure unless set.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>        <span class="hljs-comment">//获得添加锁，</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>        <span class="hljs-comment">//获得当前队列中的元素数量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>        putLock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果当前队列中元素的数量等于队列的容量，则阻塞当前线程，</span><br>            <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>                notFull.await();<br>            &#125;<br>            enqueue(node);<br>            <span class="hljs-comment">//当前线程中元素数量增1，返回操作前的数量</span><br>            c = count.getAndIncrement();<br>            <span class="hljs-comment">//c+1其实是当前队列中元素的数量，如果比容量小，则唤醒notFull的操作，即可以进行继续添加，执行put等添加操作。</span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>                notFull.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            putLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">//说明在执行enqueue前的数量为0，执行完enqueue后数量为1,则需要唤醒取进程。</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            signalNotEmpty();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>put(e)</code> 方法的执行步骤大体如下，</p><ul><li>判断要put的元素e是否为null，如果为null直接抛出空指针异常；</li><li>e不为null，则使用e创建一个Node节点，获得put锁；</li><li>判断当前队列中的元素数量和队列的容量，如果相等，则阻塞当前线程；</li><li>如果不相等，把生成的node节点插入队列，enqueue方法定义如下，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>        <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert last.next == null;</span><br>        last = last.next = node;<br>    &#125;<br><br><span class="hljs-comment">// 在enqueue(node)操作中，就是将插入节点设置为尾结点的next节点，也就是last.next = node，然后再修改尾结点为新插入的节点，即：last = last.next，完成了入队节点的插入操作</span><br></code></pre></td></tr></table></figure><ul><li>使用原子操作类把当前队列中的元素数量增1；如果添加后的队列中的元素数量比容量小，则表示可以继续执行put类的操作，唤醒notFull.singal()；</li><li>如果c&#x3D;0，即在enqueue前为空，数量为0（此时会阻塞take进程），enqueue后为1，则需要唤醒take进程，如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNotEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>        takeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            notEmpty.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            takeLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>offer</strong> 方法</p><p>offer方法的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>        <span class="hljs-keyword">if</span> (count.get() == capacity)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>        putLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (count.get() &lt; capacity) &#123;<br>                enqueue(node);<br>                c = count.getAndIncrement();<br>                <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>                    notFull.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            putLock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            signalNotEmpty();<br>        <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此方法的执行步骤大体如下，</p><ul><li>判断当前队列中的元素数量和队列容量，如果相等，直接返回false；</li><li>如果当前队列中元素数量小于队列容量，执行入队操作；</li><li>入队操作之后，判断队列中元素数量如果仍小于队列容量，唤醒其他的阻塞线程；</li><li>如果c&#x3D;&#x3D;0（即入队成功，队列中元素的数量为1），则需要唤醒阻塞在put锁的线程；</li></ul><p><strong>add</strong></p><p>在 <code>LinkedBlockingQueue </code>中，由于继承了 <code>AbstractQueue</code> 类，所以<code>add</code>方法也是使用的<code>AbstractQueue</code>中的定义，代码如下；<code>add</code>方法直接调用了<code>offer(E e)</code>方法，并判断是否入队成功，如果入队失败则抛出 <code>IllegalStateException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 直接调用offer(e)方法进行入队</span><br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-comment">// 入队成功：返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 入队失败：抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="出队逻辑-1"><a href="#出队逻辑-1" class="headerlink" title="出队逻辑"></a>出队逻辑</h5><p>take方法和put刚好相反，其定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        E x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//获得当前队列的元素数量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>        <span class="hljs-comment">//获得take锁</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>        <span class="hljs-comment">//执行take操作</span><br>        takeLock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>                notEmpty.await();<span class="hljs-comment">//阻塞当前线程</span><br>            &#125;<br>            x = dequeue();<br>            <span class="hljs-comment">//当前队列的数量减1，返回操作前的数量</span><br>            c = count.getAndDecrement();<br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>                notEmpty.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            takeLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">//当前队列中元素数量为capacity-1，即未满，可以调用put方法，需要唤醒阻塞在put锁上的线程</span><br>        <span class="hljs-keyword">if</span> (c == capacity)<br>            signalNotFull();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br></code></pre></td></tr></table></figure><p> 此方法的执行步骤大体如下，</p><ul><li>获得take锁，表示执行take操作；</li><li>获得当前队列的元素数量，如果数量为0，则阻塞当前线程，直到被中断或者被唤醒；</li><li>如果当前队列的元素数量不额外i0，则执行出队操作；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert head.item == null;</span><br>        Node&lt;E&gt; h = head;<span class="hljs-comment">//head赋值给h</span><br>        Node&lt;E&gt; first = h.next;<span class="hljs-comment">//相当于第二个节点赋值给first</span><br>        h.next = h; <span class="hljs-comment">// help GC</span><br>        head = first;<span class="hljs-comment">//头节点指向第二个节点</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>        first.item = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出把头节点进行出队，即head指向下一个节点</p><ul><li>当前队列的元素数量减一，并返回操作前的数量；</li><li>如果之前大于1（c最小为2），指向dequeue后数量最小为1，证明队列中仍有元素，需要唤醒获得take锁的其他阻塞线程，take.singal()；</li><li>如果c等于当前队列的容量（执行完dequeue后，当前队列中元素的数量等于capacity-1，则未满），则需要唤醒获得put锁的其他put线程；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNotFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>        putLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//唤醒阻塞在put锁的其他线程</span><br>            notFull.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            putLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>poll</strong></p><p>poll方法定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>        <span class="hljs-keyword">if</span> (count.get() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>        takeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (count.get() &gt; <span class="hljs-number">0</span>) &#123;<br>                x = dequeue();<br>                c = count.getAndDecrement();<br>                <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>                    notEmpty.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            takeLock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == capacity)<br>            signalNotFull();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此方法的执行步骤大体如下，</p><ul><li>如果当前队列元素数量为0，直接返回null</li><li>如果当前队列元素数量大于0，执行出队操作</li><li>如果c&gt;1，即c最小为2，则出队成功后，仍有1个元素，可以唤醒阻塞在take锁的线程</li><li>如果c&#x3D;capacity，则出队成功后，队列中的元素为capacity-1，这时队列为满，可以唤醒阻塞在put锁上的其他线程，即可以添加元素</li></ul><p><strong>remove</strong></p><p>在 <code>LinkedBlockingQueue</code>中，<code>remove</code> 方法也是直接使用的父类 <code>AbstractQueue</code> 中的 <code>remove</code> 方法，代码如下；<code>remove</code> 方法直接调用了 <code>poll()</code> 方法，如果出队成功则返回出队元素，出队失败则抛出<code>NoSuchElementException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用poll()方法进行出队</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll();<br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 出队成功：返回出队元素</span><br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 出队失败：抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedBlockingQueue-对比-ArrayBlockingQueue"><a href="#LinkedBlockingQueue-对比-ArrayBlockingQueue" class="headerlink" title="LinkedBlockingQueue 对比 ArrayBlockingQueue"></a>LinkedBlockingQueue 对比 ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>中，使用了一个 <code>ReentrantLock lock</code> 作为入队和出队的锁，并使用两个条件 <code>notEmpty</code> 和 <code>notFull</code> 来进行线程间通信。而在本文介绍的 <code>LinkedBlockingQueue</code>中，使用了两个锁 <code>putLock</code> 和 <code>takeLock</code> 分别作为入队和出队的锁，同样使用了两个锁的两个条件 <code>notFull</code> 和 <code>notEmpty</code> 进行线程间通信</p><p>由于在 <code>ArrayBlockingQueue</code> 中，入队和出队操作共用了同一个锁，所以两个操作之间会有相互影响；而在 <code>LinkedBlockingQueue</code> 中，入队和出队操作分别使用不同的锁，则入队和出队互不影响，可以提供队列的操作性能</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>BlockingQueue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>BlockingQueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS 共享模式的使用</title>
    <link href="/posts/22432.html"/>
    <url>/posts/22432.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章的关注点是 AQS 最后的部分，<strong>AQS 共享模式</strong>的使用</p><span id="more"></span><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p><h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p><p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p><p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver2</span> &#123; <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// 创建 N 个任务，提交给线程池来执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span><br>            e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerRunnable</span>(doneSignal, i));<br><br>        <span class="hljs-comment">// 等待所有的任务完成，这个方法才会返回</span><br>        doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> i;<br><br>    WorkerRunnable(CountDownLatch doneSignal, <span class="hljs-type">int</span> i) &#123;<br>        <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>        <span class="hljs-built_in">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doWork(i);<br>            <span class="hljs-comment">// 这个线程的任务完成了，调用 countDown 方法</span><br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>        &#125; <span class="hljs-comment">// return;</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123; ...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p><p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123; <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(startSignal, doneSignal)).start();<br><br>        <span class="hljs-comment">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span><br>        doSomethingElse();            <span class="hljs-comment">// don&#x27;t let run yet</span><br>        <span class="hljs-comment">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span><br>        startSignal.countDown();      <span class="hljs-comment">// let all threads proceed</span><br>        doSomethingElse();<br>        <span class="hljs-comment">// 等待所有任务结束</span><br>        doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br><br>    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;<br>        <span class="hljs-built_in">this</span>.startSignal = startSignal;<br>        <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span><br>            <span class="hljs-comment">// 等大家都准备好了，再打开这个门栓</span><br>            startSignal.await();<br>            doWork();<br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>        &#125; <span class="hljs-comment">// return;</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123; ...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p><p><img src="/posts/22432/5.png" alt="5"></p><p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>Talk is cheap, show me the code.</p><p>构造方法，需要传入一个不小于 0 的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>    <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>&#125;<br><span class="hljs-comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    Sync(<span class="hljs-type">int</span> count) &#123;<br>        <span class="hljs-comment">// 这样就 state == count 了</span><br>        setState(count);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state &#x3D; state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p></blockquote><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p><p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state &#x3D;&#x3D; 0），将线程从队列中一个个唤醒过来。</p><p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span><br>                latch.countDown();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span><br>                latch.countDown();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 阻塞，等待 state 减为 0</span><br>                    latch.await();<br>                    System.out.println(<span class="hljs-string">&quot;线程 t3 从 await 中返回了&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程 t3 await 被中断&quot;</span>);<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 阻塞，等待 state 减为 0</span><br>                    latch.await();<br>                    System.out.println(<span class="hljs-string">&quot;线程 t4 从 await 中返回了&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程 t4 await 被中断&quot;</span>);<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>);<br><br>        t3.start();<br>        t4.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">线程 t3 从 await 中返回了<br>线程 t4 从 await 中返回了<br></code></pre></td></tr></table></figure><blockquote><p>这两条输出，顺序不是绝对的</p><p>后面的分析，我们假设 t3 先进入阻塞队列</p></blockquote><p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p><p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><br>    <span class="hljs-comment">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span><br>    <span class="hljs-comment">// 也就是说，这个 if 返回 true，然后往里看</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br><span class="hljs-comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 1. 入队</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 2</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p><p><img src="/posts/22432/2.png" alt="2"></p><p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;&#x3D; 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p><p><img src="/posts/22432/3.png" alt="3"></p><p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p><p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p><p><img src="/posts/22432/4.png" alt="4"></p><p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p><p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p><p><img src="/posts/22432/1.png" alt="1"></p><p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p><p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span><br>    <span class="hljs-comment">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span><br>    <span class="hljs-comment">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        <span class="hljs-comment">// 唤醒 await 的线程</span><br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用这个方法的时候，state == 0</span><br><span class="hljs-comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// 将 head 的 waitStatue 设置为 0</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                <span class="hljs-comment">// 在这里，也就是唤醒 t3</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE)) <span class="hljs-comment">// todo</span><br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r); <span class="hljs-comment">// 2. 这里是下一步</span><br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                <span class="hljs-comment">// 1. 唤醒后这个方法返回</span><br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br><br>    <span class="hljs-comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span><br>    <span class="hljs-comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>            <span class="hljs-comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span><br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用这个方法的时候，state == 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 1. h == null: 说明阻塞队列为空</span><br>        <span class="hljs-comment">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span><br>        <span class="hljs-comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br>        <span class="hljs-comment">// 所以这两种情况不需要进行唤醒后继节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// 这里 CAS 失败的场景请看下面的解读</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                <span class="hljs-comment">// 在这里，也就是唤醒 t4</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     <span class="hljs-comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span><br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span><br>        <span class="hljs-comment">// 否则，就是 head 没变，那么退出循环，</span><br>        <span class="hljs-comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span><br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p><ol><li>h &#x3D;&#x3D; head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li><li>h !&#x3D; head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li></ol><p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p><p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p><p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h &#x3D;&#x3D; head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p><p><img src="/posts/22432/cyclicbarrier-2.png" alt="cyclicbarrier-2"></p><p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p><p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p><p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p><p><img src="/posts/22432/cyclicbarrier-3.png" alt="cyclicbarrier-3"></p><blockquote><p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p></blockquote><p>大家先把图看完，然后我们开始源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrier</span> &#123;<br>    <span class="hljs-comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;，或者&quot;一个周期&quot;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** The lock for guarding barrier entry */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">// CyclicBarrier 是基于 Condition 的</span><br>    <span class="hljs-comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 参与的线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><br>    <span class="hljs-comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br><br>    <span class="hljs-comment">// 当前所处的“代”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br><br>    <span class="hljs-comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span><br>    <span class="hljs-comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        <span class="hljs-built_in">this</span>.parties = parties;<br>        <span class="hljs-built_in">this</span>.count = parties;<br>        <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>        <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先，先看怎么开启新的一代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span><br>    trip.signalAll();<br>    <span class="hljs-comment">// 更新 count 的值</span><br>    count = parties;<br>    <span class="hljs-comment">// 重新生成“新一代”</span><br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p></blockquote><p>看看怎么打破一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 设置状态 broken 为 true</span><br>    generation.broken = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 重置 count 为初始值 parties</span><br>    count = parties;<br>    <span class="hljs-comment">// 唤醒所有已经在等待的线程</span><br>    trip.signalAll();<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不带超时机制</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException,<br>           BrokenBarrierException,<br>           TimeoutException &#123;<br>    <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">true</span>, unit.toNanos(timeout));<br>&#125;<br></code></pre></td></tr></table></figure><p>继续往里看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>               TimeoutException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span><br>    <span class="hljs-comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br>        <span class="hljs-comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span><br>        <span class="hljs-keyword">if</span> (g.broken)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br>        <span class="hljs-comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            breakBarrier();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>        <span class="hljs-comment">// index 是这个 await 方法的返回值</span><br>        <span class="hljs-comment">// 注意到这里，这个是从 count 递减后得到的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br><br>        <span class="hljs-comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                    command.run();<br>                <span class="hljs-comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span><br>                ranAction = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 唤醒等待的线程，然后开启新的一代</span><br>                nextGeneration();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ranAction)<br>                    <span class="hljs-comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span><br>                    <span class="hljs-comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span><br>                    breakBarrier();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>        <span class="hljs-comment">// 如果是最后一个线程调用 await，那么上面就返回了</span><br>        <span class="hljs-comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span><br>                <span class="hljs-keyword">if</span> (!timed)<br>                    trip.await();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                    nanos = trip.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                <span class="hljs-comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span><br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                    <span class="hljs-comment">// 打破栅栏</span><br>                    breakBarrier();<br>                    <span class="hljs-comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span><br>                    <span class="hljs-keyword">throw</span> ie;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span><br>                    <span class="hljs-comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span><br>                    <span class="hljs-comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span><br>                    <span class="hljs-comment">// 而是之后抛出 BrokenBarrierException 异常</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br><br>              <span class="hljs-comment">// 唤醒后，检查栅栏是否是“破的”</span><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-comment">// 这个 for 循环除了异常，就是要从这里退出了</span><br>            <span class="hljs-comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span><br>            <span class="hljs-comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span><br>            <span class="hljs-comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span><br>            <span class="hljs-comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span><br>            <span class="hljs-comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span><br>            <span class="hljs-keyword">if</span> (g != generation)<br>                <span class="hljs-keyword">return</span> index;<br><br>            <span class="hljs-comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p><p>下面开始收尾工作。</p><p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberWaiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> parties - count;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBroken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> generation.broken;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p><ol><li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li><li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li><li>指定执行的操作抛出了异常，这个我们前面也说过。</li></ol><p>最后，我们来看看怎么重置一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        breakBarrier();   <span class="hljs-comment">// break the current generation</span><br>        nextGeneration(); <span class="hljs-comment">// start a new generation</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们设想一下，如果初始化时，指定了线程 parties &#x3D; 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p><p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p><p>怎么样，CyclicBarrier 源码很简单吧。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p><p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p><p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state &#x3D; state - 1，release 的时候执行 state &#x3D; state + 1，当然，acquire  的时候，如果 state &#x3D; 0，说明没有资源了，需要等待其他线程 release。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p><p>看 acquire 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireSharedInterruptibly(<span class="hljs-keyword">permits</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireShared(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p><p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平策略：</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span><br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非公平策略：</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p><p>我们再回到 acquireShared 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务介绍，释放一个资源</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-comment">// 溢出，当然，我们一般也不会用这么大的数</span><br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧</p><blockquote><p>参考：<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">https://javadoop.com/post/AbstractQueuedSynchronizer-3</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>AQS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS 更多实现</title>
    <link href="/posts/19866.html"/>
    <url>/posts/19866.html</url>
    
    <content type="html"><![CDATA[<p>上文介绍了 AQS 的原理，以及 ReentrantLock 中对 AQS 的使用，现在来说说 AQS 的更多实现</p><span id="more"></span><p>本文关注以下几点内容：</p><ol><li><code>ReentrantLock</code> 公平锁和非公平锁的区别</li><li><code>Condition</code> 的原理</li><li><em>AQS</em> 中的取消排队</li><li>Java 线程中断和 <code>InterruptedException</code> 异常</li></ol><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p><code>ReentrantLock</code> 默认采用非公平锁，除非你在构造方法中传入参数 true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 默认非公平锁</span><br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 这里没有对阻塞队列进行判断</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态</p><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>先来看一下生产者-消费者模式的例子，使用 <code>Condition</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[BUFFER_SIZE];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == BUFFER_SIZE) &#123;<br>                <span class="hljs-comment">// 缓冲区已满，等待不满的条件</span><br>                notFull.await();<br>            &#125;<br><br>            buffer[count] = value;<br>            System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + value);<br>            count++;<br><br>            <span class="hljs-comment">// 唤醒等待非空条件的消费者</span><br>            notEmpty.signal();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 缓冲区为空，等待非空的条件</span><br>                notEmpty.await();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> buffer[count - <span class="hljs-number">1</span>];<br>            System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + value);<br>            count--;<br><br>            <span class="hljs-comment">// 唤醒等待不满条件的生产者</span><br>            notFull.signal();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 <code>wait()</code>， <code>notify()</code> 或 <code>notifyAll()</code> 方法。</p><p>2、<code>ArrayBlockingQueue</code> 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 <code>ArrayBlockingQueue</code></p></blockquote><p>我们常用 <code>obj.wait()</code>，<code>obj.notify()</code> 或 <code>obj.notifyAll()</code> 来实现相似的功能，但是，它们是基于对象的监视器锁的。而这里说的 <strong>Condition</strong> 是基于 <strong>ReentrantLock</strong> 实现的，而 ReentrantLock 是依赖于 <em>AbstractQueuedSynchronizer</em> 实现的。Condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong></p><p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 实例化一个 ConditionObject</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br>        <span class="hljs-comment">// 条件队列的第一个节点</span><br>          <span class="hljs-comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>        <span class="hljs-comment">// 条件队列的最后一个节点</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>        ......<br></code></pre></td></tr></table></figure><p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p><blockquote><p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p></blockquote><p><img src="/posts/19866/aqs2-2.png" alt="condition-2"></p><blockquote><p>这里，我们简单回顾下 Node 的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus; <span class="hljs-comment">// 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><span class="hljs-keyword">volatile</span> Node next;<br><span class="hljs-keyword">volatile</span> Thread thread;<br>Node nextWaiter;<br></code></pre></td></tr></table></figure><p>prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表</p></blockquote><p>基本上，把这张图看懂也就知道 condition 的处理流程了：</p><ol><li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的</li><li>我们知道一个 ReentrantLock 实例可以通过多次调用 <code>newCondition()</code> 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 <code>firstWaiter</code> 和 <code>lastWaiter</code></li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li><li>调用 <code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ol><p>上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。</p><p>按照流程来走代码分析，再来看看 wait 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span><br><span class="hljs-comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><br>    <span class="hljs-comment">// 添加到 condition 的条件队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br><br>    <span class="hljs-comment">// 释放锁，返回值是释放锁之前的 state 值</span><br>    <span class="hljs-comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里退出循环有两种情况，之后再仔细分析</span><br>    <span class="hljs-comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span><br>    <span class="hljs-comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们分步把上面的几个点用源码说清楚</p><ol><li><h5 id="将节点加入到条件队列"><a href="#将节点加入到条件队列" class="headerlink" title="将节点加入到条件队列"></a>将节点加入到条件队列</h5></li></ol><p><code>addConditionWaiter()</code> 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将当前线程对应的节点入队，插入队尾</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span><br>    <span class="hljs-comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        <span class="hljs-comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span><br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br><br>    <span class="hljs-comment">// t 此时是 lastWaiter，队尾</span><br>    <span class="hljs-comment">// 如果队列为空</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这块代码很简单，就是将当前线程进入到条件队列的队尾</p><p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。当 await 的时候如果发生了<strong>取消操作</strong>（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span><br><span class="hljs-comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;<br>        <span class="hljs-comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>                firstWaiter = next;<br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-完全释放独占锁"><a href="#2-完全释放独占锁" class="headerlink" title="2. 完全释放独占锁"></a>2. 完全释放独占锁</h5><p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p><blockquote><p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span><br><span class="hljs-comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span><br><span class="hljs-comment">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span><br><span class="hljs-comment">//         相应的，如果 lock 重入了 n 次，savedState == n</span><br><span class="hljs-comment">// 如果这个方法失败，会将节点设置为&quot;取消&quot;状态，并抛出异常 IllegalMonitorStateException</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span><br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p></blockquote><h5 id="3-等待进入阻塞队列"><a href="#3-等待进入阻塞队列" class="headerlink" title="3. 等待进入阻塞队列"></a>3. 等待进入阻塞队列</h5><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>    <span class="hljs-comment">// 线程挂起</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span><br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>isOnSyncQueue(Node node)</code> 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span><br><span class="hljs-comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span><br><span class="hljs-comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;<br><br>    <span class="hljs-comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span><br>    <span class="hljs-comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span><br>    <span class="hljs-comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span><br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span><br><br>    <span class="hljs-comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span><br>    <span class="hljs-comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span><br>    <span class="hljs-comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span><br><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br><br><span class="hljs-comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNodeFromTail</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (t == node)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        t = t.prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起</p><h5 id="4-signal-唤醒线程，转移到阻塞队列"><a href="#4-signal-唤醒线程，转移到阻塞队列" class="headerlink" title="4. signal 唤醒线程，转移到阻塞队列"></a>4. signal 唤醒线程，转移到阻塞队列</h5><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。唤醒操作通常由另一个线程来操作，就像<strong>生产者-消费者</strong>模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒等待了最久的线程</span><br><span class="hljs-comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用 signal 方法的线程必须持有当前的独占锁</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span><br><span class="hljs-comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span><br>        <span class="hljs-comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            lastWaiter = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>      <span class="hljs-comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span><br>&#125;<br><br><span class="hljs-comment">// 将节点从条件队列转移到阻塞队列</span><br><span class="hljs-comment">// true 代表成功转移</span><br><span class="hljs-comment">// false 代表在 signal 之前，节点已经取消了</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><br>    <span class="hljs-comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span><br>    <span class="hljs-comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span><br>    <span class="hljs-comment">// 否则，将 waitStatus 置为 0</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// enq(node): 自旋进入阻塞队列的队尾</span><br>    <span class="hljs-comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span><br>    <span class="hljs-comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        <span class="hljs-comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span><br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;&#x3D; 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可</p><h5 id="5-唤醒后检查中断状态"><a href="#5-唤醒后检查中断状态" class="headerlink" title="5. 唤醒后检查中断状态"></a>5. 唤醒后检查中断状态</h5><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。等线程从挂起中恢复过来，继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>    <span class="hljs-comment">// 线程挂起</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span><br><span class="hljs-comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span><br><span class="hljs-comment">// 3. 没有发生中断，返回 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只有线程处于中断状态，才会调用此方法</span><br><span class="hljs-comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span><br><span class="hljs-comment">// 返回 true：如果此线程在 signal 之前被取消，</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 用 CAS 将节点状态设置为 0 </span><br>    <span class="hljs-comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// 将节点放入阻塞队列</span><br>        <span class="hljs-comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span><br>    <span class="hljs-comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span><br>    <span class="hljs-comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))<br>        Thread.<span class="hljs-keyword">yield</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功</p><p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列</p><h5 id="6-获取独占锁"><a href="#6-获取独占锁" class="headerlink" title="6. 获取独占锁"></a>6. 获取独占锁</h5><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>    interruptMode = REINTERRUPT;<br></code></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state &#x3D;&#x3D; savedState了</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode !&#x3D; THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>    unlinkCancelledWaiters();<br><span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>    reportInterruptAfterWait(interruptMode);<br></code></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter &#x3D; null，将断开节点和条件队列的联系</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter &#x3D; null 的</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了</p><h5 id="7-处理中断状态"><a href="#7-处理中断状态" class="headerlink" title="7. 处理中断状态"></a>7. 处理中断状态</h5><p>interruptMode 作用：</p><ul><li>0：什么都不做，没有被中断过；</li><li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li><li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了</p></blockquote><h5 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="带超时机制的 await"></a>带超时机制的 await</h5><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <br>                  <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br>                <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br>                <span class="hljs-keyword">throws</span> InterruptedException<br></code></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 等待这么多纳秒</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-comment">// 当前时间 + 等待时长 = 过期时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-comment">// 用于返回 await 是否超时</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">// 时间到啦</span><br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span><br>            <span class="hljs-comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span><br>            <span class="hljs-comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span><br>            timedout = transferAfterCancelledWait(node);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span><br>        <span class="hljs-comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span><br>        <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 得到剩余时间</span><br>        nanosTimeout = deadline - System.nanoTime();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>    <span class="hljs-keyword">return</span> !timedout;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁</p><h5 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="不抛出 InterruptedException 的 await"></a>不抛出 InterruptedException 的 await</h5><p>关于 Condition 最后一小节了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AbstractQueuedSynchronizer-独占锁的取消排队"><a href="#AbstractQueuedSynchronizer-独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer 独占锁的取消排队"></a>AbstractQueuedSynchronizer 独占锁的取消排队</h4><p><strong>如何取消对锁的竞争</strong></p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会</p><hr><p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        doAcquireInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span><br>                <span class="hljs-comment">// 这里不再只是标记这个方法的返回值代表中断状态</span><br>                <span class="hljs-comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    node.thread = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    <span class="hljs-comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            unparkSuccessor(node);<br>        &#125;<br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 <code>waitStatus</code> 设置为 <code>Node.CANCELLED</code>，会有非常多的情况被从阻塞队列中请出去，主动或被动</p><h4 id="Java-线程中断和-InterruptedException-异常"><a href="#Java-线程中断和-InterruptedException-异常" class="headerlink" title="Java 线程中断和 InterruptedException 异常"></a>Java 线程中断和 InterruptedException 异常</h4><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false</p><blockquote><p>Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p></blockquote><p>关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span><br><span class="hljs-comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span><br><span class="hljs-comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>   doWork();<br>   System.out.println(<span class="hljs-string">&quot;我做完一件事了，准备做下一件，如果没有其他线程中断我的话&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。</p></blockquote><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p><p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p><ol><li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p><p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p><blockquote><p>这几个方法的相同之处是，方法上都有: throws InterruptedException </p><p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p></blockquote></li><li><p>实现了 InterruptibleChannel 接口的类中的一些 I&#x2F;O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p><blockquote><p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p></blockquote></li><li><p>Selector 中的 select 方法，参考下我写的 NIO 的文章</p><blockquote><p>一旦中断，方法立即返回</p></blockquote></li></ol><p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong></p><p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true</p><h5 id="InterruptedException-概述"><a href="#InterruptedException-概述" class="headerlink" title="InterruptedException 概述"></a>InterruptedException 概述</h5><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）</p><p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等</p><p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现</p><p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了</p><h5 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h5><p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题</p><p>我们经常会这么写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">10000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// ignore</span><br>&#125;<br><span class="hljs-comment">// go on </span><br></code></pre></td></tr></table></figure><p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p><p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        <span class="hljs-comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span><br>        <span class="hljs-comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span><br>        selfInterrupt();<span class="hljs-comment">// Thread.currentThread().interrupt();</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常</p><p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>     ...... <br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码</p><blockquote><p>参考：<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">https://javadoop.com/post/AbstractQueuedSynchronizer-2</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>AQS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS 原理分析</title>
    <link href="/posts/13119.html"/>
    <url>/posts/13119.html</url>
    
    <content type="html"><![CDATA[<p><strong>AQS</strong> (<em>Abstract Queued Synchronizer</em>)，它是 Java 中 <code>java.util.concurrent</code> 包下的一种基础框架，用于实现各种同步机制，特别是用于多线程编程中的同步操作</p><span id="more"></span><p><em>AQS</em> 提供了一种基于 <em>FIFO</em>（先进先出）队列的抽象同步器，可以方便地实现各种同步工具，比如锁、信号量、倒计时器等。在 Java 中，<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>等都是使用 <em>AQS</em> 实现的</p><p><em>AQS</em> 的核心思想是使用一个等待队列来管理线程的竞争和等待状态。当线程试图获取锁或资源时，如果资源已经被占用，线程将被放入等待队列中，进入等待状态。当资源释放时，AQS会自动唤醒等待队列中的第一个线程，使其重新尝试获取资源</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ol><li><strong>继承 Thread 类</strong></li></ol><p>这是最常见的创建线程的方式。你可以创建一个继承自Thread类的子类，并重写其run()方法来定义线程要执行的任务。然后通过调用子类的start()方法来启动线程</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 启动线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实现 Runnable 接口</strong></li></ol><p>这是另一种常见的创建线程的方式，它更加灵活，因为Java是单继承的，如果已经继承了其他类，就无法再继承Thread类了。通过实现Runnable接口，你可以在同一个类中实现多个任务，同时也可以共享数据</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 启动线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>实现 Callable 接口</strong></li></ol><p>Callable接口与Runnable接口类似，但是它可以返回计算结果，并且可以抛出异常。通过FutureTask类可以包装Callable，使其成为一个Runnable。与Runnable不同，Callable在执行时可以返回一个值</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务，并返回一个结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 启动线程</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>使用 Executor 框架：</strong></li></ol><p>Java 提供了 Executor 框架，它是一种更高级别的线程管理方式，通过线程池来管理线程的创建和回收，从而提高性能并避免频繁地创建和销毁线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 提交任务给线程池</span><br>executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>Future&lt;Integer&gt; future = executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br></code></pre></td></tr></table></figure><h4 id="LockSupport-的使用"><a href="#LockSupport-的使用" class="headerlink" title="LockSupport 的使用"></a>LockSupport 的使用</h4><p><code>LockSupport</code> 是 Java 中的一个工具类，用于线程的阻塞和唤醒。它提供了与 Java 对象监视器（<em><strong>synchronized</strong></em> 关键字）相似的功能，但是更加灵活和强大。<code>LockSupport</code> 可以在任意位置对线程进行阻塞和唤醒，而不需要依赖于特定的对象锁</p><p><code>LockSupport</code> 的主要方法包括：</p><ol><li><p><code>park()</code>: 当前线程阻塞，直到被其他线程调用<code>unpark()</code>方法唤醒，或者被中断<code>Thread.interrupt()</code></p></li><li><p><code>park(Object blocker)</code>: 可以传入一个<code>blocker</code>对象，用于标识阻塞的原因，便于调试和监控</p></li><li><p><code>unpark(Thread thread)</code>: <strong>唤醒指定的线程</strong>，如果该线程之前没有被阻塞，那么下一次调用 <code>park()</code> 方法时，它将不会被阻塞</p></li></ol><p><code>LockSupport</code> 的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread starts.&quot;</span>);<br>            <span class="hljs-comment">// 阻塞当前线程</span><br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;Thread is awakened.&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 等待一段时间</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 唤醒线程</span><br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个新的线程，并在其中使用 <code>LockSupport.park()</code> 阻塞该线程。然后在主线程中经过一段时间后，使用 <code>LockSupport.unpark(thread)</code> 唤醒被阻塞的线程。</p><p>需要注意的是，<code>LockSupport</code> 不是基于锁的机制，它没有像 <strong><code>synchronized</code></strong> 那样的锁定和释放过程，而是直接对线程进行阻塞和唤醒。因此，在使用 <code>LockSupport</code> 时要特别小心，避免造成死锁等问题。通常，<code>LockSupport</code> 用于高级并发工具的实现，比如 <code>ReentrantLock</code> 和 <code>ThreadPoolExecutor</code> 等</p><h4 id="ReentrantLock-的使用"><a href="#ReentrantLock-的使用" class="headerlink" title="ReentrantLock 的使用"></a>ReentrantLock 的使用</h4><p><code>ReentrantLock </code> 是Java中 <code>java.util.concurrent.locks</code> 包下的一个可重入锁实现，它提供了与 <code>synchronized </code> 关键字类似的功能，但更加灵活和强大</p><p>以下是 <code>ReentrantLock</code> 的一些主要方法和用法：</p><ol><li><p><strong>创建ReentrantLock对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>获取锁：</strong><br><code>ReentrantLock </code>使用 <code>lock()</code> 方法获取锁，如果锁已经被其他线程占用，则当前线程会被阻塞，直到获取到锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock();<br><span class="hljs-comment">// 临界区代码</span><br>lock.unlock();<br></code></pre></td></tr></table></figure></li><li><p><strong>释放锁：</strong><br>使用 <code>unlock()</code> 方法释放锁。注意，为确保正确释放锁，应在 <code>finally</code> 块中使用 <code>unlock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可中断获取锁：</strong><br><code>ReentrantLock </code>提供了 <code>lockInterruptibly()</code>方法，该方法允许线程在获取锁的过程中被中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lockInterruptibly();<br><span class="hljs-comment">// 临界区代码</span><br>lock.unlock();<br></code></pre></td></tr></table></figure></li><li><p><strong>尝试获取锁：</strong><br><code>tryLock() </code>方法尝试获取锁，如果锁可用，则获取锁并返回 <code>true</code>，如果锁被其他线程占用，则立即返回 <code>false</code>，而不会阻塞当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (lock.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 临界区代码</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 锁获取失败，执行备用方案</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>获取等待的线程数：</strong><br><code>getQueueLength()</code> 方法可以获取当前等待获取锁的线程数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">waitingThreads</span> <span class="hljs-operator">=</span> lock.getQueueLength();<br></code></pre></td></tr></table></figure></li></ol><p><code>ReentrantLock</code> 提供了更多的方法和特性，如公平锁和条件等待，使得它更加灵活和适用于复杂的多线程场景。在使用 <code>ReentrantLock</code>时，需要注意遵循获取锁和释放锁的正确顺序，以避免死锁和竞态条件。同时，要确保在获取锁后一定要释放锁，以防止资源泄漏</p><p>一个简单的<code>ReentrantLock</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;<br>                performTask();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br><br>        thread1.start();<br>        thread2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            thread1.join();<br>            thread2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Final count: &quot;</span> + count);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTask</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>            System.out.println(<span class="hljs-string">&quot;Current count: &quot;</span> + count);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们有一个全局变量 <code>count</code>，两个线程通过调用 <code>performTask</code>方法来递增这个计数器。<code>performTask</code> 方法首先通过 <code>lock.lock()</code>获取锁，然后递增 <code>count</code>并输出当前的计数值，最后通过<code>lock.unlock()</code>释放锁</p><p>由于<code>ReentrantLock</code>是可重入的，这意味着同一个线程可以多次获取该锁而不会被阻塞。在上面的例子中，两个线程都会交替执行 <code>performTask</code> 方法（并不是严格的交替），每次递增计数器，而不会出现竞争条件。最后输出的<code>count</code>值应该是<code>MAX_COUNT * 2</code>，因为两个线程各自递增了5次</p><h4 id="模版方法设计模式"><a href="#模版方法设计模式" class="headerlink" title="模版方法设计模式"></a>模版方法设计模式</h4><p>模板方法（<em>Template Method</em>）是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤的具体实现延迟到子类中。这样，子类可以在不改变算法结构的情况下重新定义某些步骤的实现。模板方法模式遵循”开闭原则”，允许在不修改算法结构的情况下修改算法的具体实现</p><p>核心思想：</p><ol><li>定义一个抽象类，该抽象类包含一个模板方法，这个模板方法是一个算法的骨架，它由一系列的步骤组成，其中某些步骤的实现可以在子类中进行重定义</li><li>模板方法中的某些步骤可以是抽象方法，由子类负责具体实现</li><li>模板方法中的某些步骤可以是具体方法，已经有默认实现，子类可以选择是否覆盖这些方法</li><li>子类继承抽象类，并实现其中的抽象方法，从而提供特定的实现细节</li></ol><p>通过模板方法模式，将通用算法的结构和步骤定义在抽象类中，而具体实现交给子类完成，这样可以避免代码重复，并且保持算法的一致性。下面通过一个简单的例子来说明模板方法模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;<br>    <span class="hljs-comment">// 模板方法，定义了算法的骨架</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareRecipe</span><span class="hljs-params">()</span> &#123;<br>        boilWater();<br>        brew();<br>        pourInCup();<br>        addCondiments();<br>    &#125;<br><br>    <span class="hljs-comment">// 具体步骤由子类实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 公共的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Boiling water&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Pouring into cup&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Steeping the tea&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding lemon&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dripping coffee through filter&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding sugar and milk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateMethodExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CaffeineBeverage</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tea</span>();<br>        <span class="hljs-type">CaffeineBeverage</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coffee</span>();<br><br>        System.out.println(<span class="hljs-string">&quot;Making tea...&quot;</span>);<br>        tea.prepareRecipe();<br><br>        System.out.println(<span class="hljs-string">&quot;\nMaking coffee...&quot;</span>);<br>        coffee.prepareRecipe();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>CaffeineBeverage </code> 是一个抽象类，它定义了 <code>prepareRecipe</code> 作为模板方法，其中包含了煮水、冲泡、倒入杯子和加入调料等步骤。<code>brew  </code>和 <code>addCondiments</code> 是抽象方法，由具体的子类来实现。<code>boilWater  </code>和 <code>pourInCup </code>是具体方法，它们已经有默认实现，但也可以在子类中进行重定义</p><p><code>Tea  </code>和 <code>Coffee</code> 是具体的子类，它们继承了 <code>CaffeineBeverage</code>，并实现了其中的抽象方法。通过运行 <code>main</code> 方法，我们可以看到茶和咖啡的制作过程，它们都遵循了 <code>CaffeineBeverage</code> 定义的算法结构，但具体步骤有所不同</p><h3 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h3><p>AQS 内部属性包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 头结点，直接把它当做「当前持有锁的线程节点」可能是最好理解的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="hljs-comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="hljs-comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="hljs-comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">// 继承自AbstractOwnableSynchronizer</span><br></code></pre></td></tr></table></figure><p><em>AbstractQueuedSynchronizer</em> 的等待队列示意如下所示，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 <em>head</em></strong></p><p><img src="/posts/13119/1460000023819546.png" alt="img"></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 标识节点当前在共享模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 标识节点当前在独占模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span><br>    <span class="hljs-comment">// 代码此线程取消了争抢这个锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 取值为上面的1、-1、-2、-3，或者0</span><br>    <span class="hljs-comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br>    <span class="hljs-comment">// 比如：半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot取消的</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前驱节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 这个就是线程本尊</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>AQS</em> 内部提供了几个重要的方法，用于子类实现具体的同步逻辑，包括：</p><ol><li><p><strong><code>getState()</code>：</strong> 获取同步状态。</p></li><li><p><strong><code>setState(int newState)</code>：</strong> 设置同步状态。</p></li><li><p><strong><code>compareAndSetState(int expect, int update)</code>：</strong> 原子性地更新同步状态。</p></li><li><p><strong><code>acquire(int arg)</code>：</strong> 获取同步状态，如果资源被占用，则将当前线程入队等待。</p></li><li><p><strong><code>release(int arg)</code>：</strong> 释放同步状态，同时唤醒等待队列中的一个线程。</p></li><li><p><strong><code>tryAcquire(int arg)</code>：</strong> 尝试获取同步状态，如果成功返回true，否则返回false。</p></li><li><p><strong><code>tryRelease(int arg)</code>：</strong> 尝试释放同步状态，如果成功返回true，否则返回false。</p></li></ol><p>Java 中的并发工具类如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都是通过继承 <em>AQS</em> 并重写其中的方法来实现不同的同步策略</p><h3 id="AQS-使用"><a href="#AQS-使用" class="headerlink" title="AQS 使用"></a>AQS 使用</h3><p>上面说到了 <code>ReentrantLock</code> 等都是通过继承 AQS 并重写其中抽象方法来实现的。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点</p><p><img src="/posts/13119/1460000023819546.png" alt="img"></p><h4 id="ReentrantLock-的使用方式"><a href="#ReentrantLock-的使用方式" class="headerlink" title="ReentrantLock 的使用方式"></a>ReentrantLock 的使用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AService</span> &#123;<br>    <span class="hljs-comment">// 使用static，这样每个线程拿到的是同一把锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 比如我们同一时间，只允许一个线程创建订单</span><br>        reentrantLock.lock();<br>        <span class="hljs-comment">// 通常，lock 之后紧跟着 try 语句</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br>            <span class="hljs-comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReentrantLock</code> 在内部用了内部类 <code>Sync</code> 来管理锁，所以真正的获取锁和释放锁是由 <code>Sync</code> 的实现类来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 <code>NonfairSync</code>（非公平锁）和 <code>FairSync</code>（公平锁），我们看 <code>FairSync</code> 部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h4><h4 id="lock-方法"><a href="#lock-方法" class="headerlink" title="lock() 方法"></a><code>lock()</code> 方法</h4><blockquote><p>一般使用lock方法进行加锁，它内部其实是调用的同步器的acquire方法。</p></blockquote><h5 id="acquire-加锁"><a href="#acquire-加锁" class="headerlink" title="acquire 加锁"></a><code>acquire</code> 加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123; <span class="hljs-comment">// 此时 arg == 1 ,获取锁是将 state 由0改为1</span><br>    <span class="hljs-comment">// 首先调用tryAcquire(1)试一下，如果成功加锁，那这个线程不必打包成Node进行排队了。</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        <span class="hljs-comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>        selfInterrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tryAcquire-尝试获取锁"><a href="#tryAcquire-尝试获取锁" class="headerlink" title="tryAcquire 尝试获取锁"></a><code>tryAcquire</code> 尝试获取锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<span class="hljs-comment">// volatile修饰</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 此时此刻没有线程持有锁</span><br>        <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁,先判断队列中有没有其他节点</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br>            <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了</span><br>            <span class="hljs-comment">// 这里没用for循环，是因为，这只是尝试获取一下，后面会有for循环CAS</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>    <span class="hljs-comment">// 这里不存在并发问题，因为当前线程已经持有锁了</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="hljs-comment">// 首先判断一下当前线程与持有锁的线程是否为同一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果到这里，说明前面的if和else if都不成立，返回false，说明尝试失败</span><br>    <span class="hljs-comment">// 回到上面一个外层调用方法继续看:</span><br>    <span class="hljs-comment">// if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>    <span class="hljs-comment">//     selfInterrupt();</span><br>    <span class="hljs-comment">// 继续看addWaiter入队操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="addWaiter-入队"><a href="#addWaiter-入队" class="headerlink" title="addWaiter 入队"></a><code>addWaiter</code> 入队</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 此方法的作用是把线程包装成Node节点，同时进入到队列中</span><br><span class="hljs-comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程包装成Node节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-comment">// 这句英文意思是enq方法上面这段代码的意义是快速的尝试一下将当前节点设置成尾节点，如果不成功在for循环CAS</span><br>    <span class="hljs-comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<span class="hljs-comment">// 取到原始尾几点</span><br>    <span class="hljs-comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123; <br>        <span class="hljs-comment">// 将当前的队尾节点，设置为当前线程的前驱节点</span><br>        node.prev = pred; <br>        <span class="hljs-comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="hljs-comment">// 这里没用for循环CAS，目的是为了快速尝试，不成功则走enq</span><br>            <span class="hljs-comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br>            <span class="hljs-comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br>            pred.next = node;<br>            <span class="hljs-comment">// 线程入队了，可以返回了</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果会到这里说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br>    enq(node);<span class="hljs-comment">// 代码在下面</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 采用无限循环的方式入队，总有一天能成为队列的尾巴</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// t == null说明队列还未初始化，首先初始化队列</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// CAS设置头节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// 这个时候有了head，但是tail指向head</span><br>                <span class="hljs-comment">// 这里只是设置了tail = head，设置完了以后，继续for循环，下次就到下面的else分支了</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这个套在无限循环里，就是将当前线程排到队尾，有线程竞争的话排不上重复排，直到排到队尾为止</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="acquireQueued-获取队列"><a href="#acquireQueued-获取队列" class="headerlink" title="acquireQueued 获取队列"></a><code>acquireQueued</code> 获取队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回到开始这段代码</span><br><span class="hljs-comment">// if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="hljs-comment">//     selfInterrupt();</span><br><br><span class="hljs-comment">// 经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br><span class="hljs-comment">// 如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br><span class="hljs-comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br><span class="hljs-comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 入队后紧接着进入无限循环</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 拿到当前节点的前驱节点，如果前驱节点为null那么抛NPE异常</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br>            <span class="hljs-comment">// 阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br>            <span class="hljs-comment">// 所以当前节点可以去试抢一下锁</span><br>            <span class="hljs-comment">// 这里我们说一下，为什么可以去试试：</span><br>            <span class="hljs-comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br>            <span class="hljs-comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br>            <span class="hljs-comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br>            <span class="hljs-comment">// tryAcquire已经分析过了，就是简单用CAS试操作一下state</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头</span><br>            <span class="hljs-comment">// 要么就是tryAcquire(arg)没有抢赢别人</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 什么时候 failed 会为 true???</span><br>        <span class="hljs-comment">// tryAcquire() 方法抛异常的情况</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a><code>shouldParkAfterFailedAcquire</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 刚刚说过，到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br><span class="hljs-comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br>    <span class="hljs-comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br>    <span class="hljs-comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br>    <span class="hljs-comment">// 此while循环作用：</span><br>    <span class="hljs-comment">// 如果当前节点的前驱节点取消了排队,就找前面最近的一个状态&lt;=0的节点，因为当前节点依赖它来唤醒</span><br>    <span class="hljs-comment">// 如果前面的节点状态都为取消排队，那么当前节点就是队列的头</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果进入到这个分支意味着ws只能是0，-2，-3</span><br>        <span class="hljs-comment">// 前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br>        <span class="hljs-comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br>        <span class="hljs-comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 这个方法返回 false，那么会再走一次 for 循序，</span><br>    <span class="hljs-comment">// 然后再次进来此方法，此时会从第一个分支返回 true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法结束根据返回值简单分析下：</p><ul><li>如果返回true：说明前驱节点的waitStatus &#x3D; -1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了。</li><li>如果返回false：说明当前不需要被挂起。</li></ul><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a><code>parkAndCheckInterrupt</code></h5><p><code>shouldParkAfterFailedAcquire</code>返回true，则进入<code>parkAndCheckInterrupt</code>这个方法。这个方法的作用就是将当前线程挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为shouldParkAfterFailedAcquire返回true，所以需要挂起当前线程</span><br><span class="hljs-comment">// 这里用了LockSupport.park(this)来挂起线程，等待被前驱节点唤醒</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>回到上面的阻塞代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>    interrupted = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>到这里，当前线程就被阻塞住了，它会一直在这里阻塞，直到它的前驱节点将它唤醒。</p><h4 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock() 方法"></a><code>unlock()</code> 方法</h4><h5 id="release-释放锁"><a href="#release-释放锁" class="headerlink" title="release 释放锁"></a><code>release</code> 释放锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tryRelease-尝试释放锁"><a href="#tryRelease-尝试释放锁" class="headerlink" title="tryRelease 尝试释放锁"></a><code>tryRelease</code> 尝试释放锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回到ReentrantLock看tryRelease方法</span><br><span class="hljs-comment">// 释放锁没有使用任何CAS，那是因为本身就在锁中操作，不存在线程安全问题</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// 扣减当前线程持有锁的个数（可重入锁的实现机制）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">// 判断当前线程是否是持有锁的线程</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// 是否完全释放锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="unparkSuccessor-唤醒后继者"><a href="#unparkSuccessor-唤醒后继者" class="headerlink" title="unparkSuccessor 唤醒后继者"></a><code>unparkSuccessor</code> 唤醒后继者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从上面调用处知道，参数node是head头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果head节点当前 waitStatus &lt; 0, 将其修改为0</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus == 1）</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 从队尾往前找，找到 waitStatus &lt;= 0的所有节点中排在最前面的</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 从后往前找ws为-1的节点，如果有-1的，for循环并没有break，所以这段代码意思是找到最前面的那个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 唤醒后继节点的线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里唤醒以后，代码又会走到这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 刚刚线程被挂起在这里了</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<span class="hljs-comment">// 不忘检查一下当前线程的状态，true：当前线程未被中断</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p><code>ReentrantLock</code> 默认采用非公平锁，除非你在构造方法中传入参数 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 默认非公平锁</span><br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>公平锁的 <code>lock</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁的 <code>lock</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 这里没有对阻塞队列进行判断</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：公平锁和非公平锁只有两处不同：</p><ol><li><strong>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁</strong>，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，<strong>但是公平锁会判断等待队列是否有线程处于等待状态</strong>，如果有则不去抢锁，乖乖排到后面</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>AQS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Async 原理</title>
    <link href="/posts/7067.html"/>
    <url>/posts/7067.html</url>
    
    <content type="html"><![CDATA[<p><code>@Async</code> 是 Spring 框架中用于实现异步方法调用的注解。通过在方法上添加 <code>@Async</code> 注解，可以告诉 Spring 将该方法的执行放到一个独立的线程中，使得方法可以异步执行，而不会阻塞当前线程</p><span id="more"></span><p>在传统的同步方法调用中，当一个方法被调用时，调用者会一直等待方法执行完成，然后才能继续执行后续的操作。而使用 <code>@Async</code> 注解后，方法的执行将变为异步的，调用者可以继续执行后续操作，而方法的执行会在另一个线程中进行</p><h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><p>使用 <code>@Async</code> 注解的步骤：</p><ol><li><p>在 Spring 配置文件中开启异步支持或者在启动类上标注 <code>@EnableAsync</code></p></li><li><p>在需要异步执行的方法上添加 <code>@Async</code> 注解</p></li></ol><p>示例代码如下：</p><ol><li>启用异步支持：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:task</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/task&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/task</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/task/spring-task.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">task:annotation-driven</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置其他相关信息 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在方法上添加 <code>@Async</code> 注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 异步执行的方法逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>asyncMethod</code> 方法被 <code>@Async</code> 注解标记，表示该方法会异步执行。当调用 <code>asyncMethod</code> 方法时，Spring 将会在一个独立的线程中执行这个方法，而不会阻塞当前线程</p><h4 id="EnableAsync"><a href="#EnableAsync" class="headerlink" title="@EnableAsync"></a><code>@EnableAsync</code></h4><p>与<code>@EnableTransactionManagement</code> 类似，向 Spring 导入了 <code>AsyncConfigurationSelector.class</code> 组件，同样属于 <code>ImportSelector</code> 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(AsyncConfigurationSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAsync &#123;<br><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotation() <span class="hljs-keyword">default</span> Annotation.class;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>AdviceMode <span class="hljs-title function_">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Ordered.LOWEST_PRECEDENCE;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>AsyncConfigurationSelector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfigurationSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceModeImportSelector</span>&lt;EnableAsync&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;<br><span class="hljs-keyword">switch</span> (adviceMode) &#123;<br><span class="hljs-keyword">case</span> PROXY:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;ProxyAsyncConfiguration.class.getName()&#125;;<br><span class="hljs-keyword">case</span> ASPECTJ:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般使用时默认未修改 <code>AdviceMode</code>，故 <code>AsyncConfigurationSelector</code> 向 Spring 容器添加了名为 <code>ProxyAsyncConfiguration</code> 的 bean</p><h5 id="ProxyAsyncConfiguration"><a href="#ProxyAsyncConfiguration" class="headerlink" title="ProxyAsyncConfiguration"></a><code>ProxyAsyncConfiguration</code></h5><p><img src="/posts/7067/image-20230725160122790.png" alt="image-20230725160122790"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyAsyncConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAsyncConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> AsyncAnnotationBeanPostProcessor <span class="hljs-title function_">asyncAdvisor</span><span class="hljs-params">()</span> &#123;<br>Assert.notNull(<span class="hljs-built_in">this</span>.enableAsync, <span class="hljs-string">&quot;@EnableAsync annotation metadata was not injected&quot;</span>);<br><span class="hljs-type">AsyncAnnotationBeanPostProcessor</span> <span class="hljs-variable">bpp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncAnnotationBeanPostProcessor</span>();<br>bpp.configure(<span class="hljs-built_in">this</span>.executor, <span class="hljs-built_in">this</span>.exceptionHandler);<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; customAsyncAnnotation = <span class="hljs-built_in">this</span>.enableAsync.getClass(<span class="hljs-string">&quot;annotation&quot;</span>);<br><span class="hljs-keyword">if</span> (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, <span class="hljs-string">&quot;annotation&quot;</span>)) &#123;<br>bpp.setAsyncAnnotationType(customAsyncAnnotation);<br>&#125;<br>bpp.setProxyTargetClass(<span class="hljs-built_in">this</span>.enableAsync.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>));<br>bpp.setOrder(<span class="hljs-built_in">this</span>.enableAsync.&lt;Integer&gt;getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br><span class="hljs-keyword">return</span> bpp;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ProxyAsyncConfiguration</code> 向容器中注入了一个 <code>AsyncAnnotationBeanPostProcessor</code></p><p><code>AbstractAsyncConfiguration</code> 是 <code>ProxyAsyncConfiguration</code> 的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAsyncConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportAware</span> &#123;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> AnnotationAttributes enableAsync;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Supplier&lt;Executor&gt; executor;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现了ImportAware.setImportMetadata</span><br><span class="hljs-comment"> * 在ProxyAsyncConfiguration初始化后被调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> importMetadata</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata importMetadata)</span> &#123;<br><span class="hljs-comment">// 取得@EnableAsync注解</span><br><span class="hljs-built_in">this</span>.enableAsync = AnnotationAttributes.fromMap(<br>importMetadata.getAnnotationAttributes(EnableAsync.class.getName(), <span class="hljs-literal">false</span>));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableAsync == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br><span class="hljs-string">&quot;@EnableAsync is not present on importing class &quot;</span> + importMetadata.getClassName());<br>&#125;<br>&#125;<br>  <br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigurers</span><span class="hljs-params">(Collection&lt;AsyncConfigurer&gt; configurers)</span> &#123;<br><span class="hljs-comment">// configurers默认为空，除非手动注入AsyncConfigurer</span><br><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (configurers.size() &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Only one AsyncConfigurer may exist&quot;</span>);<br>&#125;<br><span class="hljs-type">AsyncConfigurer</span> <span class="hljs-variable">configurer</span> <span class="hljs-operator">=</span> configurers.iterator().next();<br><span class="hljs-built_in">this</span>.executor = configurer::getAsyncExecutor;<br><span class="hljs-built_in">this</span>.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从这里可以看出，可以通过向spring容器中注入<code>AsyncConfigurer</code> 来配置执行异步任务的线程池和异常处理器</p><h5 id="AsyncAnnotationBeanPostProcessor"><a href="#AsyncAnnotationBeanPostProcessor" class="headerlink" title="AsyncAnnotationBeanPostProcessor"></a><code>AsyncAnnotationBeanPostProcessor</code></h5><p><img src="/posts/7067/image-20230725161425842.png" alt="image-20230725161425842"></p><p><code>AsyncAnnotationBeanPostProcessor</code> 主要实现了 <strong>BeanFactoryAware</strong> 和 <strong>BeanPostProcessor</strong> 接口</p><blockquote><p> <code>org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#setBeanFactory</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> &#123;<br><span class="hljs-built_in">super</span>.setBeanFactory(beanFactory);<br><span class="hljs-comment">// 实例化Advisor</span><br><span class="hljs-type">AsyncAnnotationAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncAnnotationAdvisor</span>(<span class="hljs-built_in">this</span>.executor, <span class="hljs-built_in">this</span>.exceptionHandler);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.asyncAnnotationType != <span class="hljs-literal">null</span>) &#123;<br>advisor.setAsyncAnnotationType(<span class="hljs-built_in">this</span>.asyncAnnotationType);<br>&#125;<br>advisor.setBeanFactory(beanFactory);<br><span class="hljs-built_in">this</span>.advisor = advisor;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>AsyncAnnotationBeanPostProcessor</code> 实例化时实例化了切面 <code>AsyncAnnotationAdvisor</code></p><p>每个 bean 实例化完后都会调用 <code>AsyncAnnotationBeanPostProcessor.postProcessAfterInitialization()</code>判断是否要生成代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>... <span class="hljs-comment">// 省略</span><br><br><span class="hljs-comment">// isEligible会判断哪些bean要生成代理</span><br><span class="hljs-comment">// 就是使用advisor中的pointcut进行匹配</span><br><span class="hljs-keyword">if</span> (isEligible(bean, beanName)) &#123;<br><span class="hljs-comment">// 创建代理</span><br><span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> prepareProxyFactory(bean, beanName);<br><span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>evaluateProxyInterfaces(bean.getClass(), proxyFactory);<br>&#125;<br>proxyFactory.addAdvisor(<span class="hljs-built_in">this</span>.advisor);<br>customizeProxyFactory(proxyFactory);<br><span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());<br>&#125;<br><span class="hljs-comment">// No proxy needed.</span><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AsyncAnnotationAdvisor"><a href="#AsyncAnnotationAdvisor" class="headerlink" title="AsyncAnnotationAdvisor"></a><code>AsyncAnnotationAdvisor</code></h5><p>切面 <code>AsyncAnnotationAdvisor</code> 包括通知 <code>AnnotationAsyncExecutionInterceptor</code> 和切点<code>ComposablePointcut</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AsyncAnnotationAdvisor</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Supplier&lt;Executor&gt; executor, <span class="hljs-meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;<br>Set&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;&gt; asyncAnnotationTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>asyncAnnotationTypes.add(Async.class);<br><span class="hljs-keyword">try</span> &#123;<br>asyncAnnotationTypes.add((Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;)<br>ClassUtils.forName(<span class="hljs-string">&quot;javax.ejb.Asynchronous&quot;</span>, AsyncAnnotationAdvisor.class.getClassLoader()));<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-comment">// If EJB 3.1 API not present, simply ignore.</span><br>&#125;<br>  <span class="hljs-comment">// 创建AnnotationAsyncExecutionInterceptor</span><br><span class="hljs-built_in">this</span>.advice = buildAdvice(executor, exceptionHandler); <br>  <span class="hljs-comment">// 创建ComposablePointcut</span><br><span class="hljs-built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes); <br>&#125;<br><span class="hljs-keyword">protected</span> Advice <span class="hljs-title function_">buildAdvice</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Supplier&lt;Executor&gt; executor, <span class="hljs-meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;<br><span class="hljs-type">AnnotationAsyncExecutionInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationAsyncExecutionInterceptor</span>(<span class="hljs-literal">null</span>);<br>interceptor.configure(executor, exceptionHandler);<br><span class="hljs-keyword">return</span> interceptor;<br>&#125;<br><span class="hljs-keyword">protected</span> Pointcut <span class="hljs-title function_">buildPointcut</span><span class="hljs-params">(Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes)</span> &#123;<br><span class="hljs-type">ComposablePointcut</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; asyncAnnotationType : asyncAnnotationTypes) &#123;<br><span class="hljs-type">Pointcut</span> <span class="hljs-variable">cpc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationMatchingPointcut</span>(asyncAnnotationType, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 类</span><br><span class="hljs-type">Pointcut</span> <span class="hljs-variable">mpc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationMatchingPointcut</span>(<span class="hljs-literal">null</span>, asyncAnnotationType, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 方法</span><br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComposablePointcut</span>(cpc);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>result.union(cpc); <span class="hljs-comment">// 类和方法的组合切点</span><br>&#125;<br>result = result.union(mpc);<br>&#125;<br><span class="hljs-keyword">return</span> (result != <span class="hljs-literal">null</span> ? result : Pointcut.TRUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AnnotationMatchingPointcut</code> 切面其实就是查看类或者方法上面有没有 <code>@Async</code> 注解。</p><h5 id="AnnotationAsyncExecutionInterceptor"><a href="#AnnotationAsyncExecutionInterceptor" class="headerlink" title="AnnotationAsyncExecutionInterceptor"></a><code>AnnotationAsyncExecutionInterceptor</code></h5><p><code>AnnotationAsyncExecutionInterceptor</code> 类主要负责增强逻辑的实现，继承了 <code>AsyncExecutionInterceptor</code>，其中的 <code>invoke()</code> 实现了增强逻辑</p><blockquote><p> <code>org.springframework.aop.interceptor.AsyncExecutionInterceptor#invoke</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="hljs-literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="hljs-literal">null</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">specificMethod</span> <span class="hljs-operator">=</span> ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);<br><span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">userDeclaredMethod</span> <span class="hljs-operator">=</span> BridgeMethodResolver.findBridgedMethod(specificMethod);<br><span class="hljs-comment">// 判断执行方法的特定线程池，见下</span><br><span class="hljs-type">AsyncTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> determineAsyncExecutor(userDeclaredMethod);<br><span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br><span class="hljs-string">&quot;No executor specified and no default executor set on AsyncExecutionInterceptor either&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 将目标方法的执行封装为Callable，方便提交到线程池</span><br>Callable&lt;Object&gt; task = () -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 执行目标方法</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();<br><span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> Future) &#123;<br><span class="hljs-keyword">return</span> ((Future&lt;?&gt;) result).get();<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (ExecutionException ex) &#123;<br>handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>handleError(ex, userDeclaredMethod, invocation.getArguments());<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br><span class="hljs-comment">// 提交任务</span><br><span class="hljs-keyword">return</span> oSubmit(task, executor, invocation.getMethod().getReturnType());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> <code>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#determineAsyncExecutor</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AsyncTaskExecutor <span class="hljs-title function_">determineAsyncExecutor</span><span class="hljs-params">(Method method)</span> &#123;<br><span class="hljs-type">AsyncTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.executors.get(method);<br><span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>Executor targetExecutor;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.scheduling.annotation.AnnotationAsyncExecutionInterceptor#getExecutorQualifier(java.lang.reflect.Method)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 获得@Async注解中的value属性中指定的taskExecutor名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">qualifier</span> <span class="hljs-operator">=</span> getExecutorQualifier(method);<br><span class="hljs-keyword">if</span> (StringUtils.hasLength(qualifier)) &#123;<br>targetExecutor = findQualifiedExecutor(<span class="hljs-built_in">this</span>.beanFactory, qualifier);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 获取默认的taskExecutor</span><br>targetExecutor = <span class="hljs-built_in">this</span>.defaultExecutor.get();<br>&#125;<br><span class="hljs-keyword">if</span> (targetExecutor == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>executor = (targetExecutor <span class="hljs-keyword">instanceof</span> AsyncListenableTaskExecutor ?<br>(AsyncListenableTaskExecutor) targetExecutor : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecutorAdapter</span>(targetExecutor));<br><span class="hljs-built_in">this</span>.executors.put(method, executor);<br>&#125;<br><span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>determineAsyncExecutor()</code> 负责获取异步任务执行的线程池，线程池的查找步骤如下：</p><ol><li>从Spring容器中寻找 <code>@Async</code> 注解中的value属性中指定的 <code>taskExecutor</code></li><li>寻找默认的 <code>defaultExecutor</code></li></ol><p>默认的 <code>defaultExecutor</code> 来自于</p><blockquote><p> <code>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#configure</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Supplier&lt;Executor&gt; defaultExecutor,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;<br><span class="hljs-comment">// defaultExecutor默认为从beanFactory获取TaskExecutor或者bean名字为taskExecutor的Executor，beanFactory.getBean(TaskExecutor.class)</span><br><span class="hljs-built_in">this</span>.defaultExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonSupplier</span>&lt;&gt;(defaultExecutor, () -&gt; getDefaultExecutor(<span class="hljs-built_in">this</span>.beanFactory));<br><span class="hljs-comment">// exceptionHandler默认为SimpleAsyncUncaughtExceptionHandler</span><br><span class="hljs-built_in">this</span>.exceptionHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonSupplier</span>&lt;&gt;(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::<span class="hljs-keyword">new</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>defaultExecutor</code>首先取参数传入的<code>defaultExecutor</code>，这个参数来自接口<code>AsyncConfigurer.getAsyncExecutor()</code>，如果参数为null，那么就调用<code>getDefaultExecutor()</code>，注意这个方法子类<code>AsyncExecutionInterceptor</code>重写了：</p><blockquote><p> <code>org.springframework.aop.interceptor.AsyncExecutionInterceptor#getDefaultExecutor</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Executor <span class="hljs-title function_">getDefaultExecutor</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;<br><span class="hljs-type">Executor</span> <span class="hljs-variable">defaultExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getDefaultExecutor(beanFactory);<br><span class="hljs-keyword">return</span> (defaultExecutor != <span class="hljs-literal">null</span> ? defaultExecutor : <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAsyncTaskExecutor</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果找不到<code>defaultExecutor</code>就会创建一个<code>SimpleAsyncTaskExecutor</code></p><p>再来看看父类的 <code>AsyncExecutionAspectSupport#getDefaultExecutor</code>： </p><blockquote><p> <code>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#getDefaultExecutor</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Executor <span class="hljs-title function_">getDefaultExecutor</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;<br><span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Search for TaskExecutor bean... not plain Executor since that would</span><br><span class="hljs-comment">// match with ScheduledExecutorService as well, which is unusable for</span><br><span class="hljs-comment">// our purposes here. TaskExecutor is more clearly designed for it.</span><br><span class="hljs-keyword">return</span> beanFactory.getBean(TaskExecutor.class);<br>&#125;<br><span class="hljs-keyword">catch</span> (NoUniqueBeanDefinitionException ex) &#123;<br>logger.debug(<span class="hljs-string">&quot;Could not find unique TaskExecutor bean&quot;</span>, ex);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 找名为taskExecutor的Executor</span><br><span class="hljs-keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;<br><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>logger.info(<span class="hljs-string">&quot;More than one TaskExecutor bean found within the context, and none is named &quot;</span> +<br><span class="hljs-string">&quot;&#x27;taskExecutor&#x27;. Mark one of them as primary or name it &#x27;taskExecutor&#x27; (possibly &quot;</span> +<br><span class="hljs-string">&quot;as an alias) in order to use it for async processing: &quot;</span> + ex.getBeanNamesFound());<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>logger.debug(<span class="hljs-string">&quot;Could not find default TaskExecutor bean&quot;</span>, ex);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;<br>logger.info(<span class="hljs-string">&quot;No task executor bean found for async processing: &quot;</span> +<br><span class="hljs-string">&quot;no bean of type TaskExecutor and no bean named &#x27;taskExecutor&#x27; either&quot;</span>);<br>&#125;<br><span class="hljs-comment">// Giving up -&gt; either using local default executor or none at all...</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先从<code>beanFactory</code>中获取<code>TaskExecutor</code>类型的对象，然后再找名为<code>taskExecutor</code>的<code>Executor</code>对象</p><blockquote><p><code>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#doSubmit</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doSubmit</span><span class="hljs-params">(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType)</span> &#123;<br><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">if</span> (CompletableFuture.class.isAssignableFrom(returnType)) &#123;<br><span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> task.call();<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionException</span>(ex);<br>&#125;<br>&#125;, executor);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;<br><span class="hljs-keyword">return</span> ((AsyncListenableTaskExecutor) executor).submitListenable(task);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Future.class.isAssignableFrom(returnType)) &#123;<br><span class="hljs-keyword">return</span> executor.submit(task);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>executor.submit(task);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doSubmit()</code> 负责将任务提交至线程池中，并对各种方法的返回值进行处理</p><h4 id="Spring-定义的线程池类"><a href="#Spring-定义的线程池类" class="headerlink" title="Spring 定义的线程池类"></a>Spring 定义的线程池类</h4><p>Spring 已经定义的线程池类有如下一些：</p><ul><li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，默认每次调用都会创建一个新的线程</li><li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方</li><li><code>ConcurrentTaskExecutor：Executor</code>的适配类，不推荐使用。如果 <code>ThreadPoolTaskExecutor</code> 不满足要求时，才用考虑使用这个类</li><li><code>SimpleThreadPoolTaskExecutor</code>：是Quartz的 <code>SimpleThreadPool</code> 的类。线程池同时被quartz和非quartz使用，才需要使用此类</li><li><code>ThreadPoolTaskExecutor</code> ：最常使用，推荐。 其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code> 的包装</li></ul><h4 id="配置自定义线程池"><a href="#配置自定义线程池" class="headerlink" title="配置自定义线程池"></a>配置自定义线程池</h4><h5 id="异步方法默认的线程池"><a href="#异步方法默认的线程池" class="headerlink" title="异步方法默认的线程池"></a>异步方法默认的线程池</h5><p>在 <code>@EnableAsync</code> 注解中有如下注释说明：</p><blockquote><p>By default, Spring will be searching for an associated thread pool definition:either a unique {@link org.springframework.core.task.TaskExecutor} bean in the context,or an {@link java.util.concurrent.Executor} bean named “taskExecutor” otherwise. Ifneither of the two is resolvable, a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}will be used to process async method invocations.</p></blockquote><p>翻译一下就是：</p><blockquote><p>Spring首先会通过下面两种方式查找作为异步方法的默认线程池：<br>1、查找唯一的一个TaskExecutor类型的bean<br>2、或者是一个名称为“taskExecutor”的Executor类型的Bean。<br>如果上面两种方式都没有查找到，则使用SimpleAsyncTaskExecutor作为异步方法的默认线程池</p></blockquote><p>而 <code>SimpleAsyncTaskExecutor</code> 线程池去执行 <code>@Async</code> 标注的异步方法，由于该线程池不会重用线程，所以项目中推荐使用自定义的线程池。</p><h5 id="配置异步方法默认自定义线程池"><a href="#配置异步方法默认自定义线程池" class="headerlink" title="配置异步方法默认自定义线程池"></a>配置异步方法默认自定义线程池</h5><p>配置 <code>@Async</code> 默认的线程池有多种方式：</p><ol><li>重新实现接口 <code>AsyncConfigurer</code></li><li>继承 <code>AsyncConfigurerSupport</code></li><li>自定义一个 <code>TaskExecutor</code> 类型的bean</li><li>自定义一个名称为 <em>taskExecutor</em> 的Executor类型的Bean</li></ol><p><strong>实现接口</strong></p><p>开发者可以通过实现 <code>AsyncConfigurer</code> 接口来自定义自己的线程池，以下是官方文档给的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br> <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>          executor.setCorePoolSize(<span class="hljs-number">7</span>);<br>          executor.setMaxPoolSize(<span class="hljs-number">42</span>);<br>          executor.setQueueCapacity(<span class="hljs-number">11</span>);<br>          executor.setThreadNamePrefix(<span class="hljs-string">&quot;MyExecutor-&quot;</span>);<br>          executor.initialize();<br>          <span class="hljs-keyword">return</span> executor;<br>      &#125;<br> <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAsyncUncaughtExceptionHandler</span>();<br>      &#125;<br></code></pre></td></tr></table></figure><p><strong>继承类</strong></p><p>通过继承 <code>AsyncConfigurerSupport</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> extend AsyncConfigurerSupport &#123;<br> <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>          executor.setCorePoolSize(<span class="hljs-number">7</span>);<br>          executor.setMaxPoolSize(<span class="hljs-number">42</span>);<br>          executor.setQueueCapacity(<span class="hljs-number">11</span>);<br>          executor.setThreadNamePrefix(<span class="hljs-string">&quot;MyExecutor-&quot;</span>);<br>          executor.initialize();<br>          <span class="hljs-keyword">return</span> executor;<br>      &#125;<br> <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAsyncUncaughtExceptionHandler</span>();<br>      &#125;<br></code></pre></td></tr></table></figure><p><strong>配置自定义的TaskExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span>  &#123;<br> <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-meta">@Bean(name=AsyncExecutionAspectSupport.DEFAULT_TASK_EXECUTOR_BEAN_NAME)</span><br>      <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>          executor.setCorePoolSize(<span class="hljs-number">7</span>);<br>          executor.setMaxPoolSize(<span class="hljs-number">42</span>);<br>          executor.setQueueCapacity(<span class="hljs-number">11</span>);<br>          executor.setThreadNamePrefix(<span class="hljs-string">&quot;MyExecutor-&quot;</span>);<br>          executor.initialize();<br>          <span class="hljs-keyword">return</span> executor;<br>      &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不同异步方法配置不同线程池</strong></p><p>有时候不同功能的异步方法需要配置不同的线程池，可以通过在 <code>@Async</code> 上指定线程池的名称来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;customExecutor-1&quot;)</span><span class="hljs-comment">// 自定义线程池1</span><br>    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">customExecutor1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        executor.setCorePoolSize(<span class="hljs-number">3</span>);<span class="hljs-comment">//核心池大小</span><br>        executor.setMaxPoolSize(<span class="hljs-number">6</span>);<span class="hljs-comment">//最大线程数</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">60</span>);<span class="hljs-comment">//线程空闲时间</span><br>        executor.setQueueCapacity(<span class="hljs-number">10</span>);<span class="hljs-comment">//队列程度</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;customExecutor-1-&quot;</span>);<span class="hljs-comment">//线程前缀名称</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="hljs-comment">//配置拒绝策略</span><br>        executor.setAllowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<span class="hljs-comment">// 允许销毁核心线程</span><br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;customExecutor-2&quot;)</span><span class="hljs-comment">// 自定义线程池2</span><br>    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">customExecutor2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        executor.setCorePoolSize(<span class="hljs-number">3</span>);<span class="hljs-comment">//核心池大小</span><br>        executor.setMaxPoolSize(<span class="hljs-number">6</span>);<span class="hljs-comment">//最大线程数</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">60</span>);<span class="hljs-comment">//线程空闲时间</span><br>        executor.setQueueCapacity(<span class="hljs-number">10</span>);<span class="hljs-comment">//队列程度</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;customExecutor-2-&quot;</span>);<span class="hljs-comment">//线程前缀名称</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="hljs-comment">//配置拒绝策略</span><br>        executor.setAllowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<span class="hljs-comment">// 允许销毁核心线程</span><br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Async(&quot;customExecutor-1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;&#125;<br><br><span class="hljs-meta">@Async(&quot;customExecutor-2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="Async-异常处理"><a href="#Async-异常处理" class="headerlink" title="@Async 异常处理"></a><code>@Async</code> 异常处理</h4><p>当方法是带<code>Future</code>返回值的时候，<code>Future.get()</code>方法会抛出异常，所以异常捕获是没问题的。但是当方法是不带返回值的时候，那么此时主线程就不能捕获到异常，需要额外的配置来处理异常，可以有下面两种方式。</p><ol><li>通过<code>try-catch</code>处理异常</li></ol><p>直接在异步方法中使用 <code>try-catch</code> 来处理抛出的异常。这个方法也可以用于带 <code>Future</code> 返回值的异步方法。</p><ol start="2"><li>通过实现 <code>AsyncUncaughtExceptionHandler</code> 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 省略自定义线程池的代码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 自定义异常处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncUncaughtExceptionHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleUncaughtException</span><span class="hljs-params">(Throwable throwable, Method method, Object... objects)</span> &#123;<br>                System.out.println(method.getName() + <span class="hljs-string">&quot;发生异常！异常原因：&quot;</span> + throwable.getMessage() );<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p><code>@Async</code> 注解必须用在 <code>public</code> 访问级别的方法上，因为 Spring 使用代理来实现异步调用，所以只有 <code>public</code> 方法才能被代理</p></li><li><p>异步方法的返回值类型通常应该是 <code>void</code> 或 <code>java.util.concurrent.Future</code>。如果返回 <code>Future</code> 类型，则可以通过 <code>Future</code> 对象来获取异步方法的执行结果</p></li><li><p>异步方法应该在不同的类中调用，这样 Spring 能够正确地创建一个独立的线程来执行异步方法。</p></li><li><p>需要配置一个合适的 <code>TaskExecutor</code>，用于执行异步任务。如果没有配置，Spring 将使用默认的 <code>SimpleAsyncTaskExecutor</code></p></li></ul><p>总结来说，<code>@Async</code> 注解是 Spring 框架中实现异步方法调用的一种方式，它提供了一种简单的方法来实现多线程处理，从而提高应用程序的并发能力和性能</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Aysnc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transactional 原理</title>
    <link href="/posts/49928.html"/>
    <url>/posts/49928.html</url>
    
    <content type="html"><![CDATA[<p><code>@Transactional</code> 是 Spring 框架中用于实现事务管理的注解。事务是指一系列数据库操作，它们要么全部成功执行，要么全部失败回滚。使用 <code>@Transactional</code> 注解可以确保一组数据库操作要么全部成功提交，要么全部失败回滚，保持数据的一致性和完整性</p><span id="more"></span><h3 id="事务Transaction"><a href="#事务Transaction" class="headerlink" title="事务Transaction"></a>事务<em>Transaction</em></h3><p>数据库事务是指一组数据库操作，这些操作被视为一个单独的工作单元，并且要么全部成功执行，要么全部失败回滚，以保持数据库的一致性和完整性</p><p>事务具有四个特性，通常称为 ACID 特性：</p><ol><li><p><strong>原子性（<em>Atomicity</em>）</strong>：事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果其中任何一个操作失败，整个事务将回滚到最初状态，不会留下部分完成的结果</p></li><li><p><strong>一致性（<em>Consistency</em>）</strong>：事务在执行前和执行后，数据库的状态必须保持一致。这意味着事务在执行后，数据库从一个一致的状态转换到另一个一致的状态</p></li><li><p><strong>隔离性（<em>Isolation</em>）</strong>：事务之间是相互隔离的，一个事务的执行不应该受到其他事务的干扰。即使多个事务同时执行，它们也不能相互干扰，每个事务都应该感觉自己在独立执行</p></li><li><p><strong>持久性（<em>Durability</em>）</strong>：一旦事务成功提交，其结果将被永久保存在数据库中，即使发生系统故障，数据也不会丢失</p></li></ol><p>数据库事务的常用操作有：</p><ol><li><p><strong>开始事务（BEGIN 或 START TRANSACTION）</strong>：开始一个新的事务，此时数据库会记录当前的状态</p></li><li><p><strong>提交事务（COMMIT）</strong>：如果事务中所有的操作都成功执行，那么就提交事务，将结果保存到数据库中</p></li><li><p><strong>回滚事务（ROLLBACK）</strong>：如果事务中的任何一个操作失败，回滚事务，将数据库状态恢复到事务开始之前的状态</p></li></ol><p>事务的应用场景包括金融交易、订单处理、库存管理等需要确保数据完整性和一致性的场景。在数据库事务中，要注意设计良好的事务边界，避免事务持续时间过长，以免影响数据库的性能和并发处理能力</p><p>使用事务能够确保数据库操作的可靠性，是保障数据完整性和可靠性的重要手段。数据库管理系统（DBMS）负责实现和管理事务，并根据数据库的特性和事务的要求来确保 ACID 特性的实现</p><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a><code>@Transactional</code></h3><p>Spring中的 <code>@Transactional</code> 基于动态代理的机制，提供了一种透明的事务管理机制，方便快捷解决在开发中碰到的问题。在现实中，实际的问题往往比我们预期的要复杂很多，这就要求对 <code>@Transactional</code> 有深入的了解，以来应对复杂问题</p><p>在 Spring 中，<code>@Transactional</code> 注解可以用于类或方法级别。当应用在类级别上时，表示该类的所有公共方法都将受到事务管理。而当应用在方法级别上时，只有被注解的方法才会受到事务管理</p><p>要使用 <code>@Transactional</code> 注解，需要满足以下条件：</p><ol><li><p>在 Spring 配置文件中启用事务管理器或者在启动类上添加 <code>@EnableTransactionManagement</code></p></li><li><p>在需要事务管理的类上或方法上添加 <code>@Transactional</code> 注解</p></li></ol><blockquote><p>在Spring-boot里会自动配置事务，一般不需要手动开启事务管理</p><p>相关的配置在 <code>org.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></p></blockquote><p>示例代码如下：</p><ol><li>启用事务管理器：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置数据源和其他相关信息 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在类或方法上添加 <code>@Transactional</code> 注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingInTransaction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行数据库操作，这些操作会在事务管理下进行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingWithRollback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 执行数据库操作，如果发生异常，事务会回滚</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>doSomethingInTransaction</code> 和 <code>doSomethingWithRollback</code> 方法都被 <code>@Transactional</code> 注解标记，这意味着它们会受到事务管理。如果在 <code>doSomethingWithRollback</code> 方法中发生了异常，事务将回滚，数据库操作将被撤销，保持数据的一致性</p><h4 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a><code>@EnableTransactionManagement</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;TransactionManagementConfigurationSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTransactionManagement &#123;<br>    <span class="hljs-comment">// 指定代理对象生成方式，true为cglib，否则为jdk</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 指定拦截器的生成模式，默认为代理模式</span><br>    AdviceMode <span class="hljs-title function_">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY;<br>    <span class="hljs-comment">// 事务拦截器优先级</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Integer.MAX_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <code>@EnableAspectJAutoProxy</code> 注解类似，都是向Spring导入了一个 <strong><code>TransactionManagementConfigurationSelector</code></strong> 组件，它是属于 <code>ImportSelector</code> 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManagementConfigurationSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceModeImportSelector</span>&lt;EnableTransactionManagement&gt; &#123;<br><br>    <span class="hljs-keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;<br>        <span class="hljs-comment">// 从注解中获得的AdviceMode，默认为PROXY</span><br>        <span class="hljs-keyword">switch</span> (adviceMode) &#123;<br>            <span class="hljs-comment">// 向Spring容器添加了两个bean，分别为：</span><br>            <span class="hljs-comment">// AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration</span><br>            <span class="hljs-keyword">case</span> PROXY:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()&#125;;<br>            <span class="hljs-keyword">case</span> ASPECTJ:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-built_in">this</span>.determineTransactionAspectClass()&#125;;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a><code>AutoProxyRegistrar</code></h5><p><img src="/posts/49928/image-20230725134053856.png" alt="image-20230725134053856"></p><p>根据类的继承图可知，它属于 <strong><code>ImportBeanDefinitionRegistrar </code><strong>类型，Spring最终会调用内部的</strong><code>registerBeanDefinitions</code></strong> 方法，下述是源码中比较关键的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mode == AdviceMode.PROXY) &#123;<br>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);<br><span class="hljs-keyword">if</span> ((Boolean) proxyTargetClass) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用 <code>@EnableTransactionManagement</code> 注解时，并没有特意去修改内部方法的返回值。因此，这里的mode就是<code>AdviceMode.PROXY</code>，proxyTargetClass为<em>false</em>。由源码逻辑可知：Spring最终会执行这段代码：<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code> 这段代码的主要功能就是向Spring容器中添加这个bean：<code>InfrastructureAdvisorAutoProxyCreator.class</code></p><p><img src="/posts/49928/image-20230725141731103.png" alt="image-20230725141731103"></p><p>与之前 AOP 中的 <code>@EnableAspectJAutoProxy</code> 内部导入的 <code>AnnotationAwareAspectJAutoProxyCreator</code> bean的类继承图十分相似，都继承了 <code>AbstractAdvisorAutoProxyCreator</code></p><p>整个Spring AOP寻找切面、切面、通知的过程就是此方法 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 的功劳，而生成AOP代理对象就是 <code>BeanPostProcessor#postProcessAfterInitialization</code> 的功劳。而这些寻找切面、生成代理对象的功能其实是抽象父类 <code>AbstractAutoProxyCreator</code> 的功能。因此，<code>InfrastructureAdvisorAutoProxyCreatorv</code>也具备了寻找切面、切面、通知以及生成代理对象的功能</p><h5 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a><code>ProxyTransactionManagementConfiguration</code></h5><p><img src="/posts/49928/image-20230725142415730.png" alt="image-20230725142415730"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTransactionManagementConfiguration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyTransactionManagementConfiguration</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(</span><br><span class="hljs-meta">        name = &#123;&quot;org.springframework.transaction.config.internalTransactionAdvisor&quot;&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@Role(2)</span><br>    <span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title function_">transactionAdvisor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> &#123;<br>        <span class="hljs-type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();<br>        <span class="hljs-comment">// 内部维护了事务相关的属性源</span><br>        advisor.setTransactionAttributeSource(transactionAttributeSource);<br>        <span class="hljs-comment">// 内部维护了执行事务时的拦截器，后续会依赖这个拦截器来开启、提交/回滚事务</span><br>        <span class="hljs-comment">// 当调用拥有事务的方法时，最终会调用到此拦截器内部的invoke方法</span><br>        advisor.setAdvice(transactionInterceptor);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableTx != <span class="hljs-literal">null</span>) &#123;<br>            advisor.setOrder((Integer)<span class="hljs-built_in">this</span>.enableTx.getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> advisor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(2)</span><br>    <span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title function_">transactionAttributeSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTransactionAttributeSource</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(2)</span><br>    <span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title function_">transactionInterceptor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;<br>        <span class="hljs-type">TransactionInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>();<br>        interceptor.setTransactionAttributeSource(transactionAttributeSource);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.txManager != <span class="hljs-literal">null</span>) &#123;<br>            interceptor.setTransactionManager(<span class="hljs-built_in">this</span>.txManager);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类主要功能：</p><ul><li>构建事务拦截器 <code>transactionInterceptor</code></li><li>构建事务属性数据源 <code>transactionAttributeSource</code></li><li>构建 Advisor 类型的 bean <code>transactionAdvisor</code></li></ul><h4 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h4><h5 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h5><p>所谓编程式事务就是手动在代码中完成事务的提交，发生异常时的回滚。</p><p>在实现类中注入<code>PlatformTransactionManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">saveResource</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br><br>    <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>());<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 相关业务</span><br>        <br>        <span class="hljs-comment">// 手动提交</span><br>        transactionManager.commit(status);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;Exception:&#123;&#125;&quot;</span>, ExceptionUtil.stacktraceToString(e));<br>        <span class="hljs-comment">// 发生异常时进行回滚</span><br>        transactionManager.rollback(status);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h5><p>所谓声明式事务，就是使用<code>@Transactional</code>注解开启事务，该注解可以放在类上和方法上，放在类上时，该类所有的public方法都会开启事务；放在方法上时，表示当前方法支持事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">saveResource</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br>        <span class="hljs-comment">// 相关业务</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Transactional-底层执行原理"><a href="#Transactional-底层执行原理" class="headerlink" title="@Transactional 底层执行原理"></a><code>@Transactional</code> 底层执行原理</h4><p><code>ProxyTransactionManagementConfiguration</code> 在注入<code>BeanFactoryTransactionAttributeSourceAdvisor</code> 的同时，还为其设置了事务增强器：<code>advisor.setAdvice(transactionInterceptor;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTransactionManagementConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title function_">transactionAdvisor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> &#123;<br>        <span class="hljs-type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();<br>        advisor.setTransactionAttributeSource(transactionAttributeSource);<br>        <span class="hljs-comment">// 设置事务 interceptor</span><br>        advisor.setAdvice(transactionInterceptor);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableTx != <span class="hljs-literal">null</span>) &#123;<br>            advisor.setOrder((Integer)<span class="hljs-built_in">this</span>.enableTx.getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> advisor;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 创建事务 interceptor</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title function_">transactionInterceptor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;<br>        <span class="hljs-type">TransactionInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>();<br>        interceptor.setTransactionAttributeSource(transactionAttributeSource);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.txManager != <span class="hljs-literal">null</span>) &#123;<br>            interceptor.setTransactionManager(<span class="hljs-built_in">this</span>.txManager);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a><code>TransactionInterceptor</code></h5><p><img src="/posts/49928/image-20230725144817466.png" alt="image-20230725144817466"></p><p><code>TransactionInterceptor</code> 继承自 <code>TransactionAspectSupport</code>，并实现了 <code>MethodInterceptor</code>、<code>Serializable</code>；说明它是一个方法拦截器，在声明式事务中，其实就是在IoC容器中注册一个代理对象，当代理对象要执行目标方法时，方法拦截器会工作：</p><blockquote><p><code>org.springframework.transaction.interceptor.TransactionInterceptor#invoke</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-comment">// Work out the target class: may be &#123;@code null&#125;.</span><br><span class="hljs-comment">// The TransactionAttributeSource should be passed the target class</span><br><span class="hljs-comment">// as well as the method, which may be from an interface.</span><br>Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="hljs-literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span><br><span class="hljs-keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoroutinesInvocationCallback</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceedWithInvocation</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-keyword">return</span> invocation.proceed();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> invocation.getThis();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object[] getArguments() &#123;<br><span class="hljs-keyword">return</span> invocation.getArguments();<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于事务开启、回滚、提交的逻辑就是在 <code>invokeWithinTransaction()</code> 方法中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">invokeWithinTransaction</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass,<span class="hljs-keyword">final</span> InvocationCallback invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        ...<br>        <span class="hljs-type">PlatformTransactionManager</span> <span class="hljs-variable">ptm</span> <span class="hljs-operator">=</span> asPlatformTransactionManager(tm);<br>        <span class="hljs-comment">// 切点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">joinpointIdentification</span> <span class="hljs-operator">=</span> methodIdentification(method, targetClass, txAttr);<br><br>        <span class="hljs-keyword">if</span> (txAttr == <span class="hljs-literal">null</span> || !(ptm <span class="hljs-keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;<br>            <span class="hljs-comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span><br>            <span class="hljs-comment">// 创建事务</span><br>            <span class="hljs-type">TransactionInfo</span> <span class="hljs-variable">txInfo</span> <span class="hljs-operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);<br><br>            <span class="hljs-comment">// 环绕切点执行业务逻辑</span><br>            Object retVal;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// This is an around advice: Invoke the next interceptor in the chain.</span><br>                <span class="hljs-comment">// This will normally result in a target object being invoked.</span><br>                retVal = invocation.proceedWithInvocation();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-comment">// target invocation exception</span><br>                <span class="hljs-comment">// 执行过程中发生异常，执行回滚</span><br>                completeTransactionAfterThrowing(txInfo, ex);<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                cleanupTransactionInfo(txInfo);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;<br>                <span class="hljs-comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span><br>                <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> txInfo.getTransactionStatus();<br>                <span class="hljs-keyword">if</span> (status != <span class="hljs-literal">null</span> &amp;&amp; txAttr != <span class="hljs-literal">null</span>) &#123;<br>                    retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 正常执行，提交事务</span><br>            commitTransactionAfterReturning(txInfo);<br>            <span class="hljs-keyword">return</span> retVal;<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>completeTransactionAfterThrowing()</code> 执行过程中发生异常，执行回滚方法</p><blockquote><p><code>org.springframework.transaction.interceptor.TransactionAspectSupport#completeTransactionAfterThrowing</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completeTransactionAfterThrowing</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;<br>    <span class="hljs-comment">// 判断事务状态不为空的情况下</span><br>    <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 输出debug日志</span><br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() +<br>                    <span class="hljs-string">&quot;] after exception: &quot;</span> + ex);<br>        &#125;<br>        <span class="hljs-comment">// 在指定异常下回滚</span><br>        <span class="hljs-keyword">if</span> (txInfo.transactionAttribute != <span class="hljs-literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 开始回滚</span><br>                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (TransactionSystemException ex2) &#123;<br>                logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                ex2.initApplicationException(ex);<br>                <span class="hljs-keyword">throw</span> ex2;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (RuntimeException | Error ex2) &#123;<br>                logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                <span class="hljs-keyword">throw</span> ex2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不是指定的异常，任然提交</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We don&#x27;t roll back on this exception.</span><br>            <span class="hljs-comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (TransactionSystemException ex2) &#123;<br>                logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                ex2.initApplicationException(ex);<br>                <span class="hljs-keyword">throw</span> ex2;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (RuntimeException | Error ex2) &#123;<br>                logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                <span class="hljs-keyword">throw</span> ex2;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commitTransactionAfterReturning()</code> 正常执行，提交事务方法</p><blockquote><p><code>org.springframework.transaction.interceptor.TransactionAspectSupport#commitTransactionAfterReturning</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitTransactionAfterReturning</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;<br><span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Transactional-常用属性配置"><a href="#Transactional-常用属性配置" class="headerlink" title="Transactional 常用属性配置"></a><code>Transactional</code> 常用属性配置</h4><h5 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a><code>propagation</code></h5><p><strong>@Transactional(propagation &#x3D;</strong> <strong>Propagation.REQUIRED</strong>)</p><p>配置事务的传播特性，默认为：<strong>required</strong></p><table><thead><tr><th>传播性</th><th>描述</th></tr></thead><tbody><tr><td>Propagation**.REQUIRED**</td><td><strong>（默认值）</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置</td></tr><tr><td>Propagation**.REQUIRES_NEW**</td><td>创建新事务，无论当前存不存在事务，都创建新事务，如果当前有事务就将当前事务挂起</td></tr><tr><td>Propagation**.SUPPORTS**</td><td>如果有事务就在当前事务下运行，没有事务就在无事务状态下运行</td></tr><tr><td>Propagation**.NOT_SUPPORTED**</td><td>在无事务状态下运行，如果有事务，将当前事务挂起</td></tr><tr><td>Propagation**.MANDATORY**</td><td>必须存在事务，若无事务，抛出异常<code>IllegalTransactionStateException</code></td></tr><tr><td>Propagation**.NEVER**</td><td>不支持事务，有事务就抛出异常</td></tr><tr><td>Propagation**.NESTED**</td><td>当前有事务就在当事务里面再起一个事务</td></tr></tbody></table><ul><li><strong>支持当前事务</strong></li></ul><p><code>int PROPAGATION_REQUIRED = 0</code>; 如果当前存在事务，则加入当前事物；如果当前事务不存在，则新建一个事务；</p><p><code>int PROPAGATION_SUPPORTS = 1</code>; 如果当前存在事务，则加入当前事务；如果当前事务不存在，则以非事务方式运行；</p><p><code>int PROPAGATION_MANDATORY = 2</code>; 如果当前存在事务，则加入当前事务；如果当前事务不存在，则抛出异常；</p><ul><li><strong>不支持当前事务</strong></li></ul><p><code>int PROPAGATION_REQUIRES_NEW = 3</code>; 创建一个新事物，如果当前存在新事物，则把当前事务挂起；</p><p><code>int PROPAGATION_NOT_SUPPORTED = 4</code>; 以非事务方式运行，如果当前存在事务，则把当前事务挂起；</p><p><code>int PROPAGATION_NEVER = 5</code>;   以非事务方式运行，如果当前存在事务，则抛出异常；</p><p><code>int PROPAGATION_NESTED = 6</code>;   如果当前存在事务，则创建一个事务作为嵌套事务运行，如果当前不存在事务，则参照PROPAGATION_REQUIRED</p><p><strong>对于NESTED事务，如果外部事务异常，则内部事务也必须回滚</strong></p><h5 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a><code>isolation</code></h5><p>配置事务个<strong>隔离级别</strong>，默认为当前数据库的默认隔离级别（<em>MySQL</em>为<code>REPEATABLE-READ</code>）</p><p><strong>@Transactional(isolation &#x3D; Isolation.READ_COMMITTED )</strong></p><p>查看数据的隔离级别</p><p><img src="/posts/49928/bVcSxIP.png" alt="img"></p><table><thead><tr><th>隔离性</th><th>描述</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong>（未提交度）</td><td>读取未提交内容，所有事务可看到其他未提交事务的结果，很少实际使用（会出现脏读）</td></tr><tr><td><strong>READ COMMITTED</strong>（提交读）</td><td>一个事务只能读取到另一个事务已提交事务的修改过的数据，并且其他事务每次对数据进行修改并提交后，该事务都能查询到最新值</td></tr><tr><td><strong>REPEATABLE READ</strong>（可重复读）</td><td>一个是事务读取其实事务已经提交的修改数据，第一次读取某条记录时，即时其他事务修改了该记录并提交时，之后再读取这条记录时，仍然是第一次读取的值，而不是每次读取不同的数据</td></tr><tr><td><strong>SERIALIZABLE</strong>（串行化）</td><td>事务串行化执行，不会出现踩踏，避免了脏读、幻读和不可重复度，但效率低下</td></tr></tbody></table><h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><code>timeout</code></h5><p>配置事务超时时间，默认为：-1</p><p><strong>@Transactional(timeout &#x3D; 5)</strong>   </p><p>指定强制回滚之前事务可以占用的时间。单位：秒。如果执行时间草果这个时间就强制回滚</p><h5 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a><code>readOnly</code></h5><p><strong>@Transactional(readOnly &#x3D; false)</strong>  </p><p>默认为 ：false </p><p>指定事务是否为只读，表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。如果只有查询数据操作, 应设置 <code>readOnly = true</code> </p><h5 id="rollbackFor"><a href="#rollbackFor" class="headerlink" title="rollbackFor"></a><code>rollbackFor</code></h5><p>配置在那些异常情况下需要回滚数据，默认情况只在发生不受控异常下回滚（<code>RuntimeException</code>和<code>Error</code>），开发中最好配置为<code>Exception</code></p><p>受控异常（<em>checked exceptions</em>）：就是非运行时异常，即<code>Exception</code>中除了<code>RuntimeException</code>及其子类以外的</p><p>不受控异常（<em>unchecked exceptions</em>）：<code>RuntimeException</code>和<code>Error</code></p><p>rollbackFor 属性在这里就可以发挥它的作用了</p><p> <strong>@Transactional(rollbackFor &#x3D; <code>Exception.class</code>)</strong> </p><p> 这里你可以使用 java 已声明的异常；也可以使用自定义异常；也可同时设置多个异常类，中间用逗号间隔</p><p> <strong>@Transactional(rollbackFor &#x3D; {<code>SQLException.class</code>，<code>UserAccountException.class</code>})</strong> </p><h5 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a><strong><code>noRollbackFor</code></strong></h5><p>默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚。可以通过noRollbackFor属性进行设置例外异常<br><strong>@Transactional(noRollbackFor &#x3D;</strong> <strong>{UserAccountException.class})</strong><br>上面设置了遇到UserAccountException异常不回滚。一般不建议设置这个属性，通常情况下默认即可</p><h4 id="注意的几点"><a href="#注意的几点" class="headerlink" title="注意的几点"></a><strong>注意的几点</strong></h4><ol><li><code>@Transactional</code> 只能被应用到public方法上，对于其它非public的方法，如果标记了<code>@Transactional</code>也不会报错，但方法没有事务功能</li><li>用 spring 事务管理器，由spring来负责数据库的打开、提交、回滚。默认遇到运行期例外(<code>throw new RuntimeException(&quot;注释&quot;);</code>)会回滚，即遇到不受检查（<em>unchecked</em>）的例外时回滚；而遇到需要捕获的例外(<code>throw new Exception(&quot;注释&quot;);</code>)不会回滚，即遇到受检查的例外时，需我们指定方式来让事务回滚要想所有异常都回滚，要加上 <code>@Transactional( rollbackFor=&#123;Exception.class,其它异常&#125;)</code> 。如果让unchecked例外不回滚： <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li><code>@Transactional</code> 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 <code>@Transactional</code> 注解的出现不足于开启事务行为，它仅仅是一种元数据，能够被可以识别 <code>@Transactional</code> 注解和上述的配置适当的具有事务行为的 <em>beans</em> 所使用</li><li>Spring 团队的建议是你在具体的类（或类的方法）上使用 <code>@Transactional</code> 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 <code>@Transactional</code> 注解，但是这将<strong>只能</strong>当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 <code>@Transactional</code> 注解</li></ol><h4 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h4><ol><li><p>**<code>propagation</code>**设置错误，包括三种： <code>Propagation.SUPPORTS</code>，<code>Propagation.NOT_SUPPORTED</code>，<code>Propagation.NEVER</code></p></li><li><p>A，B两个方法，B方法添加了<code>@Transactional</code>，A没有，A中调用了B，如果在调用A方法的过程中，无论是A出问题还是B出问题，抛出异常，都不会回滚，是因为SpringAOP，只有当前事务方法被<strong>当前类以外的代码调用时，才会生产代理对象</strong></p></li><li><p>加了 <code>try-catch</code> ，没有抛出异常</p></li><li><p>两个Service，ServiceA和ServiceB。两个都有<code>@Transactional</code>，A中调用了B，B抛出异常，这时B标识为需要回滚，但是A方法 <code>try-catch</code> 这个异常并进行了处理，A标识为可以 <code>commit</code>，就会报错<code>UnexpectedRollbackException</code></p></li><li><p>数据库引擎不支持事务</p></li><li><p><code>rollbackFor</code>设置错误</p></li><li><p>抛出检查异常导致事务不能正确回滚（没写<code>rollbackFor</code>，或者 <code>try-catch</code> 掉了没到达外层环绕通知，必须抛出去或者 <code>transactionStatus.setRollbackOnly()</code>）</p></li><li><p>自定义切面捕获了内层异常（因为优先级问题 事务切面在最外层，可以更改自定义切面order 「<strong>不推荐</strong>」）</p></li><li><p><code>@Transactional</code> 需要加在公共方法上，spring为方法创建代理，添加事务通知前提都是public（解决办法，**<code>public</code>** 或者 <code>annotationTranscationAttributeSource(publicMethodsOnly:true)</code>)</p></li><li><p>父子容器事务失效，子容器扫描范围过大，将未配置事务控制的service扫描进来（springboot一般不会出现，因为只有一个容器）</p></li><li><p>调用本类方法导致传播行为失效，因为调用本类方法不经过代理，因此无法增强（依赖注入自己（代理）调用；通过 <code>aopcontext </code>拿到代理对象来调用；通过CTW，LTW实现功能增强</p></li><li><p><code>@Transactional</code> 没有保证原子行为，**<code>select</code>**方法并不阻塞，事务的原子性仅涵盖 <code>insert update delete select... for update</code></p></li><li><p><code>@Transactional</code> 方法导致 <strong><code>synchronized</code></strong> 失效，**<code>synchronized</code>** 仅仅保证目标方法的原子性，环绕目标方法的还有 <code>commit</code> 等操作，他们并未处于 <code>sync</code> 块内（扩大 <strong><code>synchronized</code></strong> 范围至代理方法调用；使用<code>select...for update</code> 替换 <code>select</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Transactional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 集成 Mybatis 原理</title>
    <link href="/posts/31562.html"/>
    <url>/posts/31562.html</url>
    
    <content type="html"><![CDATA[<p>MyBatis是一种在Java语言中使用的开源持久化框架，它通过简化数据库访问操作，使开发人员能够更轻松地与数据库进行交互。MyBatis将数据库操作从Java代码中分离出来，通过XML或注解配置来映射Java对象与数据库表之间的关系，从而实现了对象关系映射（ORM）</p><span id="more"></span><p>MyBatis的一些主要特点和组成部分：</p><ol><li><p>易于学习和使用：<code>MyBatis</code>相对于其他ORM框架而言，学习曲线较为平缓。它允许开发人员直接编写SQL语句，从而更加灵活地控制数据库操作</p></li><li><p>灵活的SQL映射：<code>MyBatis</code>支持在XML配置文件中编写SQL语句，这些SQL语句可以动态生成，根据不同的条件生成不同的SQL查询。这样可以避免过多的重复代码，提高开发效率</p></li><li><p>支持原生SQL：与其他ORM框架相比，<code>MyBatis</code>更加接近原生SQL，使得开发人员可以更好地优化和调整SQL语句以提高数据库性能</p></li><li><p>提供映射器（<code>Mapper</code>）接口：MyBatis使用<code>Java</code>接口和映射器文件（XML或注解）来描述数据库操作，使开发人员可以使用简洁的接口定义和调用<code>SQL</code>语句</p></li><li><p>缓存支持：MyBatis支持一级缓存和二级缓存，可以减少数据库查询次数，提高系统性能</p></li><li><p>使用MyBatis：在应用程序中调用映射器接口来进行数据库操作</p></li></ol><p>总体而言，MyBatis是一款功能强大且灵活的Java持久化框架，适用于各种规模的应用程序和数据库操作需求。它与Spring等框架集成良好，并在许多Java项目中得到广泛应用</p><p>在使用Mybatis的时候，我们只需要定义好Mapper接口，在业务层需要的地方注入对应Mapper即可</p><h4 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a><strong>@MapperScan</strong></h4><p><code>@MapperScan</code> 注解属于 <code>mybatis</code> 的扫描包注解，它用于自动扫描指定的包路径，以发现并注册<code>MyBatis</code>的映射器接口（<em>Mapper Interface</em>）。使用 <code>mapperscan</code>可以简化MyBatis的配置过程，特别是在项目中存在多个映射器接口时，可以避免手动一个个地在配置文件中注册这些接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(MapperScannerRegistrar.class)</span><br><span class="hljs-meta">@Repeatable(MapperScans.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MapperScan &#123;<br><br>  String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  <br>  ...<span class="hljs-comment">// 省略  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到了 <code>@MapperScan</code> 注解上 <code>@Import(MapperScannerRegistrar.class)</code>，这里导入了 <code>MapperScannerRegistrar</code> 类，此类实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，覆写了 <code>registerBeanDefinitions()</code> 方法，在容器初始化时将 <code>beanDefinition</code> 注册到容器之中</p><h4 id="MapperScannerRegistrar"><a href="#MapperScannerRegistrar" class="headerlink" title="MapperScannerRegistrar"></a><strong>MapperScannerRegistrar</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperScannerRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-comment">// 获取@MapperScan注解标注类的信息</span><br>    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">mapperScanAttrs</span> <span class="hljs-operator">=</span> AnnotationAttributes     .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));<br>    <span class="hljs-keyword">if</span> (mapperScanAttrs != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 调用下面的registerBeanDefinitions方法</span><br>      registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,<br>          generateBaseBeanName(importingClassMetadata, <span class="hljs-number">0</span>));<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName)</span> &#123;<br><br>   <span class="hljs-comment">// 生成MapperScannerConfigurer这个类的beanDefinition</span><br>    <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);<br>    builder.addPropertyValue(<span class="hljs-string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="hljs-literal">true</span>);<br><br>    ...<span class="hljs-comment">// 省略获取MapperScan注解的配置信息，比如basePackages、annotationClass，basePackages表示需要扫描的路径，annotationClass则是指定了增加了这种注解类的类需要被Spring进行管理，比如增加了Mapper注解的类需要被Spring管理的操作</span><br><br>    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续Spring就会基于这个<code>MapperScannerConfigurer</code>做一系列文章</p><h4 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h4><p><img src="/posts/31562/image-20230720192208172.png" alt="image-20230720192208172"></p><p>它是 <code>BeanDefinitionRegistryPostProcessor</code> 的实现类，是一个 <code>BeanFactory</code> 后置处理器，Spring启动时回调被覆盖的 <code>postProcessBeanDefinitionRegistry()</code> 方法来添加<code>beanDefinition</code>的操作，<code>MapperScannerConfigurer</code>这个类中具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.processPropertyPlaceHolders) &#123;<br>    processPropertyPlaceHolders();<br>  &#125;<br><br>  <span class="hljs-type">ClassPathMapperScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathMapperScanner</span>(registry);<br>  scanner.setAddToConfig(<span class="hljs-built_in">this</span>.addToConfig);<br>  scanner.setAnnotationClass(<span class="hljs-built_in">this</span>.annotationClass);<br>  scanner.setMarkerInterface(<span class="hljs-built_in">this</span>.markerInterface);<br>  scanner.setSqlSessionFactory(<span class="hljs-built_in">this</span>.sqlSessionFactory);<br>  scanner.setSqlSessionTemplate(<span class="hljs-built_in">this</span>.sqlSessionTemplate);<br>  scanner.setSqlSessionFactoryBeanName(<span class="hljs-built_in">this</span>.sqlSessionFactoryBeanName);<br>  scanner.setSqlSessionTemplateBeanName(<span class="hljs-built_in">this</span>.sqlSessionTemplateBeanName);<br>  scanner.setResourceLoader(<span class="hljs-built_in">this</span>.applicationContext);<br>  scanner.setBeanNameGenerator(<span class="hljs-built_in">this</span>.nameGenerator);<br>  scanner.setMapperFactoryBeanClass(<span class="hljs-built_in">this</span>.mapperFactoryBeanClass);<br>  <span class="hljs-keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;<br>    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));<br>  &#125;<br>  scanner.registerFilters();<br>  scanner.scan(<br>      StringUtils.tokenizeToStringArray(<span class="hljs-built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中创建了ClassPathMapperScanner对象，然后使用这个扫描器来扫描有Mapper注解的类，看它的关系知道，它是ClassPathBeanDefinitionScanner的子类，而spring则是使用ClassPathBeanDefinitionScanner来进行扫描的</p><h4 id="ClassPathMapperScanner"><a href="#ClassPathMapperScanner" class="headerlink" title="ClassPathMapperScanner"></a>ClassPathMapperScanner</h4><p><img src="/posts/31562/image-20230720192651755.png" alt="image-20230720192651755"></p><p><code>ClassPathMapperScanner</code> 通过调用 <code>registerFilters()</code> 方法来添加 <code>includeFilter</code>（实际类型是：<em>TypeFilter</em>），这里是Spring提供的扩展点，Mybatis定义的是 <code>@MapperScan</code> 注解中 <code>annotationClass</code> 属性配置的注解类型，这里配置了<code>Mapper</code>，所以调用<code>scan()</code>方法开启扫描后，Spring就会将包含<code>Mapper</code>注解的类扫描为<code>BeanDefinition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">doScan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>    <span class="hljs-comment">// Spring定义的doScan</span><br>    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-built_in">super</span>.doScan(basePackages);<br><br>    <span class="hljs-keyword">if</span> (beanDefinitions.isEmpty()) &#123;<br>      ...<span class="hljs-comment">// 省略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 扫描完成后Mybatis自定义对BeanDefinition进行处理</span><br>      processBeanDefinitions(beanDefinitions);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinitions</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;<br>    GenericBeanDefinition definition;<br>    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;<br>      definition = (GenericBeanDefinition) holder.getBeanDefinition();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> definition.getBeanClassName();<br><br>      <span class="hljs-comment">// 将当前的Mapper接口类传入，为之后的代理创建做准备</span><br>      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <br>      <span class="hljs-comment">// 把原来的BeanClass修改成了MapperFactoryBean.class</span><br>      definition.setBeanClass(<span class="hljs-built_in">this</span>.mapperFactoryBeanClass);<br><br>      ... <span class="hljs-comment">// 省略</span><br>      definition.getPropertyValues().add(<span class="hljs-string">&quot;addToConfig&quot;</span>, <span class="hljs-built_in">this</span>.addToConfig);<br>      <span class="hljs-keyword">if</span> (!explicitFactoryUsed) &#123;<br>        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);<br>      &#125;<br>      definition.setLazyInit(lazyInitialization);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 重写了候选组件的判断方法，只关心接口</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCandidateComponent</span><span class="hljs-params">(AnnotatedBeanDefinition beanDefinition)</span> &#123;<br>    <span class="hljs-keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>MapperFactoryBean</code> 是 <code>FactoryBean</code> 的实现类，Spring在实例化<code>Mapper</code>时，实际上是实例化<code>MapperFactoryBean</code> ，再调用它的<code>getObject()</code> 方法</p><h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperFactoryBean</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SqlSessionDaoSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> Class&lt;T&gt; mapperInterface;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperFactoryBean</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// intentionally empty</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperFactoryBean</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> getSqlSession().getMapper(<span class="hljs-built_in">this</span>.mapperInterface);<br>  &#125;<br>  ...<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>MapperFactoryBean</code> 的继承关系：</p><p><img src="/posts/31562/image-20230720194907382.png" alt="image-20230720194907382"></p><p>实现了<code>InitializingBean</code>，继承了<code>SqlSessionDaoSupport</code>，<code>DaoSupport</code>，在<code>DaoSupport</code>里重写了 <code>afterPropertiesSet()</code> 方法执行了<code>checkDaoConfig()</code> 方法；故在<code>MapperFactoryBean</code>初始化完成后，Spring会调用它的<code>afterPropertiesSet()</code>方法，从而会执行到<code>checkDaoConfig()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkDaoConfig</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">super</span>.checkDaoConfig();<br><br>  notNull(<span class="hljs-built_in">this</span>.mapperInterface, <span class="hljs-string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);<br><br>  <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> getSqlSession().getConfiguration();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="hljs-built_in">this</span>.mapperInterface)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      configuration.addMapper(<span class="hljs-built_in">this</span>.mapperInterface);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.mapperInterface + <span class="hljs-string">&quot;&#x27; to configuration.&quot;</span>, e);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      ErrorContext.instance().reset();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法调用了 <code>configuration.addMapper(this.mapperInterface)</code> 方法，然后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperRegistry</span> &#123;<br>    ... <span class="hljs-comment">// 省略</span><br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type.isInterface()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasMapper(type)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is already known to the MapperRegistry.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">loadCompleted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.knownMappers.put(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxyFactory</span>(type));<br>                <span class="hljs-type">MapperAnnotationBuilder</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperAnnotationBuilder</span>(<span class="hljs-built_in">this</span>.config, type);<br>                parser.parse();<br>                loadCompleted = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!loadCompleted) &#123;<br>                    <span class="hljs-built_in">this</span>.knownMappers.remove(type);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其实就是使用<code>Mapper</code>的接口类型作为<code>key</code>，<code>MapperProxyFactory</code> 作为<code>value</code>，添加到 <code>MapperRegistry</code> 对象Map集合中</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>在Spring完成 <code>MapperFactoryBean</code> 的创建后，会调用它的 <code>getObject()</code> 方法来获取真实对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">return</span> getSqlSession().getMapper(<span class="hljs-built_in">this</span>.mapperInterface);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="hljs-built_in">this</span>.knownMappers.get(type);<br>    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var5) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getObject()</code> 方法中会调用 <code>getMapper()</code> 方法，从<code>MapperRegistry</code> 中的 <code>knowMappers</code> 集合里拿到对象的代理工厂，然后用它来创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>    <span class="hljs-comment">// 为这个mapper接口创建了代理对象</span><br>    MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>(sqlSession, <span class="hljs-built_in">this</span>.mapperInterface, <span class="hljs-built_in">this</span>.methodCache);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newInstance(mapperProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>mybatis定义一个注解<code>@MapperScan</code></li><li>在<code>@MapperScan</code>中通过<code>@Import</code>导入了<code>MapperScannerRegistrar</code>，使这个类在启动时被加载</li><li>在<code>MapperScannerRegistrar</code>类中，先通过Spring扫描得到多个<code>beanDefinition</code>，后由mybatis的<code>processBeanDefinitions()</code> 方法处理上边的多个<code>beanDefinitions</code></li><li>遍历每一个处理后的<code>beanDefinition</code>，并添加构造方法，设置接口名字为bean的类型，至此bean类型确定。</li><li>为每一个处理后的<code>beanDefinition</code>，设置<code>FactoryBean</code>（其实就是<code>MapperFactoryBean.class</code>）</li><li>在<code>MapperFactoryBean</code>中的<code>getObject()</code>方法中，通过动态代理获取每一个 <code>mapper</code> 的代理对象，因为上文<code>@Import</code>导入了<code>MapperScannerRegistrar</code>，所以这些代理对象在启动时会被加入到容器以供后续随时使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 解决循环依赖原理</title>
    <link href="/posts/11853.html"/>
    <url>/posts/11853.html</url>
    
    <content type="html"><![CDATA[<p>循环依赖：是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成了构成一个环形调用</p><span id="more"></span><ul><li>自己依赖自己的直接依赖</li></ul><p><img src="/posts/11853/1460000040362329.png" alt="1.png"></p><ul><li>两个对象之间的直接依赖</li></ul><p><img src="/posts/11853/1460000040362330.png" alt="2.png"></p><ul><li>多个对象之间的间接依赖</li></ul><p><img src="/posts/11853/1460000040362331.png" alt="3.png"></p><p>前面两种情况的直接循环依赖比较直观，非常好识别，但是第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来</p><h3 id="循环依赖场景"><a href="#循环依赖场景" class="headerlink" title="循环依赖场景"></a>循环依赖场景</h3><p><img src="/posts/11853/1460000040362332.png" alt="4.png"></p><p><strong>单例的setter注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService1</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestService2 testService2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService2</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestService1 testService1;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个经典的循环依赖，但是它能正常运行，得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了，将<strong>实例化与初始化步骤分开</strong>，在中间过程中给其他对象赋值的时候，并不是一个完整对象，而是把半成品对象赋值给了其他对象</p><p>Bean创建前有一个集合<strong>singletonsCurrentlyInCreation</strong>，用于标记正在创建这个状态</p><ul><li><p><strong>一级缓存</strong>：为“Spring 的单例属性”而生，就是个单例池，用来存放已经初始化完成的单例 Bean</p></li><li><p><strong>二级缓存</strong>：为“解决 AOP”而生，存放的是半成品的 AOP 的单例 Bean</p></li><li><p><strong>三级缓存</strong>：为“打破循环”而生，存放的是生成半成品单例 Bean 的工厂方法，SingletonFactories是个函数式接口，lambda表达式</p></li></ul><p><strong>spring内部有三级缓存</strong>：</p><ul><li><code>singletonObjects</code> 一级缓存，用于保存实例化、注入、初始化完成的bean实例</li><li><code>earlySingletonObjects</code> 二级缓存，用于保存实例化完成的bean实例</li><li><code>singletonFactories</code> 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。</li></ul><p><strong>实例化bean之前先标记为创建状态</strong></p><p><img src="/posts/11853/v2-1e7bd042df73e47bb951e70b298c96ca_1440w-20230725001127175.png" alt="img"></p><ol><li>先实例化<code>testService1</code>，<code>doCreateBean</code>，发现是创建状态，三级缓存存入<em>lambda</em>表达式，这个表达式是生成bean的代理对象的，如果是AOP则反射对象，否则bean自身，是个半成品，添加A的代理对象到3级缓存</li><li>走到<code>populateBean</code>方法中，填充属性通过<code>AutowiredAnnotationBeanPostProcess</code>的<code>postProcessProperties()</code> 方法发现依赖<code>testService2</code>，继续递归<code>testService2</code>，重复1步骤</li><li>发现<code>testService2 </code>依赖 <code>testService1</code>，再解决<code>testService2</code>的依赖</li><li>发现<code>testService1</code>现在在3级缓存已经有了，把<code>testService1</code>从3级缓存删除，存到2级缓存，此时三级缓存存<code>testService2</code>，二级缓存存<code>testService1</code></li><li>继续返回第二层，<code>testService2</code>填充了<code>testService1</code>的属性，从创建状态删除，把<code>testService2</code>添加到一级缓存，删除二级缓存</li><li>再返回第一层，<code>testService1</code>填充了<code>testService2</code>的属性，从创建状态删除，把<code>testService1</code>添加到一级缓存，删除二级缓存</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>DefaultSingletonBeanRegistry#getSingleton(String)</code> 获取单例 Bean 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>   <span class="hljs-comment">// allowEarlyReference 允许早期依赖</span><br>   <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>   <span class="hljs-comment">// 这个bean 正处于 创建阶段</span><br>   <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>      <span class="hljs-comment">// 并发控制</span><br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>         <span class="hljs-comment">// 单例缓存是否存在</span><br>         singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>         <span class="hljs-comment">// 是否运行获取 bean factory 创建出的 bean</span><br>         <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-comment">// 获取缓存中的 ObjectFactory</span><br>            ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>               singletonObject = singletonFactory.getObject();<br>               <span class="hljs-comment">// 将对象缓存到 earlySingletonObject中</span><br>               <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>               <span class="hljs-comment">// 从工厂缓冲中移除</span><br>               <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码就是 Spring 尝试从缓存中加载单例。单例在 Spring 的同一个容器中只会被创建一次，后续再获取 bean，就直接从缓存中取了</p><p>补充一些方法和参数</p><ul><li><code>isSingletonCurrentlyInCreation()</code>：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)</li><li><code>allowEarlyReference</code> ：是否容许从singletonFactories中经过getObject拿到对象</li></ul><p>先认识下 <code>DefaultSingletonBeanRegistry</code> 这个类里面的成员变量</p><ul><li><code>Map&lt;String, Object&gt; singletonObjects</code>  key 就是 beanName ，value 就是 bean 实例</li><li><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code> key 为 beanName，value 为创建 bean 的工厂</li><li><code>Map&lt;String, Object&gt; earlySingletonObjects</code> key 为 beanName ，value 为 bean。但是和 <code>singletonObjects</code> 不同的是，bean 被加入到 <code>earlySingletonObjects</code> 的时候、这个 bean 还是处于一种创建中的状态，目的也很简单、Spring 用来解决某些场景下的循环依赖</li></ul><p>Spring获取一个bean的简单过程：</p><ul><li>首先从<code>singletonObjects</code>获取，也就是单例IoC容器中</li><li>然后从<code>earlySingletonObjects</code>中获取，也就是通过<code>ObjectFactory</code>实现的提前曝光的容器</li><li>最后从<code>singletonFactories</code>获取，也就是实例化bean的实例工厂</li><li>如果都获取不到，则新创建一个bean对象，也就说走上面分析的流程</li></ul><p>    从缓存中获取的bean的过程，一般都称为三级缓存，前面三个步骤对应了1，2，3级缓存。接下来举一个案例分析这个过程，假如有bean的依赖关系为：A-&gt;B-&gt;C-&gt;A，当然这些都是基于属性依赖的，当A执行到<code>populateBean</code>方法实现属性注入的时候，会先去获取B实例，然后B执行<code>populateBean</code>会获取C实例，C执行到<code>populateBean</code>获取查找A实例，此时A实例正在被创建，又会循环上述过程，产生了循环依赖问题。Spring获取<code>getBean()</code>最终调用下面简化后的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType, <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br><span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>Object bean;<br><span class="hljs-comment">//关注点1</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                     <span class="hljs-comment">//关注点2</span><br>sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>&#125;<br><span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br>&#125;<br>&#125;);<br>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125;<br>            ..............<br>            &#125;<br><span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>​       当A去查找bean的实例的时候，会调用上面的<code>doGetBean</code>方法获取，这个方法里面有两个关注点，分别是两个重载方法<code>getSingleton</code>，首先当A执行<code>populateBean</code>查找B的实例时调用第一个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>       <span class="hljs-comment">//从一级缓存中获取</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">//从二级缓存中获取</span><br>singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                         <span class="hljs-comment">//从三级缓存中获取</span><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>    这个方法是从三级缓存中查找bean，第一级缓存<code>singletonObjects</code>里面放置的是实例化好的单例对象。第二级<code>earlySingletonObjects</code>里面存放的是提前曝光的单例对象（没有完全装配好）。第三级<code>singletonFactories</code>里面存放的是要被实例化的对象的对象工厂，由于B第一次获取还没有被创建，所以一级缓存<code>singletonObjects</code>获取结果肯定为null，再看看看看进入二级缓存中的条件<code>isSingletonCurrentlyInCreation(beanName)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingletonCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>        <span class="hljs-comment">//在这里表示bean是否正在创建的过程，此时B 尚未在创建中，所以会返回false</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>    上面的步骤中并没有任何操作往<code>isSingletonCurrentlyInCreation</code>中加入B的beanName的操作，所以压根不会进入二级缓存，直接就返回null了，然后就判断bean是否时单例的，如果时调用<code>getSingleton(String beanName, ObjectFactory objectFactory)</code>,此时objectFactory时一个匿名内部类，实例B的获取是通过内部类的<code>createBean</code>获取的，这个是我们关注点2 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(beanName, <span class="hljs-string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">//从一级缓存中获取</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.singletonsCurrentlyInDestruction) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationNotAllowedException</span>(beanName,<span class="hljs-string">&quot;不能从销毁的bean中创建&quot;</span>);<br>&#125;<br>                <span class="hljs-comment">//在这里将B的beanName添加到isSingletonCurrentlyInCreation</span><br>beforeSingletonCreation(beanName);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br><span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;Exception&gt;();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>                     <span class="hljs-comment">//最终调用匿名内部类创建bean</span><br>singletonObject = singletonFactory.getObject();<br>&#125;<br><span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br><span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br><span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-built_in">this</span>.suppressedExceptions) &#123;<br>ex.addRelatedCause(suppressedException);<br>&#125;<br>&#125;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br><span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>&#125;<br>afterSingletonCreation(beanName);<br>&#125;<br>addSingleton(beanName, singletonObject);<br>&#125;<br><span class="hljs-keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    这个方法首先会从一级缓存中查找B，很明显，查到的结果为null，然后调用<code>beforeSingletonCreation(beanName)</code>，将B的beanName添加到<code>singletonsCurrentlyInCreation</code>中，也就是关注点1中无法进入二级缓存的那个集合校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp;<br>!<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    紧接着就会调用<code>singletonFactory.getObject()</code>创建名，也就是通过匿名内部类的<code>createBean</code>方法创建，前面分析过，创建bean最终会调用<code>doCreateBean</code>方法，这个方法简化了， 只看最核心的关注点3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> Object[] args)</span> &#123;<br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br>    ...........代码省略...........<br>   <span class="hljs-comment">//关注点3</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>         isSingletonCurrentlyInCreation(beanName));<br>   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>         logger.debug(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>               <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>      &#125;<br>      addSingletonFactory(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            <span class="hljs-keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);<br>         &#125;<br>      &#125;);<br>   &#125;<br>   <span class="hljs-comment">//初始化和实例化bean</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>   <span class="hljs-keyword">try</span> &#123;<br>      populateBean(beanName, mbd, instanceWrapper);<br>      <span class="hljs-keyword">if</span> (exposedObject != <span class="hljs-literal">null</span>) &#123;<br>         exposedObject = initializeBean(beanName, exposedObject, mbd);<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>     <span class="hljs-keyword">throw</span> ex;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>            exposedObject = earlySingletonReference;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>            String[] dependentBeans = getDependentBeans(beanName);<br>            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);<br>            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>               <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                  actualDependentBeans.add(dependentBean);<br>               &#125;<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>  ...........代码省略...........<br>   <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>    <code>createBeanInstance</code>利用反射创建了对象，下面我们看看关注点3<code>earlySingletonExposure</code>属性值的判断，其中有一个判断点就是<code>isSingletonCurrentlyInCreation(beanName)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingletonCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>    发现使用的是<code>singletonsCurrentlyInCreation</code>这个集合，在上面的步骤中将的B的BeanName已经填充进去了，所以可以查到，而且在初始化bean的时候，还会判断检查bean是否有循环依赖，而且是否允许循环依赖，这里的ABC形成了循环依赖，所以最终<code>earlySingletonExposure</code>结合其他的条件综合判断为true,进行下面的流程<code>addSingletonFactory</code>,这里是为这个Bean添加<code>ObjectFactory</code>,这个<code>BeanName(A)</code>对应的对象工厂，他的<code>getObject</code>方法的实现是通过<code>getEarlyBeanReference</code>这个方法实现的。首先我们看下<code>addSingletonFactory</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br><span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    往三级缓存<code>singletonFactories</code>存放数据，清除二级缓存中beanName对应的数据。这里有个很重要的点，是往三级缓存里面存入了值，这是Spring处理循环依赖的核心点。<code>getEarlyBeanReference</code>这个方法是<code>getObject</code>的实现，可以简单认为是返回了一个为填充完毕的A的对象实例。设置完三级缓存后，就开始了填充A对象属性的过程</p><p>    上面理清之后整体来分析以下ABC的初始化流程，当设置A的属性时，发现需要B类型的Bean，于是继续调用<code>getBean</code>方法创建，这次的流程和上面A的完全一致，然后到了填充C类型的Bean的过程，同样的调用getBean(C)来执行，同样到了填充属性A的时候，调用了getBean(A),我们从这里继续说，调用了doGetBean中的&#96;Object sharedInstance &#x3D; getSingleton(beanName),还是关注点1的代码，但是处理逻辑完全不一样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>       <span class="hljs-comment">//从一级缓存中获取</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">//从二级缓存中获取 此时二级缓存中应该也获取不到 </span><br>singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                         <span class="hljs-comment">//从三级缓存中获取  此时可以获取到 A 的实例，虽然属性并不太完整</span><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>    还是从singletonObjects获取对象获取不到，因为A是在<code>singletonsCurrentlyInCreation</code>这个Set中，所以进入了下面的逻辑，从二级缓存<code>earlySingletonObjects</code>中取，还是没有查到，然后从三级缓存<code>singletonFactories</code>找到对应的对象工厂调用<code>getObject</code>方法获取未完全填充完毕的A的实例对象，然后删除三级缓存的数据，填充二级缓存的数据，返回这个对象A。C依赖A的实例填充完毕了，虽然这个A是不完整的。不管怎么样C式填充完了，就可以将C放到一级缓存<code>singletonObjects</code>同时清理二级和三级缓存的数据。同样的流程B依赖的C填充好了，B也就填充好了，同理A依赖的B填充好了，A也就填充好了。Spring就是通过这种方式来解决循环引用的</p><p><img src="/posts/11853/1460000040362341.png" alt="13.png"></p><p><strong>Spring不能解决构造器的循环依赖</strong></p><p>构造器注入形成的循环依赖： 也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决</p><p>Spring解决循环依赖主要是依赖三级缓存，但是的<strong>在调用构造方法之前还未将其放入三级缓存之中</strong>，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决</p><p><strong>Spring不能解决prototype作用域循环依赖</strong></p><p>这种循环依赖同样无法解决，因为spring不会缓存‘prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的</p><p><strong>Spring不能解决多例的循环依赖</strong></p><p>多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖</p><blockquote><p>那么实际开发中，类似的依赖是如何解决？</p></blockquote><ul><li><strong>生成代理对象产生的循环依赖</strong></li></ul><p>这类循环依赖问题解决方法很多，主要有：</p><ol><li>使用@Lazy注解，延迟加载</li><li>使用@DependsOn注解，指定加载先后关系</li><li>修改文件名称，改变循环依赖类的加载顺序</li></ol><ul><li><strong>使用@DependsOn产生的循环依赖</strong></li></ul><p>这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题</p><ul><li><strong>多例循环依赖</strong></li></ul><p>这类循环依赖问题可以通过把bean改成单例的解决</p><ul><li><strong>构造器循环依赖</strong></li></ul><p>这类循环依赖问题可以通过使用@Lazy注解解决</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理 Proxy 反射 Reflect 与 Spring AOP</title>
    <link href="/posts/59835.html"/>
    <url>/posts/59835.html</url>
    
    <content type="html"><![CDATA[<p><strong>AOP</strong>（<em>Aspect-Oriented Programming</em>，面向切面编程）是一种编程范式，旨在通过横切关注点（<em>Cross-cutting Concerns</em>）的抽象和模块化，将系统的功能和非功能需求分离，从而提高代码的可维护性、可重用性和灵活性</p><span id="more"></span><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP的这种模式，底层就是基于代理模式实现</p><p><strong>代理模式</strong>（<em>Proxy Pattern</em>）是一种结构型设计模式，也叫<strong>委托模式</strong>，它允许通过一个代理对象来控制对另一个对象的访问。代理对象充当另一个对象的接口，以控制对该对象的访问，并在必要时添加额外的逻辑。代理模式主要用于对目标对象的访问进行控制，可以用于实现懒加载、访问控制、缓存、日志记录等功能</p><p>代理模式一般分为以下三个角色：</p><ol><li><p><strong>抽象主题</strong>（Subject）：定义了目标对象和代理对象的共同接口，这样在任何使用目标对象的地方都可以使用代理对象</p></li><li><p><strong>真实主题</strong>（Real Subject）：也称为被代理对象或目标对象，它是代理模式中的真正业务逻辑的实现</p></li><li><p><strong>代理</strong>（Proxy）：代理对象，它持有对真实主题的引用，并实现了抽象主题的接口。代理对象通常在客户端与真实主题之间起到中介的作用，它可以在调用真实主题之前或之后执行一些附加操作</p></li></ol><h5 id="代理模式实现"><a href="#代理模式实现" class="headerlink" title="代理模式实现"></a>代理模式实现</h5><p>下面是一个简单的Java中代理模式的实现示例，使用了静态代理方式：</p><ol><li>定义抽象主题接口（Subject）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义真实主题类（RealSubject）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>定义代理类（Proxy）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Proxy.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span> &#123;<br>        realSubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        realSubject.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>客户端代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用代理对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>();<br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Proxy</span></span> is doing something before the RealSubject...<br><span class="hljs-function"><span class="hljs-title">RealSubject</span></span> is doing something...<br><span class="hljs-function"><span class="hljs-title">Proxy</span></span> is doing something after the RealSubject...<br></code></pre></td></tr></table></figure><p>在上面的示例中，抽象主题（Subject）定义了一个接口，真实主题（RealSubject）实现了这个接口，代理类（Proxy）也实现了这个接口，并在方法中调用了真实主题对象的方法，同时添加了一些额外的操作。客户端通过代理对象来访问真实主题，而无需直接与真实主题交互。这样，代理对象就控制了对真实主题的访问，并且可以在调用前后添加一些自定义的逻辑</p><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理与静态代理的区别，首先要了解两个前置知识点：Java程序的执行以及类加载机制</p><ul><li>Java程序的执行过程<ul><li>编写源代码：首先，开发人员使用Java编程语言编写源代码，源代码通常以<code>.java</code>为扩展名</li><li>编译源代码：使用Java编译器（javac）对源代码进行编译，将源代码转换为字节码文件。字节码文件以<code>.class</code>为扩展名，并包含Java虚拟机（JVM）可执行的中间代码</li><li>执行<code>.class</code> 文件</li></ul></li><li>类加载机制<ul><li><strong>加载</strong>（loading）：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的 <code>java.lang.class</code> 对象，作为方法区这个类的各种数据访问入口</li><li><strong>连接</strong>（Linking）：<br>   类加载的连接阶段包括三个子阶段：<ul><li>验证（Verification）：对加载的类进行验证，确保其符合Java虚拟机规范和安全要求</li><li>准备（Preparation）：为类的静态变量分配内存空间，并设置默认初始值</li><li>解析（Resolution）：将类的符号引用（常量池中的符号）解析为直接引用，建立对其他类的引用关系</li></ul></li><li><strong>初始化</strong>（Initialization）：<ul><li>在初始化阶段，执行类的静态代码块和静态初始化语句，对类的静态变量进行初始化</li><li>初始化阶段是类加载的最后一个阶段，在此阶段完成后，Java类对象被完全初始化，可以被使用</li></ul></li></ul></li></ul><p>动态代理和静态代理是两种不同的代理模式实现方式，它们在代理对象的创建和使用方式上存在一些区别</p><ol><li><p>创建时机和方式：</p><ul><li>静态代理：在编译阶段就需要创建代理类，代理类是由开发者手动编写的。对于每一个被代理的类，都需要创建一个相应的代理类</li><li>动态代理：在运行时动态生成代理类，无需手动编写代理类。代理类是在程序运行时根据接口或类信息动态创建的</li></ul></li><li><p>代理对象与目标对象的关系：</p><ul><li>静态代理：代理对象和目标对象之间的关系是静态的，即在编译时就已经确定了。每个代理类只能代理一个目标类，代理类与目标类是一一对应的关系</li><li>动态代理：代理对象和目标对象之间的关系是动态的，即在程序运行时根据需要动态生成代理类。一个动态代理类可以代理多个目标类，代理对象的关联是在运行时决定的</li></ul></li><li><p>实现方式：</p><ul><li>静态代理：通过手动编写代理类来实现，需要为每一个目标类创建一个代理类</li><li>动态代理：使用Java的反射机制，在运行时动态生成代理类。Java提供了两种动态代理的方式：基于接口的代理（JDK动态代理）和基于类的代理（CGLIB动态代理）</li></ul></li><li><p>灵活性：</p><ul><li>静态代理：代理类的创建和目标类的绑定是在编译时确定的，因此在程序运行时无法动态改变代理关系。</li><li>动态代理：由于代理类是在运行时生成的，因此可以根据需要动态地改变代理关系，更加灵活。</li></ul></li></ol><p>总体而言，静态代理需要手动编写代理类，对于少量目标类的代理是可行的，但当目标类数量较多时会产生大量重复代码。而动态代理通过在运行时动态生成代理类，避免了手动编写代理类的繁琐过程，适用于代理对象较多、代理关系动态变化的情况</p><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JDK动态代理是Java中实现动态代理的一种机制，它是Java标准库（<code>java.lang.reflect</code>包）提供的一种代理方式。JDK动态代理基于接口的代理方式，通过在运行时动态生成代理类来实现代理功能。JDK动态代理使用了Java的反射机制来实现，可以在运行时创建代理对象，无需手动编写代理类</p><p>JDK动态代理的核心类是<code>java.lang.reflect.Proxy</code>，它提供了静态方法<code>newProxyInstance()</code>来创建代理对象。<code>newProxyInstance()</code>方法接收三个参数：</p><ol><li><code>ClassLoader</code>：用于加载动态生成的代理类的类加载器。</li><li><code>Class[] interfaces</code>：代理类要实现的接口数组，代理对象将实现这些接口。</li><li><code>InvocationHandler</code>：代理对象的调用处理程序，它定义了代理对象在执行方法时的行为。</li></ol><p>以下是一个使用JDK动态代理的简单示例：</p><ol><li>定义抽象主题接口（Subject）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义真实主题类（RealSubject）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>定义代理处理程序（MyInvocationHandler）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyInvocationHandler.java</span><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object realSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.realSubject = realSubject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(realSubject, args);<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>客户端代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建真实主题对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br><br>        <span class="hljs-comment">// 创建代理处理程序</span><br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(realSubject);<br>        <span class="hljs-comment">// 获取对应的 ClassLoader</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> realSubject.getClass().getClassLoader();<br>        <span class="hljs-comment">// 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService</span><br>        Class[] interfaces = realSubject.getClass().getInterfaces()<br><br>        <span class="hljs-comment">// 创建代理对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(<br>                classLoader,<br>                interfaces,<br>                handler);<br><br>        <span class="hljs-comment">// 使用代理对象</span><br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy is doing something before the RealSubject...<br>RealSubject is doing something...<br>Proxy is doing something after the RealSubject...<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们通过 <code>Proxy.newProxyInstance()</code> 方法创建了一个代理对象，该代理对象实现了<code>Subject</code>接口，并在调用方法时通过 <code>MyInvocationHandler</code> 中定义的逻辑来进行增强操作。这样，我们就实现了一个基于JDK动态代理的简单代理功能</p><h5 id="JDK动态代理分析"><a href="#JDK动态代理分析" class="headerlink" title="JDK动态代理分析"></a>JDK动态代理分析</h5><p><code> Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span> &#123;<br>    Objects.requireNonNull(h);<br><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br>    <span class="hljs-comment">// 查询（在缓存中已经有）或生成指定的代理类的class对象。</span><br>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>        &#125;<br>        <span class="hljs-comment">// 返回对应参数的公共构造函数</span><br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;<br>        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    cons.setAccessible(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 生成代理对象</span><br>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);<br>    &#125;   <br>    ... <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后来到 <code>ProxyClassFactory</code> 的 <code>apply()</code> 方法，代理类就是在这里生成的</p><h5 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h5><p>CGLib动态代理是另一种实现动态代理的方式，它与JDK动态代理不同，不基于接口，而是对类进行代理。CGLib是一个强大的代码生成库，它能够在运行时扩展Java类和实现代理功能。CGLib动态代理的原理是通过生成目标类的子类来实现代理，因此被代理的类不能是final类，且代理的方法不能是final或static的。两者的区别有以下几点：</p><ol><li>Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类。</li><li>Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB 使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效。</li></ol><p>CGLib动态代理的核心类是 <code>net.sf.cglib.proxy.Enhancer</code>，它是CGLib库中的代理增强类，用于生成代理类的实例。使用CGLib动态代理需要依赖CGLib库。</p><p>以下是一个使用CGLib动态代理的简单示例：</p><ol><li>定义目标类（<code>RealSubject</code>）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义代理处理程序（<code>MyMethodInterceptor</code>）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyMethodInterceptor.java</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// before</span><br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        <span class="hljs-comment">// after</span><br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>intercept</code>方法四个参数的含义如下： <code>obj</code>: 代理类对象。 <code>method</code>: 被代理的类中的方法。 <code>args</code>: 调用方法需要的参数。 <code>proxy</code>: 生成的代理类对方法的<strong>代理引用</strong></p><p>用户需要实现<code>MethodInterceptor</code>接口，实现对方法的拦截。这一点与JDK动态代理中用户需要实现<code>InvocationHandler</code>接口类似</p><ol start="3"><li>客户端代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建代理处理程序</span><br>        <span class="hljs-type">MyMethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>();<br><br>        <span class="hljs-comment">// 使用Enhancer创建代理对象</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置继承被代理类</span><br>        enhancer.setSuperclass(RealSubject.class);<br>        <span class="hljs-comment">// 设置回调</span><br>        enhancer.setCallback(interceptor);<br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (RealSubject) enhancer.create();<br><br>        <span class="hljs-comment">// 使用代理对象</span><br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy is doing something before the RealSubject...<br>RealSubject is doing something...<br>Proxy is doing something after the RealSubject...<br></code></pre></td></tr></table></figure><p>在上面的示例中使用CGLib的 <code>Enhancer</code> 类来创建了一个代理对象，该代理对象继承了 <code>RealSubject</code> 类，并在调用方法时通过 <code>MyMethodInterceptor</code> 中定义的逻辑来进行增强操作。这样就实现了一个基于CGLib动态代理的简单代理功能</p><p>需要注意的是，CGLib动态代理相比于JDK动态代理的优点在于它可以代理没有实现接口的类，而且在一些场景下由于继承的方式，可以更高效地执行代理。然而，CGLib动态代理也有一些限制，例如无法代理 <code>final</code> 类和 <code>final</code> 方法</p><h5 id="CGLib动态代理分析"><a href="#CGLib动态代理分析" class="headerlink" title="CGLib动态代理分析"></a>CGLib动态代理分析</h5><p><strong>生成指定类Class对象字节数组</strong>，CGLib动态代理会选择目标类（被代理类）作为父类，然后生成代理类的字节码——首先创建<code>Enhancer</code>对象，设置<code>SuperClass</code>父类（被代理类），然后调用<code>Enhancer</code>对象的<code>create()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.classOnly = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.argumentTypes = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.createHelper();<br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createHelper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1.进行有效性验证</span><br>  <span class="hljs-comment">//1.1 callBack不能为空，也就是说至少要有一个callBack(callBack与代理类紧密相关)</span><br>  <span class="hljs-comment">//1.2 有多个callBack时必须有callBackFilter</span><br>    <span class="hljs-built_in">this</span>.preValidate();<br>    <span class="hljs-comment">//2.先根据KEY_FACTORY 以当前代理类的配置信息 生成一个组合Key，再利用这个组合Key，进行create</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEY_FACTORY.newInstance(<span class="hljs-built_in">this</span>.superclass != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.superclass.getName() : <span class="hljs-literal">null</span>, <br>                 ReflectUtils.getNames(<span class="hljs-built_in">this</span>.interfaces), <br>                 <span class="hljs-built_in">this</span>.filter == ALL_ZERO ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakCacheKey</span>(<span class="hljs-built_in">this</span>.filter),                  <br>                 <span class="hljs-built_in">this</span>.callbackTypes, <br>                 <span class="hljs-built_in">this</span>.useFactory, <br>                 <span class="hljs-built_in">this</span>.interceptDuringConstruction, <br>                 <span class="hljs-built_in">this</span>.serialVersionUID);<br>    <span class="hljs-built_in">this</span>.currentKey = key;<br>    <span class="hljs-comment">//根据生成的key创建代理对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.create(key);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后到了 Enhance 继承的 AbstractClassGenerator 类中的 create() 方法，这一步就是为了得到动态类的Class对象，之后通过<strong>反射</strong>生成具体的类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//1.获取当前类加载器，应用类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClassLoader();<br>        <span class="hljs-comment">//2.缓存，一级缓存的key是类加载器,value是ClassLoaderData</span><br>     <span class="hljs-comment">//2.1 cache中有则直接获取</span><br>        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;<br>        <span class="hljs-type">ClassLoaderData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (ClassLoaderData)cache.get(loader);<br>        <span class="hljs-comment">//2.2 cache中没有则生成，双重检查🔒</span><br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> AbstractClassGenerator.class;<br>            <span class="hljs-keyword">synchronized</span>(AbstractClassGenerator.class) &#123;<br>                cache = CACHE;<br>                data = (ClassLoaderData)cache.get(loader);<br>                <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span>) &#123;<br>                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>(cache);<br>                    data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderData</span>(loader);<br>                    newCache.put(loader, data);<br>                    CACHE = newCache;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-comment">//3.调用 get方法获取字节码，如果没有字节码，则会创建字节码（Class对象）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> data.get(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>.getUseCache());<br>        <span class="hljs-comment">//4.生成动态代理类</span><br>        <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> Class ? <span class="hljs-built_in">this</span>.firstInstance((Class)obj) : <span class="hljs-built_in">this</span>.nextInstance(obj);<br>    &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var9) &#123;<br>        <span class="hljs-keyword">throw</span> var9;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var10) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeGenerationException</span>(var10);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ClassLoaderData.get() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-type">boolean</span> useCache)</span> &#123;<br>    <span class="hljs-comment">//判断是否开启缓存，可直接设置：enhancer.setUseCache(false); 默认为true</span><br>    <span class="hljs-keyword">if</span> (!useCache) &#123;<br>        <span class="hljs-keyword">return</span> gen.generate(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cachedValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.generatedClasses.get(gen);<br>        <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进到 AbstractClassGenerator 的 generate() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class <span class="hljs-title function_">generate</span><span class="hljs-params">(ClassLoaderData data)</span> &#123;<br>Class gen;<br><span class="hljs-type">Object</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> CURRENT.get();<br>CURRENT.set(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 1.判断有无classLoader</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> data.getClassLoader();<br><span class="hljs-keyword">if</span> (classLoader == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ClassLoader is null while trying to define class &quot;</span> +<br>getClassName() + <span class="hljs-string">&quot;. It seems that the loader has been expired from a weak reference somehow. &quot;</span> +<br><span class="hljs-string">&quot;Please file an issue at cglib&#x27;s issue tracker.&quot;</span>);<br>&#125;<br>      <span class="hljs-comment">// 2.生成动态代理的类名</span><br><span class="hljs-keyword">synchronized</span> (classLoader) &#123;<br>        <span class="hljs-comment">// 生成代理类名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> generateClassName(data.getUniqueNamePredicate());<br>data.reserveName(name);<br><span class="hljs-built_in">this</span>.setClassName(name);<br>&#125;<br><span class="hljs-keyword">if</span> (attemptLoad) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>gen = classLoader.loadClass(getClassName());<br><span class="hljs-keyword">return</span> gen;<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br><span class="hljs-comment">// ignore</span><br>&#125;<br>&#125;<br>      <span class="hljs-comment">// 3.生成动态代理类的字节码</span><br><span class="hljs-type">byte</span>[] b = strategy.generate(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> ClassNameReader.getClassName(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(b));<br><span class="hljs-type">ProtectionDomain</span> <span class="hljs-variable">protectionDomain</span> <span class="hljs-operator">=</span> getProtectionDomain();<br>      <span class="hljs-comment">// 4.生成class文件</span><br><span class="hljs-keyword">synchronized</span> (classLoader) &#123; <span class="hljs-comment">// just in case</span><br><span class="hljs-comment">// SPRING PATCH BEGIN</span><br>gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain, contextClass);<br><span class="hljs-comment">// SPRING PATCH END</span><br>&#125;<br><span class="hljs-keyword">return</span> gen;<br>&#125;<br><span class="hljs-keyword">catch</span> (RuntimeException | Error ex) &#123;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeGenerationException</span>(ex);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>CURRENT.set(save);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里第三步的 strategy.generate() 方法是 DefaultGeneratorStrategy 中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultGeneratorStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeneratorStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DefaultGeneratorStrategy</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultGeneratorStrategy</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultGeneratorStrategy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] generate(ClassGenerator cg) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DebuggingClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClassVisitor();<br>        <span class="hljs-built_in">this</span>.transform(cg).generateClass(cw);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.transform(cw.toByteArray());<br>    &#125;<br>    ...<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>getClassVistor</code> 调用了asm的接口，生成了一个 <code>DebuggingClassWriter</code> 对象，这里的cg就是之前的 <code>Enhancer</code> 实例，点进 <code>generateClass()</code> 方法，又回到 <code>Enhance</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateClass</span><span class="hljs-params">(ClassVisitor v)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (superclass == <span class="hljs-literal">null</span>) ? Object.class : superclass;<br><br><span class="hljs-keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot subclass final class &quot;</span> + sc.getName());<br><span class="hljs-type">List</span> <span class="hljs-variable">constructors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(Arrays.asList(sc.getDeclaredConstructors()));<br>filterConstructors(sc, constructors);<br><br><span class="hljs-comment">// Order is very important: must add superclass, then</span><br><span class="hljs-comment">// its superclass chain, then each interface and</span><br><span class="hljs-comment">// its superinterfaces.</span><br><span class="hljs-type">List</span> <span class="hljs-variable">actualMethods</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-type">List</span> <span class="hljs-variable">interfaceMethods</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">Set</span> <span class="hljs-variable">forcePublic</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>    <span class="hljs-comment">// 1.得到所有的方法，包括基类、接口</span><br>getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);<br><br><span class="hljs-type">List</span> <span class="hljs-variable">methods</span> <span class="hljs-operator">=</span> CollectionUtils.transform(actualMethods, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>() &#123;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object value)</span> &#123;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> (Method) value;<br><span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Constants.ACC_FINAL<br>| (method.getModifiers()<br>&amp; ~Constants.ACC_ABSTRACT<br>&amp; ~Constants.ACC_NATIVE<br>&amp; ~Constants.ACC_SYNCHRONIZED);<br><span class="hljs-keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;<br>modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;<br>&#125;<br><span class="hljs-keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);<br>&#125;<br>&#125;);<br>    <span class="hljs-comment">// 2.生成字节码，参数还是之前的classWriter</span><br><span class="hljs-comment">// 2.1 这里的className就是之前生成的className</span><br><span class="hljs-type">ClassEmitter</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassEmitter</span>(v);<br><span class="hljs-keyword">if</span> (currentData == <span class="hljs-literal">null</span>) &#123;<br>e.begin_class(Constants.V1_8,<br>Constants.ACC_PUBLIC,<br>getClassName(),<br>Type.getType(sc),<br>(useFactory ?<br>TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :<br>TypeUtils.getTypes(interfaces)),<br>Constants.SOURCE_FILE);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>e.begin_class(Constants.V1_8,<br>Constants.ACC_PUBLIC,<br>getClassName(),<br><span class="hljs-literal">null</span>,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123;FACTORY&#125;,<br>Constants.SOURCE_FILE);<br>&#125;<br><span class="hljs-type">List</span> <span class="hljs-variable">constructorInfo</span> <span class="hljs-operator">=</span> CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());<br>    <span class="hljs-comment">// 2.2 这些都是字段，之后我们会在生成的文件中看到</span><br>e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-literal">null</span>);<br>e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (!interceptDuringConstruction) &#123;<br>e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-literal">null</span>);<br>&#125;<br>e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-literal">null</span>);<br>e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (serialVersionUID != <span class="hljs-literal">null</span>) &#123;<br>e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);<br>&#125;<br>    <span class="hljs-comment">// 2.3 这里就是生成的callback，命名就是CGLIB&amp;CALLBACK_在数组中的序号</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; callbackTypes.length; i++) &#123;<br>e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-comment">// This is declared private to avoid &quot;public field&quot; pollution</span><br>e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">if</span> (currentData == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 2.5 filter在这里发生作用</span><br>emitMethods(e, methods, actualMethods);<br>emitConstructors(e, constructorInfo);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>emitDefaultConstructor(e);<br>&#125;<br>emitSetThreadCallbacks(e);<br>emitSetStaticCallbacks(e);<br>emitBindCallbacks(e);<br><br><span class="hljs-keyword">if</span> (useFactory || currentData != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">int</span>[] keys = getCallbackKeys();<br>emitNewInstanceCallbacks(e);<br>emitNewInstanceCallback(e);<br>emitNewInstanceMultiarg(e, constructorInfo);<br>emitGetCallback(e, keys);<br>emitSetCallback(e, keys);<br>emitGetCallbacks(e);<br>emitSetCallbacks(e);<br>&#125;<br><br>e.end_class();<br>&#125;<br></code></pre></td></tr></table></figure><p>回到前面 <code>AbstractClassGenerator#create</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) &#123;<br>    <span class="hljs-keyword">return</span> firstInstance((Class) obj);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>点进 <code>firstInstance()</code> 方法里，来到 <code>Enhancer#firstInstance</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">firstInstance</span><span class="hljs-params">(Class type)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (classOnly) &#123;<br><span class="hljs-keyword">return</span> type;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> createUsingReflection(type);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createUsingReflection</span><span class="hljs-params">(Class type)</span> &#123;<br>setThreadCallbacks(type, callbacks);<br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-keyword">if</span> (argumentTypes != <span class="hljs-literal">null</span>) &#123;<br><br><span class="hljs-keyword">return</span> ReflectUtils.newInstance(type, argumentTypes, arguments);<br><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-keyword">return</span> ReflectUtils.newInstance(type);<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// clear thread callbacks to allow them to be gc&#x27;d</span><br>setThreadCallbacks(type, <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 <code>ReflectUtils</code> 反射工具类中的方法，完成了动态代理对象的生成</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>动态代理里讲到了反射，在Java中，动态代理主要通过Java反射机制实现，可以在程序运行时动态创建代理对象，无需手动编写代理类</p><p><strong>反射</strong>是Java语言中的一种机制，允许程序在运行时动态地获取、检查和操作类的信息以及对象的属性和方法。Java反射API位于<code>java.lang.reflect</code>包中，它提供了一组类和接口，用于实现反射功能。反射机制为开发者提供了在编译时无法确定的类结构信息，从而实现一些灵活、动态的操作</p><p>反射的基础知识包括以下几个关键概念：</p><ol><li><p><strong>Class类</strong>：<code>java.lang.Class</code> 是Java反射机制的核心类，它代表一个Java类的运行时信息。通过Class类，可以获取类的结构信息，如字段、方法、构造函数、父类、实现的接口等。</p></li><li><p><strong>获取Class对象</strong>：可以通过三种方式来获取一个类的Class对象：</p><ul><li>使用<code>Class.forName(String className)</code>：根据类的全限定名获取Class对象。需要处理<code>ClassNotFoundException</code>异常。</li><li>使用<code>.class</code>语法：例如，<code>String.class</code>获取String类的Class对象。</li><li>使用<code>Object.getClass()</code>方法：通过对象的<code>getClass()</code>方法获取对象所属类的Class对象。</li></ul></li><li><p><strong>获取类的信息</strong>：通过Class对象的方法，可以获取类的结构信息，例如：</p><ul><li><code>getFields()</code>：获取类的公共字段。</li><li><code>getMethods()</code>：获取类的公共方法。</li><li><code>getConstructors()</code>：获取类的公共构造函数。</li><li><code>getDeclaredFields()</code>：获取类的所有字段（包括私有字段）。</li><li><code>getDeclaredMethods()</code>：获取类的所有方法（包括私有方法）。</li></ul></li><li><p><strong>创建对象</strong>：通过Class对象的<code>newInstance()</code>方法，可以创建类的实例。</p></li><li><p><strong>访问字段和方法</strong>：通过反射可以动态地访问和修改类的字段值和调用类的方法。</p></li></ol><p>反射机制的优点在于它提供了动态性和灵活性，使得开发者能够在运行时动态地获取和操作类的信息，避免了在编译时固定的限制。然而，由于反射涉及到动态生成代码和动态检查类型，其性能可能较低，不宜频繁地使用，最好在需要时再使用</p><h5 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h5><p>反射（<em>Reflection</em>）和类加载（<em>Class Loading</em>）是Java中两个重要的概念，它们之间有一定的关系。反射是Java语言提供的一种机制，允许在<strong>运行时动态地获取、检查和操作类的信息</strong>，而<strong>类加载</strong>是<strong>Java虚拟机在将类字节码加载到内存并生成类对象的过程</strong></p><p><strong>类加载是反射的基础</strong>，反射的操作都是基于类加载完成的。在使用反射之前，需要先将类加载到内存中，然后通过类的Class对象来进行反射操作，java类的执行需要经历以下过程：</p><p><strong>编译</strong>：java文件编译后生成 <code>.class</code> 字节码文件 </p><p><strong>类加载</strong>：</p><p><img src="/posts/59835/16139181881678.png" alt="Java 类加载机制- 类加载的时机和过程"></p><ul><li><p><strong>加载</strong>：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 <code>java.lang.Class</code> 对象实例 </p></li><li><p><strong>连接</strong>：</p><ul><li><p>验证：格式（class文件规范） 语义（final类是否有子类） 操作</p></li><li><p>准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。</p></li><li><p>解析：符号引用转化为直接引用，分配地址</p></li></ul></li><li><p><strong>初始化</strong>：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。</p></li></ul><p>Java的反射就是利用上面第二步加载到jvm中的 <code>.class</code> 文件来进行操作。具体来说，在Java虚拟机对类进行加载和连接的过程中，<strong>反射主要在解析阶段进行</strong>，其中<strong>解析的主要目标是将类、字段、方法的符号引用转换为直接引用，建立类之间的关联关系</strong></p><p>以下是一个使用反射调用方法的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Class对象</span><br>        Class&lt;?&gt; clazz = MyClass.class;<br><br>        <span class="hljs-comment">// 获取无参方法的Method对象并调用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">sayHelloMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);<br>        sayHelloMethod.invoke(clazz.newInstance());<br><br>        <span class="hljs-comment">// 获取有参方法的Method对象并调用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">addMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) addMethod.invoke(clazz.newInstance(), <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hello</span>, World!<br><span class="hljs-attribute">Result</span>: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在使用反射调用方法时，要确保方法的名称、参数类型和调用的方法是一致的，否则会抛出 <code>NoSuchMethodException </code>或 <code>IllegalArgumentException</code> 异常</p><p>接下来主要解析一下获取 <code>Method</code> 对象和 <code>Method.invoke()</code> 方法</p><h5 id="获取-Method-对象"><a href="#获取-Method-对象" class="headerlink" title="获取 Method 对象"></a>获取 Method 对象</h5><p>在Java的反射机制中，可以通过<code>Class</code>对象获取<code>Method</code>对象，<code>Method</code>对象代表了类中的方法。通过<code>Method</code>对象可以在运行时动态地调用类的方法。Java反射中获取<code>Method</code>对象的方法主要有以下两个：</p><ol><li><p><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</p><ul><li>用于获取类的公共方法（包括从父类继承的公共方法）。</li><li>参数<code>name</code>是要获取的方法的名称。</li><li>参数<code>parameterTypes</code>是方法的参数类型数组，用于指定方法的参数类型。如果方法有参数，需要将参数类型以Class对象的形式传递进去。如果方法没有参数，可以不传递该参数。</li><li>返回值是一个Method对象，表示与指定名称和参数类型匹配的公共方法。如果未找到对应的方法，则抛出<code>NoSuchMethodException</code>异常。</li></ul></li><li><p><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</p><ul><li>用于获取类自身声明的方法（包括私有方法）。</li><li>参数<code>name</code>是要获取的方法的名称。</li><li>参数<code>parameterTypes</code>是方法的参数类型数组，用于指定方法的参数类型。如果方法有参数，需要将参数类型以Class对象的形式传递进去。如果方法没有参数，可以不传递该参数。</li><li>返回值是一个Method对象，表示与指定名称和参数类型匹配的类自身声明的方法。如果未找到对应的方法，则抛出<code>NoSuchMethodException</code>异常。</li></ul></li></ol><blockquote><p>上述两个方法都有获取复数个的方法，区别就是方法名后有 “<strong>s</strong>” 后缀</p><p><strong>注意事项</strong>：</p><ul><li>当获取私有方法时，使用<code>getDeclaredMethod()</code>方法；当获取公共方法时，使用<code>getMethod()</code>方法。</li><li>如果获取的方法是私有方法，需要通过<code>setAccessible(true)</code>方法将其设置为可访问，以允许访问私有方法。</li></ul></blockquote><p>其实不管是<code>getMethod</code>还是<code>getDeclaredMethod</code>，底层都调用了同一个方法：<code>privateGetDeclaredMethods</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">privateGetMethodRecursive</span><span class="hljs-params">(String name,</span><br><span class="hljs-params">            Class&lt;?&gt;[] parameterTypes,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> includeStaticMethods,</span><br><span class="hljs-params">            MethodArray allInterfaceCandidates)</span> &#123;<br><br>        <span class="hljs-comment">// Must _not_ return root methods</span><br>        Method res;<br>        <span class="hljs-comment">// Search declared public methods 搜索本来中声明的公共方法</span><br>        <span class="hljs-keyword">if</span> ((res = searchMethods(privateGetDeclaredMethods(<span class="hljs-literal">true</span>),<br>                                 name,<br>                                 parameterTypes)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))<br>                <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 如果res为空，继续向父类搜索</span><br>        <span class="hljs-comment">// Search superclass&#x27;s methods</span><br>        <span class="hljs-keyword">if</span> (!isInterface()) &#123;<br>            Class&lt;? <span class="hljs-built_in">super</span> T&gt; c = getSuperclass();<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 递归调用getMethod0，获取父类的方法实现</span><br>                <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">true</span>)) != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// res仍然为空，继续向接口搜索</span><br>        <span class="hljs-comment">// Search superinterfaces&#x27; methods</span><br>        Class&lt;?&gt;[] interfaces = getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : interfaces)<br>            <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">false</span>)) != <span class="hljs-literal">null</span>)<br>                allInterfaceCandidates.add(res);<br>        <span class="hljs-comment">// Not found</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后在看看 <code>searchMethods()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">searchMethods</span><span class="hljs-params">(Method[] methods,</span><br><span class="hljs-params">                                    String name,</span><br><span class="hljs-params">                                    Class&lt;?&gt;[] parameterTypes)</span><br>    &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">internedName</span> <span class="hljs-operator">=</span> name.intern();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> methods[i];<br>            <span class="hljs-keyword">if</span> (m.getName() == internedName<br>                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())<br>                &amp;&amp; (res == <span class="hljs-literal">null</span><br>                    || res.getReturnType().isAssignableFrom(m.getReturnType())))<br>                res = m;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (res == <span class="hljs-literal">null</span> ? res : getReflectionFactory().copyMethod(res));<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中循环了 Method[] methods 这个数组，而这个参数是由 privateGetDeclaredMethods(boolean <em>publicOnly</em>) 获得的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method[] privateGetDeclaredMethods(<span class="hljs-type">boolean</span> publicOnly) &#123;<br>    checkInitted();<br>    Method[] res;<br>    <span class="hljs-comment">// 1.ReflectionData 存储反射数据的缓存结构</span><br>    ReflectionData&lt;T&gt; rd = reflectionData();<br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 2.先从缓存中获取methods</span><br>        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// No cached value available; request value from VM</span><br>    <span class="hljs-comment">// 3.没有缓存，通过 JVM 获取，native方法</span><br>    res = Reflection.filterMethods(<span class="hljs-built_in">this</span>, getDeclaredMethods0(publicOnly));<br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>            rd.declaredPublicMethods = res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rd.declaredMethods = res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 <code>ReflectionData&lt;T&gt;</code>是类<code>Class</code>的静态内部类，<code>&lt;T&gt;</code>表示泛型，为具体的类对象。该缓存数据结构中存储了类的所有信息。<code>redefinedCount</code>是类的重定义次数，可以理解为缓存的版本号，每一个类对象理论上都会有（被垃圾回收或从来没被加载过就没没有）一个<code>ReflectionData&lt;T&gt;</code>的缓存，通过 <code>reflectionData()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lazily create and cache ReflectionData</span><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">reflectionData</span><span class="hljs-params">()</span> &#123;<br>    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="hljs-built_in">this</span>.reflectionData;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">classRedefinedCount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.classRedefinedCount;<br>    ReflectionData&lt;T&gt; rd;<br>    <span class="hljs-keyword">if</span> (useCaches &amp;&amp;<br>        reflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>        (rd = reflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>        rd.redefinedCount == classRedefinedCount) &#123;<br>        <span class="hljs-keyword">return</span> rd;<br>    &#125;<br>    <span class="hljs-comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span><br>    <span class="hljs-comment">// -&gt; create and replace new instance</span><br>    <span class="hljs-keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);<br>&#125;<br><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">newReflectionData</span><span class="hljs-params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData, <span class="hljs-type">int</span> classRedefinedCount)</span> &#123;<br>    <span class="hljs-comment">// 不使用缓存则直接返回null</span><br>    <span class="hljs-keyword">if</span> (!useCaches) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 使用while+CAS方式更新数据，创建一个新的ReflectionData，如果更新成功直接返回</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ReflectionData&lt;T&gt; rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionData</span>&lt;&gt;(classRedefinedCount);<br>        <span class="hljs-comment">// try to CAS it...</span><br>        <span class="hljs-keyword">if</span> (Atomic.casReflectionData(<span class="hljs-built_in">this</span>, oldReflectionData, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(rd))) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>        <span class="hljs-comment">// else retry</span><br>        <span class="hljs-comment">// 获取到旧的reflectionData和classRedefinedCount的值，如果旧的值不为null, 并且缓存未失效，说明其他线程更新成功了，直接返回</span><br>        oldReflectionData = <span class="hljs-built_in">this</span>.reflectionData;<br>        classRedefinedCount = <span class="hljs-built_in">this</span>.classRedefinedCount;<br>        <span class="hljs-keyword">if</span> (oldReflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>            (rd = oldReflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Method-invoke"><a href="#Method-invoke" class="headerlink" title="Method.invoke()"></a>Method.invoke()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span><br>    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,<br>       InvocationTargetException<br>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-comment">// 1.检查权限，如果 override == true，就跳过检查</span><br>        <span class="hljs-comment">// 通常在 Method#invoke 之前，会调用 Method#setAccessible(true)，就是设置 override 值为 true</span><br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取 MethodAccessor</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">ma</span> <span class="hljs-operator">=</span> methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 2.1为空时创建MethodAccessor</span><br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-comment">// 3.调用 MethodAccessor.invoke</span><br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会获取 <code>MethodAccessor</code> ，这个在之前 <code>searchMethods()</code> 最后会调用 <code>Method#copy</code> 会给 <code>Method</code> 的 <code>methodAccessor</code> 赋值，如果为空则去创建 <code>MethodAccessor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MethodAccessor <span class="hljs-title function_">acquireMethodAccessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// First check to see if one has been created yet, and take it</span><br>    <span class="hljs-comment">// if so</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) tmp = root.getMethodAccessor();<br>    <span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">null</span>) &#123;<br>        methodAccessor = tmp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Otherwise fabricate one and propagate it up to the root</span><br>        tmp = reflectionFactory.newMethodAccessor(<span class="hljs-built_in">this</span>);<br>        setMethodAccessor(tmp);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-keyword">public</span> MethodAccessor <span class="hljs-title function_">newMethodAccessor</span><span class="hljs-params">(Method var1)</span> &#123;<br>    checkInitted();<br>    <span class="hljs-keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">NativeMethodAccessorImpl</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span>(var1);<br>        <span class="hljs-type">DelegatingMethodAccessorImpl</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingMethodAccessorImpl</span>(var2);<br>        var2.setParent(var3);<br>        <span class="hljs-keyword">return</span> var3;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会先查找 <em>root</em> 的 <code>MethodAccessor</code>，这里的 <em>root</em> 在上面 <code>Method#copy</code> 中设置过。如果还是没有找到，就去创建 <code>MethodAccessor</code></p><p>在 <code>newMethodAccessor()</code> 方法里可以看到一共有三种 <code>MethodAccessor</code>：</p><ul><li><code>MethodAccessorImpl</code></li><li><code>NativeMethodAccessorImpl</code></li><li><code>DelegatingMethodAccessorImpl</code></li></ul><p>采用哪种 <code>MethodAccessor</code> 根据 <code>noInflation</code> 进行判断，<code>noInflation</code> 默认值为 <code>false</code>，只有指定了 <code>sun.reflect.noInflation</code> 属性为 <code>true</code>，才会采用 <code>MethodAccessorImpl</code> ，所以默认会调用 <code>NativeMethodAccessorImpl</code></p><p><code>MethodAccessorImpl</code> 是通过动态生成字节码来进行方法调用的，是 Java 版本的 <code>MethodAccessor</code></p><p><code>DelegatingMethodAccessorImpl</code> 就是单纯的代理，真正的实现还是 <code>NativeMethodAccessorImpl</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> MethodAccessorImpl delegate;<br> <br>    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;<br>        setDelegate(delegate);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException<br>    &#123;<br>        <span class="hljs-keyword">return</span> delegate.invoke(obj, args);<br>    &#125;<br> <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDelegate</span><span class="hljs-params">(MethodAccessorImpl delegate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NativeMethodAccessorImpl</code> 是 <em>Native</em> 版本的 <code>MethodAccessor</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException<br>    &#123;<br>        <span class="hljs-comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span><br>        <span class="hljs-comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span><br>        <span class="hljs-comment">// found from the generated bytecode.</span><br>        <span class="hljs-keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()<br>                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// Java 版本的 MethodAccessor</span><br>            <span class="hljs-type">MethodAccessorImpl</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> (MethodAccessorImpl)<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>().<br>                    generateMethod(method.getDeclaringClass(),<br>                                   method.getName(),<br>                                   method.getParameterTypes(),<br>                                   method.getReturnType(),<br>                                   method.getExceptionTypes(),<br>                                   method.getModifiers());<br>            parent.setDelegate(acc);<br>        &#125;<br>        <span class="hljs-comment">// Native 版本调用</span><br>        <span class="hljs-keyword">return</span> invoke0(method, obj, args);<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">invoke0</span><span class="hljs-params">(Method m, Object obj, Object[] args)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>NativeMethodAccessorImpl</code> 的实现中，我们可以看到，有一个 <code>numInvocations</code> 阀值控制，<code>numInvocations</code> 表示调用次数。如果 <code>numInvocations</code> 大于 15（默认阀值是 15），那么就使用 Java 版本的 <code>MethodAccessorImpl</code>。 为什么采用这个策略呢，可以 JDK 中的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &quot;Inflation&quot; mechanism. Loading bytecodes to implement</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Method.invoke() and Constructor.newInstance() currently costs</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3-4x more than an invocation via native code for the first</span><br><span class="hljs-comment">// invocation (though subsequent invocations have been benchmarked</span><br><span class="hljs-comment">// to be over 20x faster). Unfortunately this cost increases</span><br><span class="hljs-comment">// startup time for certain applications that use reflection</span><br><span class="hljs-comment">// intensively (but only once per class) to bootstrap themselves.</span><br><span class="hljs-comment">// To avoid this penalty we reuse the existing JVM entry points</span><br><span class="hljs-comment">// for the first few invocations of Methods and Constructors and</span><br><span class="hljs-comment">// then switch to the bytecode-based implementations.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Package-private to be accessible to NativeMethodAccessorImpl</span><br><span class="hljs-comment">// and NativeConstructorAccessorImpl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">noInflation</span>        <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>比起通过本地代码进行的首次调用，方法和构造函数的首次调用要快3-4倍（虽然后续的调用已经经过基准测试，速度可以达到原来的20倍以上）。然而，这个过程会增加某些密集使用反射（但每个类仅一次）来引导自身的应用程序的启动时间。为了避免这种性能损耗，我们在方法和构造函数的前几次调用中重用现有的JVM入口点，然后切换到基于字节码的实现</p><p><code>Method.invoke()</code> 的最后，调用 <code>MethodAccessor#invoke</code> 实现方法的调用</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>说完了前置知识，终于可以开始正题了</p><p>在传统的面向对象编程中，系统的功能通常以对象的形式组织，但某些功能可能会散布在整个应用程序中，而不局限于单个对象或类。这些功能被称为横切关注点，如日志记录、安全性、事务处理等。AOP的目标就是通过把这些横切关注点从核心业务逻辑中分离出来，形成独立的模块，并通过特定的方式将其织入到应用程序中。通俗一点表达就是：<strong>AOP 要实现的是在我们原来写的代码的基础上，进行一定的包装，如在方法执行前、方法返回后、方法抛出异常后等地方进行一定的拦截处理或者叫增强处理</strong></p><p>作为 Java 开发者都很熟悉 <strong>AspectJ</strong> 这个词，甚至于在提到 AOP 的时候，想到的往往就是 AspectJ。这里简单的将 AspectJ 和 Spring AOP 做个对比：</p><h5 id="Spring-AOP："><a href="#Spring-AOP：" class="headerlink" title="Spring AOP："></a><strong>Spring AOP：</strong></h5><ul><li>它基于动态代理来实现。默认来说，如果使用接口，它会采用 JDK 提供的动态代理实现，如果没有接口，则会使用 CGLib 实现</li><li>Spring 3.2 以后，spring-core 直接就把 CGLIB 和 ASM 的源码包括进来了，所以平时开发时不需要显式引入这两个依赖</li><li>如果你是 web 开发者，有些时候可能需要的是一个 Filter 或一个 Interceptor，而不一定是 AOP</li><li>Spring AOP 只能作用于 Spring 容器中的 Bean，它是使用纯粹的 Java 代码实现的，只能作用于 bean 的方法</li><li>Spring 提供了 AspectJ 的支持，但一般来说只用 Spring AOP 就够</li><li>很多人会对比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好</li></ul><h5 id="AspectJ："><a href="#AspectJ：" class="headerlink" title="AspectJ："></a><strong>AspectJ：</strong></h5><ul><li><p>AspectJ 出身也是名门，来自于 Eclipse 基金会，<a href="https://www.eclipse.org/aspectj">https://www.eclipse.org/aspectj</a></p></li><li><p>属于静态织入，它是通过修改代码来实现的，它的织入时机可以是：</p><ul><li><em><strong>Compile-time weaving</strong></em>：编译期织入，如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</li><li><em><strong>Post-compile weaving</strong></em>：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</li><li><em><strong>Load-time weaving</strong></em>：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法。1、自定义类加载器来干这个，这个应该是最容易想到的办法，在被织入类加载到 JVM 前去对它进行加载，这样就可以在加载的时候定义行为了。2、在 JVM 启动的时候指定 AspectJ 提供的 agent：<code>-javaagent:xxx/xxx/aspectjweaver.jar</code>。</li></ul></li><li><p>AspectJ 能干很多 Spring AOP 干不了的事情，它是 <strong>AOP 编程的完全解决方案</strong>。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p></li><li><p>因为 AspectJ 在实际代码运行前完成了织入，所以大家会说它生成的类是没有额外运行时开销的</p></li></ul><h5 id="AOP的关键概念："><a href="#AOP的关键概念：" class="headerlink" title="AOP的关键概念："></a><strong>AOP的关键概念：</strong></h5><ol><li><p>切面（Aspect）：切面是横切关注点的抽象表示，它包含了与某个横切关注点相关的一组通用功能。比如，日志记录是一个切面，它可以包含日志输出的功能</p></li><li><p>连接点（Join Point）：连接点是应用程序中可能被切面影响的点。在Java中，连接点通常表示为方法的执行或异常的抛出</p></li><li><p>通知（Advice）：通知是切面在特定连接点上执行的具体动作。通知包括前置通知（Before）、后置通知（After）、返回通知（After Returning）、异常通知（After Throwing）和环绕通知（Around）等</p></li><li><p>切点（Pointcut）：切点是一组连接点的集合，它定义了切面在哪些连接点上起作用。切点使用表达式来匹配连接点，从而确定在哪些连接点上应用通知</p></li><li><p>引入（Introduction）：引入允许在不修改代码的情况下向现有类添加新的方法和属性</p></li><li><p>织入（Weaving）：织入是将切面应用到目标对象并创建新的代理对象的过程。织入可以在编译时、类加载时或运行时进行</p></li></ol><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>这里介绍的 Spring AOP 是纯的 Spring 代码，和 AspectJ 没什么关系，但是 Spring 延用了 AspectJ 中的概念，包括使用了 AspectJ 提供的 jar 包中的注解，但是不依赖于其实现功能</p><blockquote><p>后面介绍的如 @Aspect、@Pointcut、@Before、@After 等注解都是来自于 AspectJ，但是功能的实现是纯 Spring AOP 自己实现的</p></blockquote><p>在 Spring 的容器中，我们面向的对象是一个个的 bean 实例。我们可以简单理解 bean 是 BeanDefinition 的实例，Spring 会根据 BeanDefinition 中的信息为我们生产合适的 bean 实例出来</p><p>当我们需要使用 bean 的时候，通过 IOC 容器的 <code>getBean()</code> 方法从容器中获取 bean 实例，只不过大部分的场景下，我们都用了依赖注入，所以很少手动调用 <code>getBean()</code> 方法</p><p>Spring AOP 的原理很简单，就是<strong>动态代理</strong>，它和 AspectJ 不一样，AspectJ 是直接修改掉你的字节码</p><p>代理模式很简单，<strong>接口 + 真实实现类 + 代理类</strong>，其中 <strong>真实实现类</strong> 和 <strong>代理类</strong> 都要实现接口，实例化的时候要使用代理类。所以，<strong>Spring AOP 需要做的是生成这么一个代理类</strong>，然后<strong>替换掉</strong>真实实现类来对外提供服务</p><p><strong>替换</strong>这个操作在 Spring IOC 容器中非常容易实现，就是在 <code>getBean()</code> 的时候返回的实际上是代理类的实例，而这个代理类我们自己没写代码，<strong>它是 Spring 采用 JDK Proxy 或 CGLIB 动态生成的</strong></p><h4 id="Spring-2-0-AspectJ-配置"><a href="#Spring-2-0-AspectJ-配置" class="headerlink" title="Spring 2.0 @AspectJ 配置"></a>Spring 2.0 @AspectJ 配置</h4><p>在 Spring 2.0 之后引入了 <code>@AspectJ</code> 和 <code>Schema-based</code> 的两种配置方式，这里<strong>仅介绍</strong> <code>AspectJ</code> 注解的方式。首先，我们需要依赖 <code>aspectjweaver.jar</code> 这个包，这个包来自于 <code>AspectJ</code>：</p><blockquote><p>并不是说基于 AspectJ 实现的，而仅仅是使用了 AspectJ 中的概念，包括使用的注解也是直接来自于 AspectJ 的包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是使用 Spring Boot 的话，添加以下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先，我们需要<strong>开启</strong> <code>@AspectJ</code> 的注解配置方式：</p><ul><li>使用 <code>@EnableAspectJAutoProxy</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>一旦开启了上面的配置，那么所有使用 @Aspect 注解的 <strong>bean</strong> 都会被 Spring 当做<strong>用来实现 AOP 的配置类</strong>，我们称之为一个 <strong>Aspect</strong></p><blockquote><p>注意，<code>@Aspect</code> 注解要作用在 bean 上面，不管是使用 <code>@Component</code> 等注解方式，还是在 xml 中配置 bean，首先它需要是一个 bean</p><p><strong>有些时候并不需要</strong>加这个注解就能使AOP生效，原因是依赖中直接或者间接的引入了 <code>spring-boot-autoconfigure</code>，这是自动装配的依赖，也就是会读取其下的 <code>spring.factories</code> 文件，在该文件中有下面的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><br><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.aop.**AopAutoConfiguration**</span><br></code></pre></td></tr></table></figure><p>则会加载 <code>AopAutoConfiguration</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Auto-configuration for Spring&#x27;s AOP support. Equivalent to enabling @EnableAspectJAutoProxy in your configuration.</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopAutoConfiguration</span> &#123;<br>​    ....<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认等同于 <code>@EnableAspectJAutoProxy</code></p></blockquote><ol><li>创建一个接口和实现类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(String username)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-comment">// 模拟添加用户的操作</span><br>        System.out.println(<span class="hljs-string">&quot;User added: &quot;</span> + username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个切面类，用于添加横切逻辑，并定义<strong>Pointcut</strong>表达式：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-comment">// 定义Pointcut表达式，选择com.example.UserService接口的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.UserService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userServiceMethods</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，<code>@Pointcut</code> 中使用了 <strong>execution</strong> 来正则匹配方法签名，这也是最常用的，除了 execution，我们再看看其他的几个比较常用的匹配方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任意公共方法的执行：</span><br>execution（<span class="hljs-keyword">public</span> * *（..））<br><br><span class="hljs-comment">// 任何一个名字以“set”开始的方法的执行：</span><br>execution（* set*（..））<br><br><span class="hljs-comment">// AccountService接口定义的任意方法的执行：</span><br>execution（* com.xyz.service.AccountService.*（..））<br><br><span class="hljs-comment">// 在service包中定义的任意方法的执行：</span><br>execution（* com.xyz.service.*.*（..））<br><br><span class="hljs-comment">// 在service包或其子包中定义的任意方法的执行：</span><br>execution（* com.xyz.service..*.*（..））<br><br><span class="hljs-comment">// 在service包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service.*）<br><br><span class="hljs-comment">// 在service包或其子包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service..*）<br><br><span class="hljs-comment">// 实现了AccountService接口的代理对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-built_in">this</span>（com.xyz.service.AccountService）<span class="hljs-comment">// &#x27;this&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 实现AccountService接口的目标对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br>target（com.xyz.service.AccountService） <span class="hljs-comment">// &#x27;target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点（在Spring AOP中只是方法执行）</span><br>args（java.io.Serializable） <span class="hljs-comment">// &#x27;args&#x27;在绑定表单中更加常用; 请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args版本只有在动态运行时候传入参数是Serializable时才匹配，而execution版本在方法签名中声明只有一个 Serializable类型的参数时候匹配。</span><br><br><span class="hljs-comment">// 目标对象中有一个 @Transactional 注解的任意连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@target</span>（org.springframework.transaction.annotation.Transactional）<span class="hljs-comment">// &#x27;@target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-meta">@within</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@within&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个执行的方法有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@annotation</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@annotation&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点（在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@args</span>（com.xyz.security.Classified） <span class="hljs-comment">// &#x27;@args&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个在名为&#x27;tradeService&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（tradeService）<br><br><span class="hljs-comment">// 任何一个在名字匹配通配符表达式&#x27;*Service&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（*Service）<br></code></pre></td></tr></table></figure><p>此外Spring 支持如下三个逻辑运算符来组合切入点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;：要求连接点同时匹配两个切入点表达式<br>||：要求连接点匹配任意个切入点表达式<br>!:：要求连接点不匹配指定的切入点表达式<br></code></pre></td></tr></table></figure><p>Spring AOP 用户可能会经常使用 execution 切入点指示符。执行表达式的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern） <span class="hljs-keyword">throws</span>-pattern?）<br></code></pre></td></tr></table></figure><ul><li>ret-type-pattern 返回类型模式, name-pattern名字模式和param-pattern参数模式是必选的， 其它部分都是可选的。返回类型模式决定了方法的返回类型必须依次匹配一个连接点。 你会使用的最频繁的返回类型模式是<code>*</code>，<strong>它代表了匹配任意的返回类型</strong>。</li><li>declaring-type-pattern, 一个全限定的类型名将只会匹配返回给定类型的方法。</li><li>name-pattern 名字模式匹配的是方法名。 你可以使用<code>*</code>通配符作为所有或者部分命名模式。</li><li>param-pattern 参数模式稍微有点复杂：()匹配了一个不接受任何参数的方法， 而(..)匹配了一个接受任意数量参数的方法（零或者更多）。 模式(<em>)匹配了一个接受一个任何类型的参数的方法。 模式(</em>,String)匹配了一个接受两个参数的方法，第一个可以是任意类型， 第二个则必须是String类型</li></ul><p>上面匹配中，通常 “.” 代表一个包名，”..” 代表包及其子包，方法参数任意匹配使用两个点 “..”</p><ol start="3"><li><strong>配置 Advice</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdviceExample</span> &#123;<br><br>    <span class="hljs-comment">// 使用定义的Pointcut，在所有方法执行后添加额外逻辑</span><br>    <span class="hljs-meta">@After(&quot;com.javadoop.aop.LoggingAspect.userServiceMethods()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterExecution</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method execution completed.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个简单的Main类来测试：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br><br>        userService.addUser(<span class="hljs-string">&quot;John Doe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行Main类时，你将看到类似以下输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">User added: John Doe<br><span class="hljs-keyword">Method</span> <span class="hljs-title function_">execution</span> <span class="hljs-title function_">completed</span>.<br></code></pre></td></tr></table></figure><p>这表明 <code>addUser</code> 方法执行后，切面中定义的 <code>logAfterExecution</code> 方法被调用。使用 <code>Pointcut</code>，你可以更细粒度地控制切入点，而不是直接在特定方法上定义切面逻辑</p><p>如果 <code>Advice</code> 方法需要获取入参，Spring 提供了非常简单的获取入参的方法，使用 <code>org.aspectj.lang.JoinPoint</code> 作为 <code>Advice</code> 的第一个参数即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.javadoop.aop.LoggingAspect.userServiceMethods()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logArgs</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法执行前，打印入参：&quot;</span> + Arrays.toString(joinPoint.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意 <code>org.aspectj.lang.JoinPoint</code> 的使用方法：</p><ul><li>必须放置在第一个参数上</li><li>如果是 @Around，我们通常会使用其子类 <code>ProceedingJoinPoint</code>，因为它有 <code>procceed()</code>&#x2F; <code>procceed(args[])</code> 方法。</li></ul></blockquote><h4 id="AOP的原理"><a href="#AOP的原理" class="headerlink" title="AOP的原理"></a>AOP的原理</h4><p>所以理解Spring AOP的初始化必须要先理解Spring IOC的初始化</p><h5 id="基于注解的切面代理创建"><a href="#基于注解的切面代理创建" class="headerlink" title="基于注解的切面代理创建"></a>基于注解的切面代理创建</h5><p>这里直接从之前说到的 <code>@EnableAspectJAutoProxy</code> 切入，它 @import 了 <code>AspectJAutoProxyRegistrar.class</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="hljs-comment"> * of the @&#123;<span class="hljs-doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(</span><br><span class="hljs-params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br><br>    <span class="hljs-comment">// 注册 AspectJAnnotationAutoProxyCreator，如果需要的话</span><br>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br>    ... <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry)</code> 这个方法点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br><span class="hljs-keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(</span><br><span class="hljs-params">BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br>   <span class="hljs-comment">// 注册 AnnotationAwareAspectJAutoProxyCreator.class</span><br><span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerOrEscalateApcAsRequired</span><span class="hljs-params">(</span><br><span class="hljs-params">Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br>Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br><br>   <span class="hljs-comment">// 如果名为 org.springframework.aop.config.internalAutoProxyCreator 的 bean 已经在册</span><br><span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br><span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">apcDefinition</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>     <span class="hljs-comment">// 已经在册的 ProxyCreator 与当前期望的类型不一致，则依据优先级进行选择</span><br><span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">currentPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(apcDefinition.getBeanClassName());<br><span class="hljs-type">int</span> <span class="hljs-variable">requiredPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(cls);<br>       <span class="hljs-comment">// 选择优先级高的 ProxyCreator 更新注册</span><br><span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) &#123;<br>apcDefinition.setBeanClassName(cls.getName());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br>   <span class="hljs-comment">// 没有对应在册的 ProxyCreator，注册一个新的</span><br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(cls);<br>beanDefinition.setSource(source);<br>beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);<br>beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br><span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结下来就是注册了一个名为 <code>org.springframework.aop.config.internalAutoProxyCreator</code> 的 <code>BeanDefinition</code>，我们称之为代理创建器（<em>ProxyCreator</em>）。这里使用的默认实现为 <code>AnnotationAwareAspectJAutoProxyCreator.class</code> 类，如果存在多个候选实现，则选择优先级最高的进行注册</p><p>然后是 <code>AspectJAutoProxyRegistrar#registerBeanDefinitions</code> 后面省略的部分是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>&#125;<br><span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里配置的 <code>proxy-target-class</code> 和 <code>expose-proxy</code> 属性添加到对应 BeanDefinition 的属性列表中</p><p>这是 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的继承关系图：</p><p><img src="/posts/59835/image-20230721185238617.png" alt="image-20230721185238617"></p><p>看得出它实现了两类接口：<code>BeanPostProcessor</code> 和 <code>Aware</code></p><p><code>BeanPostProcessor</code> 接口我们知道在容器启动过程中会在初始化 bean 实例的前后分别调用 <code>BeanPostProcessor</code> 中定义的 <code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 两个方法。针对这两个方法的实现主要位于继承链的 <code>AbstractAutoProxyCreator</code> 类中，并且<strong>主要是</strong>实现了 <code>BeanPostProcessor#postProcessAfterInitialization</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a proxy with the configured interceptors if the bean is</span><br><span class="hljs-comment"> * identified as one to proxy by the subclass.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getAdvicesAndAdvisorsForBean</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> &#123;<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-comment">// 如果 beanName 不为空则直接使用 beanName（FactoryBean 则使用 &amp;&#123;beanName&#125;），否则使用 bean 的 className</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>       <span class="hljs-comment">// 尝试对 bean 进行增强，创建返回增强后的代理对象</span><br><span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的核心在于调用 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法，尝试基于 AOP 配置对当前 bean 进行增强，并返回增强后的代理对象。方法 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> &#123;<br><span class="hljs-comment">// 已经处理过，直接返回</span><br>   <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>   <span class="hljs-comment">// 不需要进行增强的 bean 实例，直接跳过</span><br><span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-built_in">this</span>.advisedBeans.get(cacheKey))) &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>   <span class="hljs-comment">// 对于 AOP 的基础支撑类，或者指定不需要被代理的类，设置为不进行代理</span><br><span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br><span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-comment">// Create proxy if we have advice.</span><br>   <span class="hljs-comment">// 获取适用于当前 bean 的 Advisor</span><br>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-literal">null</span>);<br>   <span class="hljs-comment">// 基于获取到的 Advisor 为当前 bean 创建代理对象</span><br><span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br><span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>     <span class="hljs-comment">// 创建代理对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(<br>bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(bean));<br><span class="hljs-built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br><span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法主要的工作是对 bean 实例进行筛选，过滤掉那些已经增强过的、支持 AOP 基础运行的，以及指定不需要被代理的 bean 实例。对于剩下的 bean 实例来说，首先会调用 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法获取适用于当前 bean 的增强器（<em>Advisor</em>），并基于这些增强器调用 <code>AbstractAutoProxyCreator#createProxy</code> 方法为当前 bean 创建增强后的代理对象</p><h5 id="筛选适用于-bean-的增强器"><a href="#筛选适用于-bean-的增强器" class="headerlink" title="筛选适用于 bean 的增强器"></a>筛选适用于 bean 的增强器</h5><p>首先来看一下筛选适用于当前 bean 的合格增强器的过程，实现位于 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>        Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;<br>    <span class="hljs-comment">// 获取适用于当前 bean 的 Advisor</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">this</span>.findEligibleAdvisors(beanClass, beanName);<br>    <span class="hljs-comment">// 没有合格的 Advisor，不进行代理</span><br>    <span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> DO_NOT_PROXY; <span class="hljs-comment">// null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors.toArray();<br>&#125;<br><br><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    <span class="hljs-comment">// 获取所有候选的 Advisor（包括注解的、XML 中配置的）</span><br>    List&lt;Advisor&gt; candidateAdvisors = <span class="hljs-built_in">this</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// 从所有 Advisor 中寻找适用于当前 bean 的 Advisor</span><br>    List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-built_in">this</span>.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>    <span class="hljs-comment">// 如果 Advisor 不为空，则在最前面追加一个 ExposeInvocationInterceptor</span><br>    <span class="hljs-built_in">this</span>.extendAdvisors(eligibleAdvisors);<br>    <span class="hljs-comment">// 对 Advisor 进行排序</span><br>    <span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;<br>        eligibleAdvisors = <span class="hljs-built_in">this</span>.sortAdvisors(eligibleAdvisors);<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个方法的执行流程很简单，获取所有的候选增强器，并从中找出适用于当前 bean 的增强器。首先来看获取所有候选增强器的过程，实现位于 <code>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findCandidateAdvisors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用父类的 findCandidateAdvisors 方法，兼容父类查找 Advisor 的规则</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// 获取所有注解定义的 Advisor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder != <span class="hljs-literal">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法首先调用了父类的实现，这主要是为了兼容父类查找候选增强器的规则，例如我们的示例中使用的是注解方式定义的增强，但是父类却是基于 XML 配置的方式查找增强器，这里的兼容能够让我们在以注解方式编程时兼容其它以 XML 配置的方式定义的增强。下面还是将主要精力放在解析注解式增强定义上，该过程位于 <code>BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</code> 方法中。不过该方法实现比较冗长，但是逻辑却很清晰，所以这里主要概括一下其执行流程：</p><ol><li>获取所有类型 bean 实例对应的 beanName 集合；</li><li>过滤不是切面类型的 bean 对应的 beanName，即没有被 <code>@Aspect</code> 注解，或包含以 <code>ajc$</code> 开头的字段，同时支持覆盖 <code>BeanFactoryAspectJAdvisorsBuilder#isEligibleBean</code> 方法扩展过滤规则；</li><li>对于切面 bean 类型，获取 bean 中定义的所有切点，并为每个切点生成对应的增强器；</li><li>缓存解析得到的增强器，避免重复解析。</li></ol><p>上述流程中我们重点看一下过程 3，实现位于 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title function_">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> &#123;<br>    <span class="hljs-comment">// 获取切面 aspect 对应的 class 和 beanName</span><br>    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">aspectName</span> <span class="hljs-operator">=</span> aspectInstanceFactory.getAspectMetadata().getAspectName();<br>    <span class="hljs-comment">// 校验切面定义的合法性</span><br>    <span class="hljs-built_in">this</span>.validate(aspectClass);<br><br>    <span class="hljs-comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br>    <span class="hljs-comment">// so that it will only instantiate once.</span><br>    <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">lazySingletonAspectInstanceFactory</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingletonAspectInstanceFactoryDecorator</span>(aspectInstanceFactory);<br><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 1. 遍历处理切面中除被 @Pointcut 注解以外的方法</span><br>    <span class="hljs-keyword">for</span> (Method method : <span class="hljs-built_in">this</span>.getAdvisorMethods(aspectClass)) &#123;<br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 如果增强器不为空，同时又配置了增强延迟初始化，则需要追加实例化增强器 SyntheticInstantiationAdvisor</span><br>    <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;<br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">instantiationAdvisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticInstantiationAdvisor</span>(lazySingletonAspectInstanceFactory);<br>        advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 获取所有引介增强定义</span><br>    <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>        <span class="hljs-comment">// 创建引介增强器 DeclareParentsAdvisor</span><br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getDeclareParentsAdvisor(field);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述实现的整体执行流程如代码注释。拿到一个切面定义，Spring 首先会遍历获取切面中的增强方法，即被 <code>@Around</code>、<code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>，以及 <code>@AfterThrowing</code> 注解的方法，并调用 <code>ReflectiveAspectJAdvisorFactory#getAdvisor</code> 方法为每一个增强方法生成对应的增强器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod,</span><br><span class="hljs-params">                          MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> declarationOrderInAspect,</span><br><span class="hljs-params">                          String aspectName)</span> &#123;<br><br>    <span class="hljs-comment">// 校验切面类定义的合法性</span><br>    <span class="hljs-built_in">this</span>.validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br><br>    <span class="hljs-comment">// 获取注解配置的切点信息，封装成 AspectJExpressionPointcut 对象</span><br>    <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">expressionPointcut</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPointcut(<br>            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>    <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 依据切点信息生成对应的增强器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(<br>            expressionPointcut, candidateAdviceMethod, <span class="hljs-built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述实现首先对当前切面定义执行合法性校验，如果切面配置合法则获取目标方法上的切点注解定义，并封装成 AspectJExpressionPointcut 对象。该过程位于 <code>ReflectiveAspectJAdvisorFactory#getPointcut</code> 方法中，实现比较简单。</p><p>拿到切点注解定义之后，方法会依据切点的配置信息使用 InstantiationModelAwarePointcutAdvisorImpl 实现类创建对应的增强器。类 InstantiationModelAwarePointcutAdvisorImpl 的实例化过程除了初始化了一些基本属性之外，主要是调用了 <code>InstantiationModelAwarePointcutAdvisorImpl#instantiateAdvice</code> 方法，依据增强类型对增强器实施相应的初始化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Advice <span class="hljs-title function_">instantiateAdvice</span><span class="hljs-params">(AspectJExpressionPointcut pointcut)</span> &#123;<br>    <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aspectJAdvisorFactory.getAdvice(<br>            <span class="hljs-built_in">this</span>.aspectJAdviceMethod, pointcut, <span class="hljs-built_in">this</span>.aspectInstanceFactory, <span class="hljs-built_in">this</span>.declarationOrder, <span class="hljs-built_in">this</span>.aspectName);<br>    <span class="hljs-keyword">return</span> (advice != <span class="hljs-literal">null</span> ? advice : EMPTY_ADVICE);<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvice</span><br><span class="hljs-keyword">public</span> Advice <span class="hljs-title function_">getAdvice</span><span class="hljs-params">(Method candidateAdviceMethod,</span><br><span class="hljs-params">                        AspectJExpressionPointcut expressionPointcut,</span><br><span class="hljs-params">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> declarationOrder,</span><br><span class="hljs-params">                        String aspectName)</span> &#123;<br><br>    <span class="hljs-comment">// 获取切面 class 对象，并校验切面定义</span><br>    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    <span class="hljs-built_in">this</span>.validate(candidateAspectClass);<br><br>    <span class="hljs-comment">// 获取方法的切点注解定义</span><br>    AspectJAnnotation&lt;?&gt; aspectJAnnotation =<br>            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// If we get here, we know we have an AspectJ method.</span><br>    <span class="hljs-comment">// Check that it&#x27;s an AspectJ-annotated class</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isAspect(candidateAspectClass)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Advice must be declared inside an aspect type: &quot;</span> +<br>                <span class="hljs-string">&quot;Offending method &#x27;&quot;</span> + candidateAdviceMethod + <span class="hljs-string">&quot;&#x27; in class [&quot;</span> + candidateAspectClass.getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br><br>    AbstractAspectJAdvice springAdvice;<br><br>    <span class="hljs-comment">// 依据切点注解类型使用对应的增强类进行封装</span><br>    <span class="hljs-keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;<br>        <span class="hljs-comment">// @Pointcut</span><br>        <span class="hljs-keyword">case</span> AtPointcut:<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Processing pointcut &#x27;&quot;</span> + candidateAdviceMethod.getName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// @Around</span><br>        <span class="hljs-keyword">case</span> AtAround:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAroundAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @Before</span><br>        <span class="hljs-keyword">case</span> AtBefore:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJMethodBeforeAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @After</span><br>        <span class="hljs-keyword">case</span> AtAfter:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @AfterReturning</span><br>        <span class="hljs-keyword">case</span> AtAfterReturning:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterReturningAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-type">AfterReturning</span> <span class="hljs-variable">afterReturningAnnotation</span> <span class="hljs-operator">=</span> (AfterReturning) aspectJAnnotation.getAnnotation();<br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;<br>                springAdvice.setReturningName(afterReturningAnnotation.returning());<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @AfterThrowing</span><br>        <span class="hljs-keyword">case</span> AtAfterThrowing:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterThrowingAdvice</span>(<br>                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-type">AfterThrowing</span> <span class="hljs-variable">afterThrowingAnnotation</span> <span class="hljs-operator">=</span> (AfterThrowing) aspectJAnnotation.getAnnotation();<br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;<br>                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Unsupported advice type on method: &quot;</span> + candidateAdviceMethod);<br>    &#125;<br><br>    <span class="hljs-comment">// Now to configure the advice...</span><br>    springAdvice.setAspectName(aspectName);<br>    springAdvice.setDeclarationOrder(declarationOrder);<br>    String[] argNames = <span class="hljs-built_in">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (argNames != <span class="hljs-literal">null</span>) &#123;<br>        springAdvice.setArgumentNamesFromStringArray(argNames);<br>    &#125;<br>    springAdvice.calculateArgumentBindings();<br><br>    <span class="hljs-keyword">return</span> springAdvice;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法的整体执行流程如代码注释，逻辑比较清晰，Spring 会依据具体的增强注解类型，选择相应的增强类对切点定义进行封装。这里我们以 <code>@Before</code> 为例说明一下增强的执行流程，AspectJMethodBeforeAdvice 增强类关联注册的处理器是 MethodBeforeAdviceInterceptor，当我们调用一个被前置增强的目标方法时，<code>MethodBeforeAdviceInterceptor#invoke</code> 方法会被触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 执行增强方法</span><br>    <span class="hljs-built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());<br>    <span class="hljs-comment">// 执行目标方法</span><br>    <span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里执行的增强方法就对应着 <code>AspectJMethodBeforeAdvice#before</code> 方法，该方法会依据切点配置将相应的参数绑定传递给我们自定义的增强方法，并最终通过反射调用触发执行。</p><p>上面分析了普通方法级别增强的处理过程，对于另外一类增强（引介增强），方法 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 则使用专门的 DeclareParentsAdvisor 类创建对应的增强器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3. 获取所有引介增强定义</span><br><span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>    <span class="hljs-comment">// 创建引介增强器</span><br>    <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getDeclareParentsAdvisor(field);<br>    <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>        advisors.add(advisor);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Advisor <span class="hljs-title function_">getDeclareParentsAdvisor</span><span class="hljs-params">(Field introductionField)</span> &#123;<br>    <span class="hljs-comment">// 获取 @DeclareParents 注解定义</span><br>    <span class="hljs-type">DeclareParents</span> <span class="hljs-variable">declareParents</span> <span class="hljs-operator">=</span> introductionField.getAnnotation(DeclareParents.class);<br>    <span class="hljs-keyword">if</span> (declareParents == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有指定默认的接口实现类</span><br>    <span class="hljs-keyword">if</span> (DeclareParents.class == declareParents.defaultImpl()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;&#x27;defaultImpl&#x27; attribute must be set on DeclareParents&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 DeclareParentsAdvisor 类型创建对应的引介增强器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeclareParentsAdvisor</span>(<br>            introductionField.getType(), declareParents.value(), declareParents.defaultImpl());<br>&#125;<br></code></pre></td></tr></table></figure><p>对于引介增强来说，Spring 会注入 DelegatePerTargetObjectIntroductionInterceptor 处理器对其进行专门的处理，思想上与前面分析前置增强大同小异，这里不再展开。</p><p>继续回到 <code>AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</code> 方法，上面的过程我们分析了获取所有类型增强器的过程，但是这些增强器不一定都适用于当前 bean 实例，我们需要依据切点配置信息对其进行筛选。这一过程位于 <code>AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorsThatCanApply</span><span class="hljs-params">(</span><br><span class="hljs-params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    ProxyCreationContext.setCurrentProxiedBeanName(beanName);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ProxyCreationContext.setCurrentProxiedBeanName(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorsThatCanApply</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-comment">// 没有候选的增强器，直接返回</span><br>    <span class="hljs-keyword">if</span> (candidateAdvisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> candidateAdvisors;<br>    &#125;<br>    List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 1. 筛选引介增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 表示是否含有引介增强</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasIntroductions</span> <span class="hljs-operator">=</span> !eligibleAdvisors.isEmpty();<br><br>    <span class="hljs-comment">// 2. 筛选其它类型的增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-comment">// 引介增强已经处理过，这里直接跳过</span><br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>            <span class="hljs-comment">// already processed</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 筛选其它类型的增强器</span><br>        <span class="hljs-keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法首先会使用类过滤器（ClassFilter）筛选引介增强器，除了我们手动注册的类过滤器外，这里默认还会使用 TypePatternClassFilter 类过滤器执行过滤操作。然后，方法会过滤筛选其它类型的增强器，这里除了使用类过滤器外，考虑方法级别增强的定义形式，还会使用方法匹配器（MethodMatcher）进行筛选。如果增强器适用于当前 bean 类型，则将其加入到集合中用于下一步为当前 bean 创建增强代理对象。如果没有任何一个增强器适用于当前 bean 类型，则方法 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 最终会返回值为 null 的 <code>DO_NOT_PROXY</code> 数组对象，表示当前 bean 不需要被增强。</p><h5 id="为-bean-创建增强代理对象"><a href="#为-bean-创建增强代理对象" class="headerlink" title="为 bean 创建增强代理对象"></a>为 bean 创建增强代理对象</h5><p>完成了对于当前 bean 增强器的筛选，接下来我们继续回到 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法，看一下基于前面筛选出的增强器为当前 bean 创建增强代理对象的过程，实现位于 <code>AbstractAutoProxyCreator#createProxy</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass,</span><br><span class="hljs-params">                             <span class="hljs-meta">@Nullable</span> String beanName,</span><br><span class="hljs-params">                             <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors,</span><br><span class="hljs-params">                             TargetSource targetSource)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-built_in">this</span>.beanFactory, beanName, beanClass);<br>    &#125;<br><br>    <span class="hljs-comment">// ProxyFactory 用于为目标 bean 实例创建代理对象</span><br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>    proxyFactory.copyFrom(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// proxy-target-class = false，表示使用 JDK 原生动态代理</span><br>    <span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>        <span class="hljs-comment">// 检测当前 bean 是否应该基于类而非接口生成代理对象，即包含 preserveTargetClass=true 属性</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.shouldProxyTargetClass(beanClass, beanName)) &#123;<br>            proxyFactory.setProxyTargetClass(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果是基于接口生成代理，则添加需要代理的接口到 ProxyFactory 中（除内置 callback 接口、语言内在接口，以及标记接口）</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.evaluateProxyInterfaces(beanClass, proxyFactory);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将拦截器封装成 Advisor 对象</span><br>    Advisor[] advisors = <span class="hljs-built_in">this</span>.buildAdvisors(beanName, specificInterceptors);<br>    proxyFactory.addAdvisors(advisors);<br>    proxyFactory.setTargetSource(targetSource);<br>    <span class="hljs-comment">// 模板方法，定制代理工厂</span><br>    <span class="hljs-built_in">this</span>.customizeProxyFactory(proxyFactory);<br><br>    <span class="hljs-comment">// 设置代理工厂被配置之后是否还允许修改，默认为 false，表示不允许修改</span><br>    proxyFactory.setFrozen(<span class="hljs-built_in">this</span>.freezeProxy);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisorsPreFiltered()) &#123;<br>        proxyFactory.setPreFiltered(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 基于 ProxyFactory 创建代理类</span><br>    <span class="hljs-keyword">return</span> proxyFactory.getProxy(<span class="hljs-built_in">this</span>.getProxyClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>方法的执行流程如代码注释。下面我们主要分析将拦截器封装成 Advisor 对象的过程，以及基于 ProxyFactory 创建增强代理对象的过程。</p><p>Spring 定义了非常多的拦截器、增强器，以及增强方法等，这里通过 <code>AbstractAutoProxyCreator#buildAdvisors</code> 方法统一将他们封装成 Advisor 对象，从而简化代理的创建过程。封装的核心步骤由 <code>DefaultAdvisorAdapterRegistry#wrap</code> 方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException &#123;<br>    <span class="hljs-comment">// 已经是 Advisor，则无需多做处理</span><br>    <span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) &#123;<br>        <span class="hljs-keyword">return</span> (Advisor) adviceObject;<br>    &#125;<br>    <span class="hljs-comment">// 要求必须是 Advice 类型</span><br>    <span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAdviceTypeException</span>(adviceObject);<br>    &#125;<br>    <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> (Advice) adviceObject;<br>    <span class="hljs-comment">// 如果是 MethodInterceptor，则直接使用 DefaultPointcutAdvisor 进行包装</span><br>    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br>        <span class="hljs-comment">// So well-known it doesn&#x27;t even need an adapter.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(advice);<br>    &#125;<br>    <span class="hljs-comment">// 否则遍历注册的适配器，如果存在关联的适配器则使用 DefaultPointcutAdvisor 进行包装</span><br>    <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-built_in">this</span>.adapters) &#123;<br>        <span class="hljs-comment">// Check that it is supported.</span><br>        <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(advice);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAdviceTypeException</span>(advice);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们重点分析一下通过代理工厂 ProxyFactory 创建增强代理对象的过程，实现位于 <code>ProxyFactory#getProxy</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.createAopProxy() <span class="hljs-comment">// 1. 创建 AOP 代理</span><br>            .getProxy(classLoader); <span class="hljs-comment">// 2. 基于 AOP 代理创建目标类的增强代理对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的执行过程可以拆分成两个步骤：</p><ol><li>创建 AOP 代理，Spring 默认提供了两种 AOP 代理实现，即 java 原生代理和 CGLib 代理；</li><li>基于 AOP 代理创建目标类的增强代理对象。</li></ol><p>我们首先来看一下步骤 1 的实现，位于 <code>ProxyCreatorSupport#createAopProxy</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.active) &#123;<br>        <span class="hljs-built_in">this</span>.activate();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAopProxyFactory().createAopProxy(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</span><br><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    <span class="hljs-keyword">if</span> (config.isOptimize() <span class="hljs-comment">// 需要对代理策略进行优化</span><br>            || config.isProxyTargetClass() <span class="hljs-comment">// // 指定使用 CGLib 生成代理对象</span><br>            || <span class="hljs-built_in">this</span>.hasNoUserSuppliedProxyInterfaces(config)) <span class="hljs-comment">// 当前类没有接口定义，不得不使用 CGLib</span><br>    &#123;<br>        Class&lt;?&gt; targetClass = config.getTargetClass();<br>        <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                    <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 目标类是接口或代理类，使用 JDK 原生代理</span><br>        <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>        &#125;<br>        <span class="hljs-comment">// 使用 CGLib 动态代理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjenesisCglibAopProxy</span>(config);<br>    &#125;<br>    <span class="hljs-comment">// 使用 JDK 原生动态代理</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码清晰说明了 Spring 在生成代理对象时如何在 java 原生代理和 CGLib 代理之间进行选择，可以概括如下：</p><ol><li>如果目标类实现了接口，则 Spring 默认会使用 java 原生代理。</li><li>如果目标类未实现接口，则 Spring 会使用 CGLib 生成代理。</li><li>如果目标类实现了接口，但是在配置时指定了 <code>proxy-target-class=true</code>，则使用 CGLib 生成代理。</li></ol><p>下面分别对基于 java 原生代理和 CGLib 代理生成增强代理对象的过程进行分析。</p><h5 id="基于-Java-原生代理创建增强代理对象"><a href="#基于-Java-原生代理创建增强代理对象" class="headerlink" title="基于 Java 原生代理创建增强代理对象"></a>基于 Java 原生代理创建增强代理对象</h5><p>首先来看一下基于 Java 原生代理生成增强代理对象的过程，位于 <code>JdkDynamicAopProxy</code> 类中。Java 原生代理要求代理类实现 <code>InvocationHandler</code> 接口，并在 <code>InvocationHandler#invoke</code> 方法中实现代理增强逻辑。<code>JdkDynamicAopProxy</code> 正好实现了该接口，对应的 <code>JdkDynamicAopProxy#invoke</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.targetSource;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当前是 equals 方法，但是被代理类接口中未定义 equals 方法</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.equals(args[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 当前是 hashCode 方法，但是被代理类接口中未定义 hashCode 方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hashCode();<br>        &#125;<br>        <span class="hljs-comment">// 如果是 DecoratingProxy 中定义的方法（即 DecoratingProxy#getDecoratedClass），直接返回目标类对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;<br>            <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-built_in">this</span>.advised);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.advised.opaque <span class="hljs-comment">// 允许被转换成 Advised 类型</span><br>                &amp;&amp; method.getDeclaringClass().isInterface() <span class="hljs-comment">// 接口类型</span><br>                &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) <span class="hljs-comment">// 方法所在类是 Advised 类及其父类</span><br>        &#123;<br>            <span class="hljs-comment">// 直接反射调用该方法</span><br>            <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-built_in">this</span>.advised, method, args);<br>        &#125;<br><br>        <span class="hljs-comment">// 结果值</span><br>        Object retVal;<br><br>        <span class="hljs-comment">// 指定内部间调用也需要代理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>            <span class="hljs-comment">// Make invocation available if necessary.</span><br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool.</span><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 获取当前方法的拦截器链</span><br>        List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br><br>        <span class="hljs-comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br>        <span class="hljs-comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br>        <span class="hljs-comment">// 拦截器链为空，则直接反射调用增强方法</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly</span><br>            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br>            <span class="hljs-comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>        &#125;<br>        <span class="hljs-comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">MethodInvocation</span> <span class="hljs-variable">invocation</span> <span class="hljs-operator">=</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);<br>            <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span><br>            retVal = invocation.proceed();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理返回值</span><br>        Class&lt;?&gt; returnType = method.getReturnType();<br>        <span class="hljs-keyword">if</span> (retVal != <span class="hljs-literal">null</span> &amp;&amp; retVal == target &amp;&amp;<br>                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;<br>                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// Special case: it returned &quot;this&quot; and the return type of the method is type-compatible.</span><br>            <span class="hljs-comment">// Note that we can&#x27;t help if the target sets a reference to itself in another returned object.</span><br>            retVal = proxy;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<br>                    <span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>        &#125;<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>            <span class="hljs-comment">// Must have come from TargetSource.</span><br>            targetSource.releaseTarget(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>            <span class="hljs-comment">// Restore old proxy.</span><br>            AopContext.setCurrentProxy(oldProxy);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上述方法实现，我们可以概括出整个增强代理的执行过程，如下：</p><ol><li>特殊处理 <code>Object#equals</code>、<code>Object#hashCode</code>、<code>DecoratingProxy#getDecoratedClass</code>，以及 Advised 类及其父类中定义的方法；</li><li>如果配置了 expose-proxy 属性，则记录当前代理对象，以备在内部间调用时实施增强；</li><li>获取当前方法的拦截器链；</li><li>如果没有拦截器定义，则直接反射调用增强方法，否则先逐一执行拦截器方法，最后再应用增强方法；</li><li>处理返回值。</li></ol><p>重点来看一下步骤 4 中应用拦截器方法的实现，位于 <code>ReflectiveMethodInvocation#proceed</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 如果所有的增强都执行完成，则执行增强方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentInterceptorIndex == <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.invokeJoinpoint();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取下一个需要执行的拦截器</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">interceptorOrInterceptionAdvice</span> <span class="hljs-operator">=</span><br>            <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-built_in">this</span>.currentInterceptorIndex);<br>    <span class="hljs-comment">// 动态拦截器，执行动态方法匹配</span><br>    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;<br>        <span class="hljs-comment">// Evaluate dynamic method matcher here: static part will already have been evaluated and found to match.</span><br>        <span class="hljs-type">InterceptorAndDynamicMethodMatcher</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span><br>                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;<br>        Class&lt;?&gt; targetClass = (<span class="hljs-built_in">this</span>.targetClass != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.targetClass : <span class="hljs-built_in">this</span>.method.getDeclaringClass());<br>        <span class="hljs-comment">// 动态匹配成功，执行对应的拦截方法</span><br>        <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-built_in">this</span>.method, targetClass, <span class="hljs-built_in">this</span>.arguments)) &#123;<br>            <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-comment">// 动态匹配失败，忽略当前拦截器方法，继续执行下一个拦截器</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.proceed();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 静态拦截器，直接应用拦截方法</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器方法的执行流程如上述代码注释，是一个递归调用的过程，并在最后应用增强方法。</p><p>完成了对于 AOP 代理对象 <code>JdkDynamicAopProxy</code> 的创建，最后来看一下获取该对象的过程，实现位于 <code>JdkDynamicAopProxy#getProxy</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-comment">// 获取需要被代理的接口集合</span><br>    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-built_in">this</span>.advised, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 检测是否在被代理接口中声明了 equals 和 hashCode 方法</span><br>    <span class="hljs-built_in">this</span>.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>    <span class="hljs-comment">// 基于 Java 原生代理生成代理对象</span><br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑也就是 Java 原生代理的模板代码，如果对 Java 代理比较熟悉的话，应该不难理解</p><h5 id="基于-CGLib-代理创建增强代理对象"><a href="#基于-CGLib-代理创建增强代理对象" class="headerlink" title="基于 CGLib 代理创建增强代理对象"></a>基于 CGLib 代理创建增强代理对象</h5><p>基于 CGLib 代理生成增强代理对象的过程位于 <code>ObjenesisCglibAopProxy</code> 类中，该类继承自 <code>CglibAopProxy</code> 类。获取 CGLib 代理类对象的方法定义在 <code>CglibAopProxy</code> 中，即 <code>CglibAopProxy#getProxy</code> 方法。该方法基于 CGLib 的 <code>Enhancer</code> 类创建代理对象，属于 CGLib 的标准使用模式，因为有多个 <code>callback</code> 实现，所以这里使用了 <code>CallbackFilter</code> 模式，依据场景选择并应用对应的 <code>callback</code> 拦截器。</p><p>我们重点关注 <code>callback</code> 的实现，位于 <code>CglibAopProxy#getCallbacks</code> 方法中。受制于 CGLib 在执行时一次只允许应用一个 <code>callback</code> 的约束，所以该方法依据参数配置实现了一组 <code>callback</code>，以覆盖不同的场景。核心的 AOP callback 实现是 <code>DynamicAdvisedInterceptor</code> 类，它实现了 <code>MethodInterceptor</code> 接口，对应的 <code>DynamicAdvisedInterceptor#intercept</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.getTargetSource();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 指定内部间调用也需要代理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>            <span class="hljs-comment">// Make invocation available if necessary.</span><br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 获取当前方法的拦截器链</span><br>        List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>        <span class="hljs-comment">// 结果值</span><br>        Object retVal;<br>        <span class="hljs-comment">// Check whether we only have one InvokerInterceptor:</span><br>        <span class="hljs-comment">// that is, no real advice, but just reflective invocation of the target.</span><br>        <span class="hljs-comment">// 拦截器链为空，则直接反射调用增强方法</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;<br>            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span><br>            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span><br>            <span class="hljs-comment">// it does nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = methodProxy.invoke(target, argsToUse);<br>        &#125;<br>        <span class="hljs-comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            retVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();<br>        &#125;<br>        <span class="hljs-comment">// 处理返回值</span><br>        retVal = processReturnType(proxy, target, method, retVal);<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>            targetSource.releaseTarget(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>            <span class="hljs-comment">// Restore old proxy.</span><br>            AopContext.setCurrentProxy(oldProxy);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出上述方法在实现流程上与前面介绍的 <code>JdkDynamicAopProxy#invoke</code> 方法是一致的，只是这里是基于 CGLib 实现</p><blockquote><p>参考 <a href="https://my.oschina.net/wangzhenchao/blog/4279608">https://my.oschina.net/wangzhenchao/blog/4279608</a></p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><code>@EnableAspectJAutoProxy</code> 开启AOP功能 </li><li><code>@EnableAspectJAutoProxy</code> 会给容器中注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code> </li><li><code>AnnotationAwareAspectJAutoProxyCreator</code> 是一个 <code>InstantiationAwareBeanPostProcessor</code> 类型后置处理器，功能可以概括为：<ol><li>从容器中获取所有的切面定义</li><li>筛选适用于当前 bean 的增强器集合</li><li>依据增强器集合基于动态代理机制生成相应的增强代理对象</li></ol></li></ol><p>Spring AOP 的实现本质上是一个动态代理的过程，Spring 引入了 Java 原生代理和 CGLib 代理，并依据场景选择基于哪种代理机制对目标对象进行增强。Spring 容器在完成对 bean 对象的创建之后会执行初始化操作，而 AOP 初始化的过程就发生在 bean 的后置初始化阶段</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>AOP</tag>
      
      <tag>Reflect</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean 的生命周期</title>
    <link href="/posts/34792.html"/>
    <url>/posts/34792.html</url>
    
    <content type="html"><![CDATA[<p>Java Bean 是 Java 编程语言中的一种编程规范，用于创建可重用组件。它是一种普通的 Java 类，遵循特定的命名规则和设计模式，目的是封装数据和行为，使得这些组件能够在不同的应用程序中被方便地复用。而 Spring 中的 Bean 指的是将对象的生命周期，交个 Spring IoC 容器来管理的对象</p><span id="more"></span><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><blockquote><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p></blockquote><p>简而言之，Spring Bean 是由 Spring IoC 容器实例化、组装和管理的对象</p><p>Spring Bean 的特点和优势：</p><ol><li><p><strong>依赖注入</strong> (<em>Dependency Injection</em>)：Spring Bean 的一个重要特点是依赖注入，即通过容器将对象之间的依赖关系动态注入到 Bean 中。这样，对象之间的耦合性降低，使得应用程序更加灵活和易于维护</p></li><li><p><strong>面向切面编程</strong> (<em>Aspect-Oriented Programming，AOP</em>)：Spring Bean 支持面向切面编程，允许开发者将应用程序的业务逻辑和横切关注点（例如日志记录、事务管理等）进行解耦。通过 AOP，可以将横切关注点作为切面，与业务逻辑分离开来，提高了代码的模块性和复用性</p></li><li><p><strong>单例和原型模式</strong>：Spring Bean 可以配置为单例（<em>Singleton</em>）模式或原型（<em>Prototype</em>）模式。在单例模式下，Spring 容器只会创建一个 Bean 实例并共享给所有请求，而在原型模式下，每次请求都会创建一个新的 Bean 实例</p></li><li><p><strong>生命周期管理</strong>：Spring Bean 的生命周期由 Spring 容器管理，容器负责在 Bean 的创建、初始化、使用和销毁时进行相应的操作。开发者可以通过实现特定的接口或使用注解来管理 Bean 的生命周期</p></li><li><p><strong>灵活配置</strong>：Spring Bean 可以通过 XML 配置文件、Java 注解或者 Java 配置类进行定义和配置，使得开发者可以根据不同的需求选择适合的配置方式</p></li></ol><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p>这里说的 Spring Bean 的生命周期主要指的是 <em>singleton</em> bean，对于 <em>prototype</em> 的 bean ，Spring 在创建好交给使用者之后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 <em>prototype</em> 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 <em>prototype</em> 作用域的 Bean 的生命周期。</p><p>了解 Spring 生命周期的意义就在于，<strong>可以利用 Bean 在其存活期间的指定时刻完成一些相关操作</strong>。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作</p><p>对于普通的 Java 对象来说，它们的生命周期就是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><p>而对于 Spring Bean 的生命周期来说：Bean 在 Spring（<em>IoC</em>）中从创建到销毁的整个过程。Spring 中 Bean 的生命周期主要包含以下 5 部分：</p><ol><li>实例化 <em>Instantiation</em>：实例化一个 bean 对象</li><li>属性赋值 <em>Populate</em>：为 bean 设置相关属性和依赖</li><li>初始化 <em>Initialization</em><ol><li>执行各种通知 <em>Aware</em></li><li>执行初始化的前置方法 <em>BeanPostProcessor before</em></li><li>执行初始化方法 <em>Init-method</em></li><li>执行初始化的后置方法 <em>BeanPostProcessor after</em></li></ol></li><li>销毁 <em>Destruction</em></li></ol><p><img src="/posts/34792/1704860a4de235aa~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0-20230724173829502.awebp" alt="bean的生命周期"></p><p>在 bean 准备就绪之前，bean 工厂执行了以下启动步骤：</p><ol><li>Spring 对 bean 进行实例化；</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中；</li><li>如果 bean 实现了 <code>BeanNameAware </code>接口，Spring 将 bean 的ID传递给 <code>setBeanName()</code> 方法；</li><li>如果 bean实现了 <code>BeanFactoryAware </code>接口，Spring 将调用 <code>setBeanFactory()</code> 方法，将BeanFactory容器实列传入；</li><li>如果 bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 <code>setApplicationContext()</code> 方法，将bean所在的应用上下文的引用传入进来；</li><li>如果 bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessBeforeInitialization()</code> 方法；</li><li>如果 bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用它们的 <code>afterPropertiesSet()</code> 方法。类似地，如果 bean 使用 <code>init-method </code>声明了初始化方法，该方法也会被调用；</li><li>如果 bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessAfterInitialization()</code> 方法；</li><li>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了 <code>DisposableBean</code> 接口，Spring将调用它的 <code>destroy()</code> 接口方法。同样，如果 bean 使用 <code>destroy-method</code> 声明了销毁方法，该方法也会被调用。</li></ol><p>以上生命周期中，需要注意的是：“<strong>实例化</strong>”和“<strong>初始化</strong>”是两个完全不同的过程，实例化只是给 Bean 分配了内存空间，而初始化则是将程序的执行权，从系统级别转换到用户级别，并开始执行用户添加的业务代码</p><h3 id="Bean-生命周期中的扩展点"><a href="#Bean-生命周期中的扩展点" class="headerlink" title="Bean 生命周期中的扩展点"></a>Bean 生命周期中的扩展点</h3><h4 id="Bean-自身的方法"><a href="#Bean-自身的方法" class="headerlink" title="Bean 自身的方法"></a><strong>Bean 自身的方法</strong></h4><p>比如构造函数、<code>getter</code> &#x2F; <code>setter</code> 以及 <code>init-method</code> 和 <code>destory-method</code> 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段</p><h4 id="容器级的方法（BeanPostProcessor-一系列接口）"><a href="#容器级的方法（BeanPostProcessor-一系列接口）" class="headerlink" title="容器级的方法（BeanPostProcessor 一系列接口）"></a><strong>容器级的方法（<code>BeanPostProcessor</code> 一系列接口）</strong></h4><p>主要是后处理器方法，比如下图的 <code>InstantiationAwareBeanPostProcessor</code>、<code>BeanPostProcessor</code> 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用</p><p><img src="/posts/34792/1460000040365134.png" alt="bean 容器中接口"></p><h5 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a><strong>InstantiationAwareBeanPostProcessor</strong></h5><p><code>InstantiationAwareBeanPostProcessor</code> 继承了 <code>BeanPostProcessor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>  <br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>  <br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title function_">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span><br><span class="hljs-keyword">throws</span> BeansException &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 调用点</li></ul><blockquote><p><code>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code><br>返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<br><code>InstantiationAwareBeanPostProcessor</code>接口中的<code>postProcessBeforeInstantiation</code>，在实例化之前调用<br><code>BeanPostProcessor</code>接口中的<code>postProcessAfterInitialization</code>，在实例化之后调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> &#123;<br><br>...<span class="hljs-comment">// 省略</span><br><span class="hljs-comment">// do before doCreateBean()</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br><br>    ... <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br><span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);<br><span class="hljs-keyword">if</span> (targetType != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 内部遍历调用postProcessBeforeInstantiation【实例化之前】</span><br>bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果返回了快捷 Bean，则内部遍历调用postProcessAfterInitialization【初始化之后】</span><br>bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>&#125;<br>&#125;<br>&#125;<br>mbd.beforeInstantiationResolved = (bean != <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>总之，<code>postProcessBeforeInstantiation</code> 在 <code>doCreateBean</code> 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 AOP 等功能实现的关键点</p><ul><li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 调用点</li></ul><blockquote><p><code>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException</code><br>正常情况下在实例化之后在执行<code>populateBean</code>之前调用<br>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的<code>postProcessPropertyValues</code>将不会执行,但是初始化和<code>BeanPostProcessor</code>的仍然会执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> &#123;<br><span class="hljs-keyword">if</span> (bw == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Skip property population phase for null instance.</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 判断容器中是否存在InstantiationAwareBeanPostProcessors</span><br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>      <span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br><span class="hljs-keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br><span class="hljs-keyword">if</span> (pvs == <span class="hljs-literal">null</span>) &#123;<br>pvs = mbd.getPropertyValues();<br>&#125;<br>      <span class="hljs-comment">// 遍历 InstantiationAwareBeanPostProcessors</span><br><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>        <span class="hljs-comment">// 执行postProcessPropertyValue方法</span><br><span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvsToUse</span> <span class="hljs-operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>&#125;<br>          <span class="hljs-comment">// 见下</span><br>pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>pvs = pvsToUse;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (needsDepCheck) &#123;<br><span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>&#125;<br>checkDependencies(beanName, mbd, filteredPds, pvs);<br>&#125;<br><br><span class="hljs-keyword">if</span> (pvs != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 设置属性</span><br>applyPropertyValues(beanName, mbd, bw, pvs);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code></p><blockquote><p>实例化之后调用，在方法 <code>applyPropertyValues</code>【属性填充】之前</p><p><strong>pvsToUse</strong> 返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中<br><strong>pvs</strong>：<code>PropertyValues</code> 对象，用于封装指定类的对象，简单来说就是 <code>PropertyValue</code> 的集合，里面相当于以key-value形式存放类的属性和值。<br><strong>pds</strong>：<code>PropertyDescriptor </code>对象数组，<code>PropertyDescriptor </code>相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">PropertyDescriptor[] filteredPds = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br><span class="hljs-keyword">if</span> (pvs == <span class="hljs-literal">null</span>) &#123;<br>pvs = mbd.getPropertyValues();<br>&#125;<br>      <span class="hljs-comment">// 遍历执行postProcessPropertyValue方法</span><br><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br><span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvsToUse</span> <span class="hljs-operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>&#125;<br>pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>pvs = pvsToUse;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="BeanPostProcessor-源码分析"><a href="#BeanPostProcessor-源码分析" class="headerlink" title="BeanPostProcessor 源码分析"></a><strong>BeanPostProcessor 源码分析</strong></h5><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> &#123;<br><br><span class="hljs-comment">// Instantiate the bean.</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br>... <span class="hljs-comment">// 省略</span><br><br><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>populateBean(beanName, mbd, instanceWrapper);<br>      <span class="hljs-comment">// 入口，初始化bean</span><br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br>  <br>  ...<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进入初始化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>...<span class="hljs-comment">// 省略</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>      <span class="hljs-comment">// 初始化前执行</span><br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>&#125;<br><br>    ...<span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>      <span class="hljs-comment">// 初始化后执行</span><br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>&#125;<br><br><span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看</p><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br><span class="hljs-keyword">throws</span> BeansException &#123;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 获取到所有的后置处理器 getBeanPostProcessors()</span><br><span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>      <span class="hljs-comment">// 循环依次调用后置处理器方法</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br><span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>result = current;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先获取到所有的后置处理器 <code>getBeanPostProcessors()</code></li><li>在 for 循环中依次调用后置处理器的方法 <code>processor.postProcessBeforeInitialization(result, beanName);</code></li><li>进入 <code>postProcessBeforeInitialization</code> 方法</li></ul><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">// 判断是否实现了Aware接口</span><br><span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||<br>bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||<br>bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware ||<br>bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware)) &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-type">AccessControlContext</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>acc = <span class="hljs-built_in">this</span>.applicationContext.getBeanFactory().getAccessControlContext();<br>&#125;<br><br><span class="hljs-keyword">if</span> (acc != <span class="hljs-literal">null</span>) &#123;<br>AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>invokeAwareInterfaces(bean);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;, acc);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeAwareInterfaces(bean);<br>&#125;<br><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>invokeAwareInterfaces(bean)</code> 方法，当前 bean 实现了 <code>ApplicationContextAware</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> &#123;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) &#123;<br>((EnvironmentAware) bean).setEnvironment(<span class="hljs-built_in">this</span>.applicationContext.getEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) &#123;<br>((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="hljs-built_in">this</span>.embeddedValueResolver);<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware) &#123;<br>((ResourceLoaderAware) bean).setResourceLoader(<span class="hljs-built_in">this</span>.applicationContext);<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware) &#123;<br>((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="hljs-built_in">this</span>.applicationContext);<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware) &#123;<br>((MessageSourceAware) bean).setMessageSource(<span class="hljs-built_in">this</span>.applicationContext);<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware) &#123;<br>((ApplicationStartupAware) bean).setApplicationStartup(<span class="hljs-built_in">this</span>.applicationContext.getApplicationStartup());<br>&#125;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) &#123;<br>((ApplicationContextAware) bean).setApplicationContext(<span class="hljs-built_in">this</span>.applicationContext);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code> 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 <code>invokeAwareInterfaces(bean)</code>，向容器中添加相关接口的上下文环境。</li></ul><h4 id="Bean-级生命周期方法"><a href="#Bean-级生命周期方法" class="headerlink" title="Bean 级生命周期方法"></a><strong>Bean 级生命周期方法</strong></h4><p>这个包括了<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>InitializingBean</code>和<code>DiposableBean</code>这些接口的方法</p><h5 id="Aware-类型的接口"><a href="#Aware-类型的接口" class="headerlink" title="Aware 类型的接口"></a><strong>Aware 类型的接口</strong></h5><p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 <code>BeanNameAware</code> 可以拿到 BeanName，以此类推。调用时机需要注意：所有的 Aware 方法都是<code>在初始化阶段之前调用的</code>。</p><p>Aware 接口众多，这里同样通过分类的方式帮助大家记忆。Aware 接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。</p><p><strong>Aware Group1</strong></p><ul><li><code>BeanNameAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>BeanFactoryAware</code></li></ul><p><strong>Aware Group2</strong></p><ul><li><p><code>EnvironmentAware</code></p></li><li><p><code>EmbeddedValueResolverAware</code><br>实现该接口能够获取 <strong>Spring EL</strong> 解析器，用户的自定义注解需要支持 <em>SPEL</em> 表达式的时候可以使用</p></li><li><p><code>ApplicationContextAware(ResourceLoaderAware/ApplicationEventPublisherAware/MessageSourceAware)</code><br>实际上这几个接口可以一起记，其返回值实质上都是当前的 <code>ApplicationContext</code> 对象，因为 <code>ApplicationContext</code> 是一个复合接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory,<br>MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br><br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br><br>String <span class="hljs-title function_">getApplicationName</span><span class="hljs-params">()</span>;<br><br>String <span class="hljs-title function_">getDisplayName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">getStartupDate</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@Nullable</span><br>ApplicationContext <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>;<br><br>AutowireCapableBeanFactory <span class="hljs-title function_">getAutowireCapableBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="Aware-调用时机源码分析"><a href="#Aware-调用时机源码分析" class="headerlink" title="Aware 调用时机源码分析"></a><strong>Aware 调用时机源码分析</strong></h5><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>invokeAwareMethods(beanName, bean);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;, getAccessControlContext());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 调用group1中的三个Aware</span><br>invokeAwareMethods(beanName, bean);<br>&#125;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>      <span class="hljs-comment">// 调用group2中的Aware</span><br>      <span class="hljs-comment">// 这里是通过 BeanPostProcessor 实现</span><br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// initializingBean调用点</span><br>invokeInitMethods(beanName, wrappedBean, mbd);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>(mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>),<br>beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>&#125;<br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>      <span class="hljs-comment">// BeanPostProcessor的另一个调用点</span><br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>&#125;<br><br><span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>并不是</strong>所有的 Aware 接口都使用同样的方式调用。<code>Bean××Aware</code> 都是在代码中直接调用的，而 <code>ApplicationContext</code> 相关的 Aware 都是通过 <code>BeanPostProcessor#postProcessBeforeInitialization()</code> 实现的。感兴趣的可以自己看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的 Bean 是否实现了相关的 Aware 方法，如果实现了会调用回调方法将资源传递给 Bean</p><p><code>BeanPostProcessor</code> 的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行</p><p>关于 Aware 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了</p><h5 id="生命周期接口"><a href="#生命周期接口" class="headerlink" title="生命周期接口"></a>生命周期接口</h5><p>剩下的两个生命周期接口，实例化和属性赋值都是 Spring 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段</p><p><code>InitializingBean</code> 接口 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>  <span class="hljs-comment">// 在 afterPropertiesSet() 方法写初始化逻辑</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd)</code>方法中调用。</li></ul><p>有一点需要注意，因为 Aware 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 Aware 接口获取的资源，这也是我们自定义扩展 Spring 的常用方式。<br>除了实现 <code>InitializingBean</code> 接口之外还能通过注解或者 xml 配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式</p><ul><li><code>DisposableBean</code> 类似于 <code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了 DisposableBean 接口的 Bean 然后调用其 destroy() 方法，感兴趣的可以自行跟一下源码。</li></ul><h5 id="Spring-Bean-生命周期流程图"><a href="#Spring-Bean-生命周期流程图" class="headerlink" title="Spring Bean 生命周期流程图"></a>Spring Bean 生命周期流程图</h5><p><img src="/posts/34792/1460000040365152.png" alt="在这里插入图片描述"></p><h4 id="工厂后处理器接口方法"><a href="#工厂后处理器接口方法" class="headerlink" title="工厂后处理器接口方法"></a>工厂后处理器接口方法</h4><p>这个包括了<code>AspectJWeavingEnabler</code> , <code>ConfigurationClassPostProcessor</code>, <code>CustomAutowireConfigurer</code>等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用</p><p>对于工厂后处理器方法看<code>refresh()</code> 里的 <code>invokeBeanFactoryPostProcessors(beanFactory)</code> 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-comment">// 获取context中已经添加的beanFactoryPostProcessors</span><br>    <span class="hljs-comment">// 实例化并调用所有的BeanFactoryPostProcessors</span><br>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());<br><br><span class="hljs-keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="hljs-literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));<br>beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟到最重要的方法 <code>invokeBeanFactoryPostProcessors</code></p><p><code>BeanFactoryPostProcessor</code>：一切处理 <strong>BeanFactory</strong> 的父接口<br><code>BeanDefinitionRegistryPostProcessor</code>：实现了 <strong>BeanFactoryPostProcessor</strong> 接口的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;<br><br><span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br>Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// beaFactory 是 BeanDefinitionRegistry 的接口或者子类</span><br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;<br><span class="hljs-type">BeanDefinitionRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> (BeanDefinitionRegistry) beanFactory;<br>      <span class="hljs-comment">// 初始化容器</span><br>List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br><span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;<br><span class="hljs-type">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-variable">registryProcessor</span> <span class="hljs-operator">=</span><br>(BeanDefinitionRegistryPostProcessor) postProcessor;<br>registryProcessor.postProcessBeanDefinitionRegistry(registry);<br>registryProcessors.add(registryProcessor);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>regularPostProcessors.add(postProcessor);<br>&#125;<br>&#125;<br><br>List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br>registryProcessors.addAll(currentRegistryProcessors);<br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>processedBeans.add(ppName);<br>&#125;<br>&#125;<br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br>registryProcessors.addAll(currentRegistryProcessors);<br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br>currentRegistryProcessors.clear();<br><br><span class="hljs-comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">reiterate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (reiterate) &#123;<br>reiterate = <span class="hljs-literal">false</span>;<br>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>processedBeans.add(ppName);<br>reiterate = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>sortPostProcessors(currentRegistryProcessors, beanFactory);<br>registryProcessors.addAll(currentRegistryProcessors);<br>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br>currentRegistryProcessors.clear();<br>&#125;<br><br><span class="hljs-comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br>invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br>invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>&#125;<br><br><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br>String[] postProcessorNames =<br>beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="hljs-comment">// Ordered, and the rest.</span><br>List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br><span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br><span class="hljs-comment">// skip - already processed in first phase above</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>orderedPostProcessorNames.add(ppName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>nonOrderedPostProcessorNames.add(ppName);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br>List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br>orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br>sortPostProcessors(orderedPostProcessors, beanFactory);<br>invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Finally, invoke all other BeanFactoryPostProcessors.</span><br>List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br>nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>&#125;<br>invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<br><br><span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br><span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br>beanFactory.clearMetadataCache();<br>&#125;<br></code></pre></td></tr></table></figure><p>流程说明：</p><ul><li>调用 <code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(registry)</code> 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理</li><li>调用 <code>BeanFactoryPostProcessor#postProcessBeanFactory(beanFactory)</code> 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory(beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理</li></ul><h3 id="常用接口说明"><a href="#常用接口说明" class="headerlink" title="常用接口说明"></a>常用接口说明</h3><p><strong>BeanNameAware</strong></p><p>该接口只有一个方法 <code>setBeanName(String name)</code>，用来获取 bean 的 <strong>id</strong> 或者 <strong>name</strong></p><p><strong>BeanFactoryAware</strong></p><p>该接口只有一个方法 <code>setBeanFactory(BeanFactory beanFactory)</code>，用来<strong>获取当前环境中</strong>的 <code>BeanFactory</code></p><p><strong>ApplicationContextAware</strong></p><p>该接口只有一个方法 <code>setApplicationContext(ApplicationContext applicationContext)</code>，用来<strong>获取当前环境中的</strong> <code>ApplicationContext</code></p><p><strong>InitializingBean</strong></p><p>该接口只有一个方法 <code>afterPropertiesSet()</code>，在<strong>属性注入完成</strong>后调用</p><p><strong>DisposableBean</strong></p><p>该接口只有一个方法 <code>destroy()</code>，在容器销毁的时候调用，在<strong>用户指定</strong>的 <code>destroy-method</code> 之前调用</p><p><strong>BeanPostProcessor</strong></p><p>该接口有两个方法：</p><ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>：在<strong>初始化之前</strong>调用此方法</li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code>：在<strong>初始化之后</strong>调用此方法</li></ul><p>通过方法签名我们可以知道，我们可以通过 beanName 来筛选出我们需要进行个性化定制的 bean</p><p><strong>InstantiationAwareBeanPostProcessor</strong></p><p>该类是 BeanPostProcessor 的子接口，常用的有如下三个方法：</p><ul><li><code>postProcessBeforeInstantiation(Class beanClass, String beanName)</code>：在 bean <strong>实例化之前</strong>调用</li><li><code>postProcessProperties(PropertyValues pvs, Object bean, String beanName)</code>：在 bean <strong>实例化之后</strong>、<strong>设置属性前</strong>调用</li><li><code>postProcessAfterInstantiation(Class beanClass, String beanName)</code>：在 bean <strong>实例化之后</strong>调用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>bean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring IoC</title>
    <link href="/posts/9827.html"/>
    <url>/posts/9827.html</url>
    
    <content type="html"><![CDATA[<p><strong>Spring IoC</strong>（Inversion of Control，控制反转）是Spring框架的核心概念之一，它是一种设计模式，用于解耦组件之间的依赖关系，提供更灵活、可维护和可测试的代码。IoC的主要思想是，将对象的创建和依赖关系的管理交给容器来处理，而不是由对象自身来创建和管理依赖</p><span id="more"></span><p><strong>IoC（Inversion of Control）控制反转</strong>：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体的表现就是我们看到的配置文件，或者是注解</p><p><strong>DI（Dependency Injection）依赖注入</strong>：就是指对象被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类了，而是在容器实例化对象的时候主动将它依赖的类注入给它</p><p>在传统的编程中，一个对象通常负责创建其依赖的其他对象，这导致了高度耦合的代码，难以修改和维护。通过使用IoC，我们将控制权转移到框架（或容器）中，框架负责创建和管理对象的实例，并将它们注入到需要它们的组件中</p><p>Spring IoC的主要组件是Bean容器，它负责实例化、配置和管理Bean（对象）。<code>Bean</code> 是Spring框架中的核心组件，它们是由Spring容器创建和管理的普通Java对象。</p><p>Spring IoC的实现方式有两种：基于XML配置和基于注解配置</p><h3 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h3><p>最基本的启动 Spring 容器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:applicationfile.xml&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 从名字上就可以看出来，就是在 <em>ClassPath</em> 中寻找 <em>xml</em> 配置文件，根据 <em>xml</em> 文件内容来构建 <code>ApplicationContext</code>。当然，除了 <code>ClassPathXmlApplicationContext</code> 以外，我们也还有其他构建 <code>ApplicationContext</code> 的方案可供选择</p><p><img src="/posts/9827/image-20230721214735686.png" alt="ApplicationContext的继承结构"></p><p><code>ClassPathXmlApplicationContext</code> 的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;configLocation&#125;, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际调用的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(</span><br><span class="hljs-params">      String[] configLocations, <span class="hljs-type">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>   <span class="hljs-comment">// 父类构造方法</span><br>   <span class="hljs-built_in">super</span>(parent);<br>   <span class="hljs-comment">// 设置Bean配置信息的路径</span><br>   setConfigLocations(configLocations);<br>   <span class="hljs-keyword">if</span> (refresh) &#123;<br>      <span class="hljs-comment">// 主要逻辑</span><br>      refresh();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有像 <code>AnnotationConfigApplicationContext</code> 、<code>FileSystemXmlApplicationContext</code> 、<code>XmlWebApplicationContext</code> 等都继承自父容器 <code>AbstractApplicationContext</code> 主要用到了装饰器模式和策略模式，最终都是调用 <strong>refresh()</strong> 方法</p><p><code>AbstractApplicationContext#refresh</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br><span class="hljs-comment">// Prepare this context for refreshing.</span><br>     <span class="hljs-comment">// 1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span><br>prepareRefresh();<br><br><span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>     <span class="hljs-comment">// 2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从子类的refreshBeanFactory()方法启动</span><br><span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br><span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>     <span class="hljs-comment">// 3、为BeanFactory配置容器特性，例如类加载器、事件处理器等</span><br>prepareBeanFactory(beanFactory);<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>       <span class="hljs-comment">// 4、为容器的某些子类指定特殊的BeanPost事件处理器</span><br>postProcessBeanFactory(beanFactory);<br><br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br><span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>       <span class="hljs-comment">// 5、调用所有注册的BeanFactoryPostProcessor的Bean</span><br>invokeBeanFactoryPostProcessors(beanFactory);<br><br><span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>       <span class="hljs-comment">// 6、为BeanFactory注册BeanPost事件处理器. BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span><br>registerBeanPostProcessors(beanFactory);<br>beanPostProcess.end();<br><br><span class="hljs-comment">// Initialize message source for this context.</span><br>       <span class="hljs-comment">// 7、初始化信息源，和国际化相关.</span><br>initMessageSource();<br><br><span class="hljs-comment">// Initialize event multicaster for this context.</span><br>       <span class="hljs-comment">// 8、初始化容器事件传播器.</span><br>initApplicationEventMulticaster();<br><br><span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>       <span class="hljs-comment">// 9、空方法，留给子类扩展</span><br>onRefresh();<br><br><span class="hljs-comment">// Check for listener beans and register them.</span><br>       <span class="hljs-comment">// 10、为事件传播器注册事件监听器.</span><br>registerListeners();<br><br><span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>       <span class="hljs-comment">// 11、初始化所有剩余的单例Bean</span><br>finishBeanFactoryInitialization(beanFactory);<br><br><span class="hljs-comment">// Last step: publish corresponding event.</span><br>       <span class="hljs-comment">// 12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br>finishRefresh();<br>&#125;<br><br><span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br><span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br><span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>&#125;<br><br><span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>       <span class="hljs-comment">// 13、销毁已创建的Bean</span><br>destroyBeans();<br><br><span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>       <span class="hljs-comment">// 14、取消refresh操作，重置容器的同步标识</span><br>cancelRefresh(ex);<br><br><span class="hljs-comment">// Propagate exception to caller.</span><br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>       <span class="hljs-comment">// 15、重设公共缓存</span><br>resetCommonCaches();<br>contextRefresh.end();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>refresh()</code>方法是在应用程序上下文（<em>ApplicationContext</em>）启动过程中的一个重要方法。它的主要作用是刷新应用程序上下文，也就是启动Spring容器并完成初始化过程，使得容器准备好处理请求和提供Bean实例。它在以下情况下被调用：</p><ol><li>Spring容器启动时，<code>refresh()</code>方法会在容器初始化时调用，用于创建和初始化所有注册的Bean。</li><li>在热加载（<em>hot reloading</em>）场景中，当类文件或配置文件发生变化时，可以手动调用<code>refresh()</code>方法来重新加载 <code>ApplicationContext</code>，实现动态更新应用程序上下文。</li></ol><p><code>refresh()</code>方法的执行过程包括以下主要步骤：</p><ol><li>调用<code>prepareRefresh()</code>方法：在刷新之前执行的预处理，通常用于初始化容器的状态</li><li>调用<code>obtainFreshBeanFactory()</code>方法：创建或获取一个新的BeanFactory实例，这是整个IOC容器的核心。它负责Bean的注册、依赖注入等工作</li><li>调用<code>prepareBeanFactory(beanFactory)</code>方法：对BeanFactory进行一些设置，如注册后置处理器、添加属性编辑器等</li><li>调用<code>postProcessBeanFactory(beanFactory)</code>方法：允许子类在标准初始化后对BeanFactory进行进一步的定制</li><li>调用<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法：调用所有注册的BeanFactory后置处理器，这些后置处理器可以修改或添加BeanFactory中的Bean定义</li><li>调用<code>registerBeanPostProcessors(beanFactory)</code>方法：注册所有的Bean后置处理器，这些后置处理器会在Bean的初始化过程中添加额外的逻辑</li><li>调用<code>initMessageSource()</code>方法：初始化消息资源，用于国际化支持</li><li>调用<code>initApplicationEventMulticaster()</code>方法：初始化事件广播器，用于处理应用程序事件</li><li>调用<code>onRefresh()</code>方法：在刷新过程中的回调方法，允许子类执行自定义的刷新逻辑</li><li>调用<code>registerListeners()</code>方法：注册应用程序事件监听器</li><li>调用<code>finishBeanFactoryInitialization(beanFactory)</code>方法：完成剩余的Bean初始化工作，包括实例化非懒加载的单例Bean</li><li>调用<code>finishRefresh()</code>方法：在刷新过程完成后执行的回调方法</li><li>完成刷新过程，容器准备好接收请求并提供Bean实例</li></ol><p><code>refresh()</code> 方法里反复提到了一个类：<code>BeanFactory</code>，下面先解释一下 <code>BeanFactory</code> 是什么</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。BeanFactory 在 Spring 中是一个核心接口，它是IOC容器的基础，负责创建、管理和查找Bean对象。BeanFactory定义了访问Spring容器中Bean的标准方法，提供了IOC容器的基本功能</p><p><img src="/posts/9827/2.png" alt="BeanFactory继承关系"></p><ol><li><code>ApplicationContext</code> 继承了 <code>ListableBeanFactory</code>，这个 <em>Listable</em> 的意思就是，通过这个接口可以获取多个 Bean</li><li><code>ApplicationContext</code> 继承了 <code>HierarchicalBeanFactory</code>，<em>Hierarchical</em> 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系</li><li><code>AutowireCapableBeanFactory</code> 这个名字中的 <code>Autowire</code> 表明它就是用来自动装配 Bean 用的，虽然<code>ApplicationContext</code> 并没有继承它，但是可以通过组合的方法：<code>ApplicationContext</code> 接口定义中的最后一个方法 <code>getAutowireCapableBeanFactory()</code> </li><li><code>ConfigurableListableBeanFactory</code> 也是一个特殊的接口，在于它继承了第二层所有的三个接口，而 <code>ApplicationContext</code> 没有</li></ol><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h3><p>再回头来说 <code>refresh()</code>方法，从上到下依次：</p><h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a><code>prepareRefresh()</code></h4><p>创建 Bean 容器前的准备工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareRefresh</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-comment">// 记录启动时间，将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span><br><span class="hljs-built_in">this</span>.startupDate = System.currentTimeMillis();<br><span class="hljs-built_in">this</span>.closed.set(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">this</span>.active.set(<span class="hljs-literal">true</span>);<br>   <br>   ... <span class="hljs-comment">// 省略 log 配置</span><br><br>   <span class="hljs-comment">// 校验 xml 配置文件</span><br>getEnvironment().validateRequiredProperties();<br><br>... <span class="hljs-comment">// 初始化部分 eventListener 容器</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a><code>obtainFreshBeanFactory()</code></h4><p>初始化 BeanFactory，加载 Bean、注册 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title function_">obtainFreshBeanFactory</span><span class="hljs-params">()</span> &#123;<br>refreshBeanFactory();<br><span class="hljs-keyword">return</span> getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractRefreshableApplicationContext#refreshBeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br>   <span class="hljs-comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br>   <span class="hljs-comment">// ApplicationContext 是否有 BeanFactory</span><br><span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>destroyBeans();<br>closeBeanFactory();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// 初始化一个 DefaultListableBeanFactory</span><br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> createBeanFactory();<br>     <span class="hljs-comment">// 设置SerializationId，用于 BeanFactory 的序列化</span><br>beanFactory.setSerializationId(getId());<br>     <span class="hljs-comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br>customizeBeanFactory(beanFactory);<br>     <span class="hljs-comment">// 加载 Bean 到 BeanFactory 中</span><br>loadBeanDefinitions(beanFactory);<br><span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了一个 <code>DefaultListableBeanFactory</code> 实例，从之前的图上看得出，<code>DefaultListableBeanFactory</code> 实现了 <code>ListableBeanFactory</code>，<code>HierarchicalBeanFactory</code> 和 <code>AutowireCapableBeanFactory</code>，是功能最全面的 beanFactory</p><p>beanFactory 说了那么久，他是个 bean 的容器，那么 bean 是什么？bean 在代码层面上可以认为是 beanDefinition 的实例。beanDefinition 中保存了 bean 的信息</p><h5 id="beanDefinition-的接口定义："><a href="#beanDefinition-的接口定义：" class="headerlink" title="beanDefinition 的接口定义："></a><strong><code>beanDefinition</code></strong> 的接口定义：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AttributeAccessor</span>, BeanMetadataElement &#123;<br><br>   <span class="hljs-comment">// 默认提供 sington 和 prototype 两种，</span><br>   <span class="hljs-comment">// 还有很多其他的比如request, session, globalSession, application, websocket他们都是基于web的扩展</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_SINGLETON</span> <span class="hljs-operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_PROTOTYPE</span> <span class="hljs-operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;<br><br>   <span class="hljs-type">int</span> <span class="hljs-variable">ROLE_APPLICATION</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">ROLE_SUPPORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">ROLE_INFRASTRUCTURE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>   <span class="hljs-comment">// 设置父 Bean，这里涉及到 bean 继承</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParentName</span><span class="hljs-params">(String parentName)</span>;<br><br>   <span class="hljs-comment">// 获取父 Bean</span><br>   String <span class="hljs-title function_">getParentName</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 设置 Bean 的类名称，用来通过反射来生成实例</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassName</span><span class="hljs-params">(String beanClassName)</span>;<br><br>   <span class="hljs-comment">// 获取 Bean 的类名称</span><br>   String <span class="hljs-title function_">getBeanClassName</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 设置是否懒加载</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLazyInit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> lazyInit)</span>;<br><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLazyInit</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 设置该 Bean 依赖的所有的 Bean，注意这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br>   <span class="hljs-comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependsOn</span><span class="hljs-params">(String... dependsOn)</span>;<br><br>   <span class="hljs-comment">// 返回该 Bean 的所有依赖</span><br>   String[] getDependsOn();<br><br>   <span class="hljs-comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br>   <span class="hljs-comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autowireCandidate)</span>;<br><br>   <span class="hljs-comment">// setPrimary。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrimary</span><span class="hljs-params">(<span class="hljs-type">boolean</span> primary)</span>;<br><br>   <span class="hljs-comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactoryBeanName</span><span class="hljs-params">(String factoryBeanName)</span>;<br>   <span class="hljs-comment">// 获取工厂名称</span><br>   String <span class="hljs-title function_">getFactoryBeanName</span><span class="hljs-params">()</span>;<br>   <span class="hljs-comment">// 指定工厂类中的 工厂方法名称</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactoryMethodName</span><span class="hljs-params">(String factoryMethodName)</span>;<br>   <span class="hljs-comment">// 获取工厂类中的 工厂方法名称</span><br>   String <span class="hljs-title function_">getFactoryMethodName</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 构造器参数</span><br>   ConstructorArgumentValues <span class="hljs-title function_">getConstructorArgumentValues</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br>   MutablePropertyValues <span class="hljs-title function_">getPropertyValues</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 是否 singleton</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 是否 prototype</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAbstract</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-type">int</span> <span class="hljs-title function_">getRole</span><span class="hljs-params">()</span>;<br>   String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br>   String <span class="hljs-title function_">getResourceDescription</span><span class="hljs-params">()</span>;<br>   BeanDefinition <span class="hljs-title function_">getOriginatingBeanDefinition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="customizeBeanFactory-beanFactory"><a href="#customizeBeanFactory-beanFactory" class="headerlink" title="customizeBeanFactory(beanFactory)"></a><code>customizeBeanFactory(beanFactory)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizeBeanFactory</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowBeanDefinitionOverriding != <span class="hljs-literal">null</span>) &#123;<br>beanFactory.setAllowBeanDefinitionOverriding(<span class="hljs-built_in">this</span>.allowBeanDefinitionOverriding);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCircularReferences != <span class="hljs-literal">null</span>) &#123;<br>beanFactory.setAllowCircularReferences(<span class="hljs-built_in">this</span>.allowCircularReferences);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置是否允许 <code>beanDefinition</code> 覆盖、是否允许循环引用</p><h5 id="loadBeanDefinitions-beanFactory"><a href="#loadBeanDefinitions-beanFactory" class="headerlink" title="loadBeanDefinitions(beanFactory)"></a><code>loadBeanDefinitions(beanFactory)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br><span class="hljs-comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">beanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(beanFactory);<br><br><span class="hljs-comment">// Configure the bean definition reader with this context&#x27;s</span><br><span class="hljs-comment">// resource loading environment.</span><br>beanDefinitionReader.setEnvironment(<span class="hljs-built_in">this</span>.getEnvironment());<br>beanDefinitionReader.setResourceLoader(<span class="hljs-built_in">this</span>);<br>beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEntityResolver</span>(<span class="hljs-built_in">this</span>));<br><br><br>   <span class="hljs-comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span><br>initBeanDefinitionReader(beanDefinitionReader);<br>   <span class="hljs-comment">// 加载/注册 BeanDefinitions</span><br>loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a><code>prepareBeanFactory(beanFactory)</code></h4><p>把在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br><span class="hljs-comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br>   <span class="hljs-comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span><br>beanFactory.setBeanClassLoader(getClassLoader());<br><span class="hljs-keyword">if</span> (!shouldIgnoreSpel) &#123;<br>     <span class="hljs-comment">// 设置 BeanExpressionResolver</span><br>beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));<br>&#125;<br>beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditorRegistrar</span>(<span class="hljs-built_in">this</span>, getEnvironment()));<br><br><span class="hljs-comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br>   <span class="hljs-comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br>   <span class="hljs-comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br>   <span class="hljs-comment">// 注意：它不仅仅回调 ApplicationContextAware，还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextAwareProcessor</span>(<span class="hljs-built_in">this</span>));<br>beanFactory.ignoreDependencyInterface(EnvironmentAware.class);<br>beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);<br>beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<br>beanFactory.ignoreDependencyInterface(MessageSourceAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);<br><br><span class="hljs-comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br>   <span class="hljs-comment">// Spring 会通过其他方式来处理这些依赖。</span><br>beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);<br>beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-built_in">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-built_in">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-built_in">this</span>);<br><br>... <span class="hljs-comment">// 省略</span><br><br><span class="hljs-comment">// 注册默认的 Environment Bean</span><br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>…</p><h4 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory)"></a><code>finishBeanFactoryInitialization(beanFactory)</code></h4><p>负责初始化所有的 singleton beans。到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 <code>postProcessBeanFactory(factory)</code> 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br><span class="hljs-comment">// 首先，初始化名字为 conversionService 的 Bean</span><br><span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;<br>beanFactory.setConversionService(<br>beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>&#125;<br><br>... <span class="hljs-comment">// 略过</span><br><br><span class="hljs-comment">// 开始初始化</span><br>beanFactory.preInstantiateSingletons();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>preInstantiateSingletons()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// this.beanDefinitionNames 保存了所有的 beanNames</span><br>List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>   <span class="hljs-comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br>   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>     ... <span class="hljs-comment">// 略过</span><br>  <span class="hljs-comment">// 对于普通的 bean，通过这个方法初始化</span><br>     getBean(beanName);<br>    ... <span class="hljs-comment">// 略过</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getBean()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType, <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br>   <span class="hljs-comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br><br>   <span class="hljs-comment">// 返回值</span><br>   Object bean; <br><br>   <span class="hljs-comment">// 检查下是不是已经创建过了</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><br>   <span class="hljs-comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br>   <span class="hljs-comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br>   <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>         <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>            logger.debug(<span class="hljs-string">&quot;...&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            logger.debug(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>         &#125;<br>      &#125;<br>      <span class="hljs-comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br>      <span class="hljs-comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br>      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>         <span class="hljs-comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span><br>         <span class="hljs-comment">// 往往是因为陷入了循环引用</span><br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>      &#125;<br><br>      <span class="hljs-comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span><br>      <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>      <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>         <span class="hljs-comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>         <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回父容器的查询结果</span><br>            <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>            <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>         &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>         <span class="hljs-comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br>         markBeanAsCreated(beanName);<br>      &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">       * 准备创建 Bean，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class="hljs-comment">       * 对于 prototype 的 Bean 来说，创建一个新的 Bean。</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>         checkMergedBeanDefinition(mbd, beanName, args);<br><br>         <span class="hljs-comment">// 先初始化依赖的所有 Bean，这个很好理解。</span><br>         <span class="hljs-comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br>         String[] dependsOn = mbd.getDependsOn();<br>         <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>               <span class="hljs-comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br>               <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>               &#125;<br>               <span class="hljs-comment">// 注册一下依赖关系</span><br>               registerDependentBean(dep, beanName);<br>               <span class="hljs-comment">// 先初始化被依赖项</span><br>               getBean(dep);<br>            &#125;<br>         &#125;<br><br>         <span class="hljs-comment">// 如果是 singleton scope 的，创建 singleton 的实例</span><br>         <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>            sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     <span class="hljs-comment">// 执行创建 Bean</span><br>                     <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                  &#125;<br>                  <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                     destroySingleton(beanName);<br>                     <span class="hljs-keyword">throw</span> ex;<br>                  &#125;<br>               &#125;<br>            &#125;);<br>            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果是 prototype scope 的，创建 prototype 的实例</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>            <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>               beforePrototypeCreation(beanName);<br>               <span class="hljs-comment">// 执行创建 Bean</span><br>               prototypeInstance = createBean(beanName, mbd, args);<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>               afterPrototypeCreation(beanName);<br>            &#125;<br>            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br>         <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>            <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>                  <span class="hljs-meta">@Override</span><br>                  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                     beforePrototypeCreation(beanName);<br>                     <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 执行创建 Bean</span><br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                     &#125;<br>                     <span class="hljs-keyword">finally</span> &#123;<br>                        afterPrototypeCreation(beanName);<br>                     &#125;<br>                  &#125;<br>               &#125;);<br>               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName,<br>                     <span class="hljs-string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +<br>                     <span class="hljs-string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,<br>                     ex);<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>         cleanupAfterBeanCreationFailure(beanName);<br>         <span class="hljs-keyword">throw</span> ex;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br>   <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; bean != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<br>         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +<br>                  ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>         &#125;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是<code>createBean()</code></p><p><code>AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>   <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      logger.debug(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>   &#125;<br>   <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;<br><br>   <span class="hljs-comment">// 确保 BeanDefinition 中的 Class 被加载</span><br>   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>   <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>      mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);<br>      mbdToUse.setBeanClass(resolvedClass);<br>   &#125;<br><br>   <span class="hljs-comment">// 准备方法覆写</span><br>   <span class="hljs-keyword">try</span> &#123;<br>      mbdToUse.prepareMethodOverrides();<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),<br>            beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);<br>   &#125;<br><br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理</span><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>      <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> bean; <br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,<br>            <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);<br>   &#125;<br>   <span class="hljs-comment">// 创建 bean</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>   <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      logger.debug(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> beanInstance;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractAutowireCapableBeanFactory#doCreateBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-comment">// Instantiate the bean.</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-comment">// 说明不是 FactoryBean，这里实例化 Bean</span><br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br>... <span class="hljs-comment">// 跳过</span><br><br><span class="hljs-comment">// 解决循环依赖的问题</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>isSingletonCurrentlyInCreation(beanName));<br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br><span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>&#125;<br>     <span class="hljs-comment">// 向容器注册一个单例Bean实例的工厂</span><br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br><br><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// 负责属性装配，因为前面的实例只是实例化了，并没有设值</span><br>populateBean(beanName, mbd, instanceWrapper);<br>     <span class="hljs-comment">// 处理 bean 初始化完成后的各种回调（例init-method，InitializingBean，BeanPostProcessor）</span><br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br>   <br>  ... <span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于Annotation的IoC初始化"><a href="#基于Annotation的IoC初始化" class="headerlink" title="基于Annotation的IoC初始化"></a>基于Annotation的IoC初始化</h3><h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>从Spring2.0以后的版本中，Spring也引入了基于注解（Annotation）方式的配置，注解（Annotation）是JDK1.5中引入的一个新特性，用于简化Bean的配置，可以取代XML配置文件。开发人员对注解（Annotation）的态度也是萝卜白菜各有所爱，个人认为注解可以简化配置，提高开发速度，但也给后期维护增加了难度。随着Spring Boot的兴起，基于注解的开发甚至实现了零配置。Spring IOC容器对于类级别的注解和类内部的注解分一下两种处理策略：</p><ol><li>类级别的注解：<code>@Component</code>、<code>@Repository</code>、<code>@Controller</code>、<code>@Service</code>以及JavaEE6的<code>@ManagedBean</code>和<code>@Named</code>注解，都是添加在类上面的类级别注解，Spring容器根据注解的过滤规则扫描读取注解Bean定义类，并将其注册到Spring IOC容器中。</li><li>类内部的注解：<code>@Autowire</code>、<code>@Value</code>、<code>@Resource</code>以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，Spring IOC容器通过Bean后置注解处理器解析Bean内部的注解。</li></ol><h4 id="定位Bean扫描路径"><a href="#定位Bean扫描路径" class="headerlink" title="定位Bean扫描路径"></a>定位Bean扫描路径</h4><p>在Spring中管理注解Bean定义的容器有两个：<code>AnnotationConfigApplicationContext</code> 和<code>AnnotationConfigWebApplicationContext</code>。这两个类的专门处理Spring注解方式配置的容器，直接依赖于注解作为容器配置信息来源的IOC容器。<code>AnnotationConfigWebApplicationContext</code> 是 <code>AnnotationConfigApplicationContext</code> 的Web版本，两者的用法以及对注解的处理方式几乎没有差别。现在我们以 <code>AnnotationConfigApplicationContext</code> 为例看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotationConfigRegistry</span> &#123;<br><br>   <span class="hljs-comment">//保存一个读取注解的Bean定义读取器，并将其设置到容器中</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;<br><br>   <span class="hljs-comment">//保存一个扫描指定类路径中注解Bean定义的扫描器，并将其设置到容器中</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;<br><br>   <span class="hljs-comment">//默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其register()</span><br>   <span class="hljs-comment">//方法注册配置类，并调用refresh()方法刷新容器，触发容器对注解Bean的载入、解析和注册过程</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> &#123;<br>      <span class="hljs-built_in">super</span>(beanFactory);<br>      <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的Bean自动注册到容器中</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;<br>      <span class="hljs-built_in">this</span>();<br>      register(annotatedClasses);<br>      refresh();<br>   &#125;<br><br>   <span class="hljs-comment">//该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的Spring Bean，将其注册到容器中</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>      <span class="hljs-built_in">this</span>();<br>      scan(basePackages);<br>      refresh();<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> &#123;<br>      <span class="hljs-built_in">super</span>.setEnvironment(environment);<br>      <span class="hljs-built_in">this</span>.reader.setEnvironment(environment);<br>      <span class="hljs-built_in">this</span>.scanner.setEnvironment(environment);<br>   &#125;<br><br>   <span class="hljs-comment">//为容器的注解Bean读取器和注解Bean扫描器设置Bean名称产生器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanNameGenerator</span><span class="hljs-params">(BeanNameGenerator beanNameGenerator)</span> &#123;<br>      <span class="hljs-built_in">this</span>.reader.setBeanNameGenerator(beanNameGenerator);<br>      <span class="hljs-built_in">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);<br>      getBeanFactory().registerSingleton(<br>            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);<br>   &#125;<br><br>   <span class="hljs-comment">//为容器的注解Bean读取器和注解Bean扫描器设置作用范围元信息解析器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScopeMetadataResolver</span><span class="hljs-params">(ScopeMetadataResolver scopeMetadataResolver)</span> &#123;<br>      <span class="hljs-built_in">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);<br>      <span class="hljs-built_in">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);<br>   &#125;<br><br>   <span class="hljs-comment">//为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的</span><br>   <span class="hljs-comment">//refresh()方法刷新容器，触发容器对新注册的Bean的处理</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;<br>      Assert.notEmpty(annotatedClasses, <span class="hljs-string">&quot;At least one annotated class must be specified&quot;</span>);<br>      <span class="hljs-built_in">this</span>.reader.register(annotatedClasses);<br>   &#125;<br><br>   <span class="hljs-comment">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用</span><br>   <span class="hljs-comment">//refresh()方法刷新容器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>      Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>      <span class="hljs-built_in">this</span>.scanner.scan(basePackages);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, Object... constructorArguments)</span> &#123;<br>      registerBean(<span class="hljs-literal">null</span>, annotatedClass, constructorArguments);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; annotatedClass, Object... constructorArguments)</span> &#123;<br>      <span class="hljs-built_in">this</span>.reader.doRegisterBean(annotatedClass, <span class="hljs-literal">null</span>, beanName, <span class="hljs-literal">null</span>,<br>            bd -&gt; &#123;<br>               <span class="hljs-keyword">for</span> (Object arg : constructorArguments) &#123;<br>                  bd.getConstructorArgumentValues().addGenericArgumentValue(arg);<br>               &#125;<br>            &#125;);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; beanClass, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">         BeanDefinitionCustomizer... customizers)</span> &#123;<br><br>      <span class="hljs-built_in">this</span>.reader.doRegisterBean(beanClass, supplier, beanName, <span class="hljs-literal">null</span>, customizers);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的源码分析，我们可以看到Spring对注解的处理分为两种方式：</p><ol><li>直接将注解Bean注册到容器中。可以在初始化容器时注册，也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容器，使得容器对注册的注解Bean进行处理</li><li>通过扫描指定的包及其子包下的所有类。在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加注解Bean，则需要手动调用容器扫描方法，然后手动刷新容器，使得容器对锁注册的Bean进行处理</li></ol><p>接下来，将会对两种处理方式详细分析其实现过程</p><h4 id="读取Annotation元数据"><a href="#读取Annotation元数据" class="headerlink" title="读取Annotation元数据"></a>读取Annotation元数据</h4><h5 id="直接将注解Bean注册到容器中"><a href="#直接将注解Bean注册到容器中" class="headerlink" title="直接将注解Bean注册到容器中"></a>直接将注解Bean注册到容器中</h5><p><strong><code>AnnotationConfigApplicationContext</code> 通过调用注解Bean定义读取器</strong></p><p><code>AnnotatedBeanDefinitionReader</code> 的 <code>register()</code> 方法向容器注册指定注解Bean，注解Bean定义读取器向容器注册注解Bean的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册多个注解Bean定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;<br>   <span class="hljs-keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;<br>      registerBean(annotatedClass);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//注册一个注解Bean定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; annotatedClass)</span> &#123;<br>   doRegisterBean(annotatedClass, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier)</span> &#123;<br>   doRegisterBean(annotatedClass, instanceSupplier, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, String name, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier)</span> &#123;<br>   doRegisterBean(annotatedClass, instanceSupplier, name, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-comment">//Bean定义读取器注册注解Bean定义的入口方法</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> &#123;<br>   doRegisterBean(annotatedClass, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, qualifiers);<br>&#125;<br><br><span class="hljs-comment">//Bean定义读取器向容器注册注解Bean定义类</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> &#123;<br>   doRegisterBean(annotatedClass, <span class="hljs-literal">null</span>, name, qualifiers);<br>&#125;<br><br><span class="hljs-comment">//Bean定义读取器向容器注册注解Bean定义类</span><br>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier, <span class="hljs-meta">@Nullable</span> String name,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> &#123;<br><br>   <span class="hljs-comment">//根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构</span><br>   <span class="hljs-type">AnnotatedGenericBeanDefinition</span> <span class="hljs-variable">abd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span>(annotatedClass);<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br><br>   abd.setInstanceSupplier(instanceSupplier);<br>   <span class="hljs-comment">//解析注解Bean定义的作用域，若@Scope(&quot;prototype&quot;)，则Bean为原型类型；</span><br>   <span class="hljs-comment">//若@Scope(&quot;singleton&quot;)，则Bean为单态类型</span><br>   <span class="hljs-type">ScopeMetadata</span> <span class="hljs-variable">scopeMetadata</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);<br>   <span class="hljs-comment">//为注解Bean定义设置作用域</span><br>   abd.setScope(scopeMetadata.getScopeName());<br>   <span class="hljs-comment">//为注解Bean定义生成Bean名称</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> (name != <span class="hljs-literal">null</span> ? name : <span class="hljs-built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-built_in">this</span>.registry));<br><br>   <span class="hljs-comment">//处理注解Bean定义中的通用注解</span><br>   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);<br>   <span class="hljs-comment">//如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。</span><br>   <span class="hljs-comment">//主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解</span><br>   <span class="hljs-comment">//Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称</span><br>   <span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;<br>         <span class="hljs-comment">//如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选</span><br>         <span class="hljs-keyword">if</span> (Primary.class == qualifier) &#123;<br>            abd.setPrimary(<span class="hljs-literal">true</span>);<br>         &#125;<br>         <span class="hljs-comment">//如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置，</span><br>         <span class="hljs-comment">//则该Bean为预实例化</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy.class == qualifier) &#123;<br>            abd.setLazyInit(<span class="hljs-literal">true</span>);<br>         &#125;<br>         <span class="hljs-comment">//如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一</span><br>         <span class="hljs-comment">//个autowiring自动依赖注入装配限定符，该Bean在进autowiring</span><br>         <span class="hljs-comment">//自动依赖注入装配时，根据名称装配限定符指定的Bean</span><br>         <span class="hljs-keyword">else</span> &#123;<br>            abd.addQualifier(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AutowireCandidateQualifier</span>(qualifier));<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;<br>      customizer.customize(abd);<br>   &#125;<br><br>   <span class="hljs-comment">//创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据</span><br>   <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">definitionHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(abd, beanName);<br>   <span class="hljs-comment">//根据注解Bean定义类中配置的作用域，创建相应的代理对象</span><br>   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>   <span class="hljs-comment">//向IOC容器注册注解Bean类定义对象</span><br>   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的源码分析，我们可以看到注册注解Bean定义类的基本步骤：</p><ol><li>需要使用注解元数据解析器计息注解Bean中关于作用域的配置。</li><li>使用<code>AnnotationConfigUtils</code>的<code>processCommonDefinitionAnnotations</code>()方法处理注解Bean定义类中通用注解。</li><li>使用<code>AnnotationConfigUtils</code>的<code>appliyScopedProxyMode()</code>方法创建对于作用域的代理对象。</li><li>通过<code>BeanDefinitaionReaderUtils</code>向容器注册Bean。</li></ol><p><strong><code>AnnotationScopeMetadataResolver</code>解析作用域元数据</strong></p><p><code>AnnotationScopeMetadataResolver</code> 通过 <code>resolveScopeMetadata()</code> 方法解析注册Bean定义类的作用域元信息，即判断注册的Bean是原型类型(<em>prototype</em>)还是单例类型（<em>singleton</em>），其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解析注解Bean定义类中的作用域元信息</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ScopeMetadata <span class="hljs-title function_">resolveScopeMetadata</span><span class="hljs-params">(BeanDefinition definition)</span> &#123;<br>   <span class="hljs-type">ScopeMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeMetadata</span>();<br>   <span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>      <span class="hljs-type">AnnotatedBeanDefinition</span> <span class="hljs-variable">annDef</span> <span class="hljs-operator">=</span> (AnnotatedBeanDefinition) definition;<br>      <span class="hljs-comment">//从注解Bean定义类的属性中查找属性为”Scope”的值，即@Scope注解的值</span><br>      <span class="hljs-comment">//annDef.getMetadata().getAnnotationAttributes()方法将Bean</span><br>      <span class="hljs-comment">//中所有的注解和注解的值存放在一个map集合中</span><br>      <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> AnnotationConfigUtils.attributesFor(<br>            annDef.getMetadata(), <span class="hljs-built_in">this</span>.scopeAnnotationType);<br>      <span class="hljs-comment">//将获取到的@Scope注解的值设置到要返回的对象中</span><br>      <span class="hljs-keyword">if</span> (attributes != <span class="hljs-literal">null</span>) &#123;<br>         metadata.setScopeName(attributes.getString(<span class="hljs-string">&quot;value&quot;</span>));<br>         <span class="hljs-comment">//获取@Scope注解中的proxyMode属性值，在创建代理对象时会用到</span><br>         <span class="hljs-type">ScopedProxyMode</span> <span class="hljs-variable">proxyMode</span> <span class="hljs-operator">=</span> attributes.getEnum(<span class="hljs-string">&quot;proxyMode&quot;</span>);<br>         <span class="hljs-comment">//如果@Scope的proxyMode属性为DEFAULT或者NO</span><br>         <span class="hljs-keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;<br>            <span class="hljs-comment">//设置proxyMode为NO</span><br>            proxyMode = <span class="hljs-built_in">this</span>.defaultProxyMode;<br>         &#125;<br>         <span class="hljs-comment">//为返回的元数据设置proxyMode</span><br>         metadata.setScopedProxyMode(proxyMode);<br>      &#125;<br>   &#125;<br>   <span class="hljs-comment">//返回解析的作用域元信息对象</span><br>   <span class="hljs-keyword">return</span> metadata;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中：<code>AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType);</code> 这里就是获取对象中指定类型的注解值。</p><p><strong><code>AnnotationConfigUtils</code>处理注解Bean定义类中的通用注解</strong></p><p><code>AnnotationConfigUtils</code> 类的 <code>processCommonDefinitionAnnotations()</code> 在向容器注册Bean之前，首先对注解Bean定义类中的通用Spring注解进行处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd)</span> &#123;<br>   processCommonDefinitionAnnotations(abd, abd.getMetadata());<br>&#125;<br><br><span class="hljs-comment">//处理Bean定义中通用注解</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> &#123;<br>   <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">lazy</span> <span class="hljs-operator">=</span> attributesFor(metadata, Lazy.class);<br>   <span class="hljs-comment">//如果Bean定义中有@Lazy注解，则将该Bean预实例化属性设置为@lazy注解的值</span><br>   <span class="hljs-keyword">if</span> (lazy != <span class="hljs-literal">null</span>) &#123;<br>      abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">&quot;value&quot;</span>));<br>   &#125;<br><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abd.getMetadata() != metadata) &#123;<br>      lazy = attributesFor(abd.getMetadata(), Lazy.class);<br>      <span class="hljs-keyword">if</span> (lazy != <span class="hljs-literal">null</span>) &#123;<br>         abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">&quot;value&quot;</span>));<br>      &#125;<br>   &#125;<br>   <span class="hljs-comment">//如果Bean定义中有@Primary注解，则为该Bean设置为autowiring自动依赖注入装配的首选对象</span><br>   <span class="hljs-keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;<br>      abd.setPrimary(<span class="hljs-literal">true</span>);<br>   &#125;<br>   <span class="hljs-comment">//如果Bean定义中有@ DependsOn注解，则为该Bean设置所依赖的Bean名称，</span><br>   <span class="hljs-comment">//容器将确保在实例化该Bean之前首先实例化所依赖的Bean</span><br>   <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">dependsOn</span> <span class="hljs-operator">=</span> attributesFor(metadata, DependsOn.class);<br>   <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>      abd.setDependsOn(dependsOn.getStringArray(<span class="hljs-string">&quot;value&quot;</span>));<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (abd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>      <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">absBd</span> <span class="hljs-operator">=</span> (AbstractBeanDefinition) abd;<br>      <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> attributesFor(metadata, Role.class);<br>      <span class="hljs-keyword">if</span> (role != <span class="hljs-literal">null</span>) &#123;<br>         absBd.setRole(role.getNumber(<span class="hljs-string">&quot;value&quot;</span>).intValue());<br>      &#125;<br>      <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> attributesFor(metadata, Description.class);<br>      <span class="hljs-keyword">if</span> (description != <span class="hljs-literal">null</span>) &#123;<br>         absBd.setDescription(description.getString(<span class="hljs-string">&quot;value&quot;</span>));<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>AnnotationConfigUtils</code>根据注解Bean定义类中配置的作用域为其应用响应的代理策略</strong></p><p><code>AnnotationConfigUtils </code>类的 <code>applyScopedProxyMode()</code> 方法根据注解Bean定义类中配置的作用域<code>@Scope</code>注解的值，为Bean定义应用响应的代理模式，主要是在Spring面向切面编程（AOP）中使用。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据作用域为Bean应用引用的代码模式</span><br><span class="hljs-keyword">static</span> BeanDefinitionHolder <span class="hljs-title function_">applyScopedProxyMode</span><span class="hljs-params">(</span><br><span class="hljs-params">      ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> &#123;<br><br>   <span class="hljs-comment">//获取注解Bean定义类中@Scope注解的proxyMode属性值</span><br>   <span class="hljs-type">ScopedProxyMode</span> <span class="hljs-variable">scopedProxyMode</span> <span class="hljs-operator">=</span> metadata.getScopedProxyMode();<br>   <span class="hljs-comment">//如果配置的@Scope注解的proxyMode属性值为NO，则不应用代理模式</span><br>   <span class="hljs-keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;<br>      <span class="hljs-keyword">return</span> definition;<br>   &#125;<br>   <span class="hljs-comment">//获取配置的@Scope注解的proxyMode属性值，如果为TARGET_CLASS</span><br>   <span class="hljs-comment">//则返回true，如果为INTERFACES，则返回false</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">proxyTargetClass</span> <span class="hljs-operator">=</span> scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);<br>   <span class="hljs-comment">//为注册的Bean创建相应模式的代理对象</span><br>   <span class="hljs-keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段为Bean引用创建相应模式的代理。这里不做深入分析。</p><p><strong><code>BeanDefinitionReaderUtils</code> 向容器注册Bean</strong></p><p>BeanDefinitionReaderUtils主要是校验BeanDefinition信息，然后将Bean添加到容器中一个管理BeanDefinition的HashMap中。</p><h5 id="扫描指定包并解析为BeanDefinition"><a href="#扫描指定包并解析为BeanDefinition" class="headerlink" title="扫描指定包并解析为BeanDefinition"></a>扫描指定包并解析为BeanDefinition</h5><p>当创建注解处理器时，如果传入的初始参数是注解Bean定义类锁在的包时，注解容器将扫描给定的包及其子包，将扫描到的注解Bean定义载入并注册。</p><p><strong><code>ClassPathBeanDefinitionScanner</code>扫描给定的包及其子包</strong></p><p>AnnotationConfigApplicationContext通过调用类路径Bean定义扫描ClassPathBeanDefinitionScanner扫描给定包及其子包下的所有类，主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassPathScanningCandidateComponentProvider</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">BeanDefinitionDefaults</span> <span class="hljs-variable">beanDefinitionDefaults</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionDefaults</span>();<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">private</span> String[] autowireCandidatePatterns;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">BeanNameGenerator</span> <span class="hljs-variable">beanNameGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationBeanNameGenerator</span>();<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">ScopeMetadataResolver</span> <span class="hljs-variable">scopeMetadataResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationScopeMetadataResolver</span>();<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">includeAnnotationConfig</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>   <span class="hljs-comment">//创建一个类路径Bean定义扫描器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>      <span class="hljs-built_in">this</span>(registry, <span class="hljs-literal">true</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//为容器创建一个类路径Bean定义扫描器，并指定是否使用默认的扫描过滤规则。</span><br>   <span class="hljs-comment">//即Spring默认扫描配置：@Component、@Repository、@Service、@Controller</span><br>   <span class="hljs-comment">//注解的Bean，同时也支持JavaEE6的@ManagedBean和JSR-330的@Named注解</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-type">boolean</span> useDefaultFilters)</span> &#123;<br>      <span class="hljs-built_in">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-type">boolean</span> useDefaultFilters,</span><br><span class="hljs-params">         Environment environment)</span> &#123;<br><br>      <span class="hljs-built_in">this</span>(registry, useDefaultFilters, environment,<br>            (registry <span class="hljs-keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="hljs-literal">null</span>));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-type">boolean</span> useDefaultFilters,</span><br><span class="hljs-params">         Environment environment, <span class="hljs-meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;<br><br>      Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>      <span class="hljs-comment">//为容器设置加载Bean定义的注册器</span><br>      <span class="hljs-built_in">this</span>.registry = registry;<br><br>      <span class="hljs-keyword">if</span> (useDefaultFilters) &#123;<br>         registerDefaultFilters();<br>      &#125;<br>      setEnvironment(environment);<br>      <span class="hljs-comment">//为容器设置资源加载器</span><br>      setResourceLoader(resourceLoader);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.registry;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanDefinitionDefaults</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> BeanDefinitionDefaults beanDefinitionDefaults)</span> &#123;<br>      <span class="hljs-built_in">this</span>.beanDefinitionDefaults =<br>            (beanDefinitionDefaults != <span class="hljs-literal">null</span> ? beanDefinitionDefaults : <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionDefaults</span>());<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> BeanDefinitionDefaults <span class="hljs-title function_">getBeanDefinitionDefaults</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanDefinitionDefaults;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAutowireCandidatePatterns</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... autowireCandidatePatterns)</span> &#123;<br>      <span class="hljs-built_in">this</span>.autowireCandidatePatterns = autowireCandidatePatterns;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanNameGenerator</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> BeanNameGenerator beanNameGenerator)</span> &#123;<br>      <span class="hljs-built_in">this</span>.beanNameGenerator = (beanNameGenerator != <span class="hljs-literal">null</span> ? beanNameGenerator : <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationBeanNameGenerator</span>());<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScopeMetadataResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ScopeMetadataResolver scopeMetadataResolver)</span> &#123;<br>      <span class="hljs-built_in">this</span>.scopeMetadataResolver =<br>            (scopeMetadataResolver != <span class="hljs-literal">null</span> ? scopeMetadataResolver : <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationScopeMetadataResolver</span>());<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScopedProxyMode</span><span class="hljs-params">(ScopedProxyMode scopedProxyMode)</span> &#123;<br>      <span class="hljs-built_in">this</span>.scopeMetadataResolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationScopeMetadataResolver</span>(scopedProxyMode);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIncludeAnnotationConfig</span><span class="hljs-params">(<span class="hljs-type">boolean</span> includeAnnotationConfig)</span> &#123;<br>      <span class="hljs-built_in">this</span>.includeAnnotationConfig = includeAnnotationConfig;<br>   &#125;<br><br>   <span class="hljs-comment">//调用类路径Bean定义扫描器入口方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>      <span class="hljs-comment">//获取容器中已经注册的Bean个数</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">beanCountAtScanStart</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.registry.getBeanDefinitionCount();<br><br>      <span class="hljs-comment">//启动扫描器扫描给定包</span><br>      doScan(basePackages);<br><br>      <span class="hljs-comment">// Register annotation config processors, if necessary.</span><br>      <span class="hljs-comment">//注册注解配置(Annotation config)处理器</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.includeAnnotationConfig) &#123;<br>         AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-built_in">this</span>.registry);<br>      &#125;<br><br>      <span class="hljs-comment">//返回注册的Bean个数</span><br>      <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);<br>   &#125;<br><br>   <span class="hljs-comment">//类路径Bean定义扫描器扫描给定包及其子包</span><br>   <span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">doScan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>      Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>      <span class="hljs-comment">//创建一个集合，存放扫描到Bean定义的封装类</span><br>      Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>      <span class="hljs-comment">//遍历扫描所有给定的包</span><br>      <span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br>         <span class="hljs-comment">//调用父类ClassPathScanningCandidateComponentProvider的方法</span><br>         <span class="hljs-comment">//扫描给定类路径，获取符合条件的Bean定义</span><br>         Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br>         <span class="hljs-comment">//遍历扫描到的Bean</span><br>         <span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>            <span class="hljs-comment">//获取Bean定义类中@Scope注解的值，即获取Bean的作用域</span><br>            <span class="hljs-type">ScopeMetadata</span> <span class="hljs-variable">scopeMetadata</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br>            <span class="hljs-comment">//为Bean设置注解配置的作用域</span><br>            candidate.setScope(scopeMetadata.getScopeName());<br>            <span class="hljs-comment">//为Bean生成名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-built_in">this</span>.registry);<br>            <span class="hljs-comment">//如果扫描到的Bean不是Spring的注解Bean，则为Bean设置默认值，</span><br>            <span class="hljs-comment">//设置Bean的自动依赖注入装配属性等</span><br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>               postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>            &#125;<br>            <span class="hljs-comment">//如果扫描到的Bean是Spring的注解Bean，则处理其通用的Spring注解</span><br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>               <span class="hljs-comment">//处理注解Bean中通用的注解，在分析注解Bean定义类读取器时已经分析过</span><br>               AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>            &#125;<br>            <span class="hljs-comment">//根据Bean名称检查指定的Bean是否需要在容器中注册，或者在容器中冲突</span><br>            <span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br>               <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">definitionHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(candidate, beanName);<br>               <span class="hljs-comment">//根据注解中配置的作用域，为Bean应用相应的代理模式</span><br>               definitionHolder =<br>                     AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>               beanDefinitions.add(definitionHolder);<br>               <span class="hljs-comment">//向容器注册扫描到的Bean</span><br>               registerBeanDefinition(definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> beanDefinitions;<br>   &#125;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类路径Bean定义扫描器<code>ClassPathBeanDefinitionScanner</code>主要通过<code>findCandidateComponents</code>()方法调用其父类<code>ClassPathScanningCandidateComponentProvider</code>类来扫描获取给定包及其子包下的类。</p><p><strong><code>ClassPathScanningCandidateComponentProvider</code>扫描给定包及其子包的类</strong></p><p><code>ClassPathScanningCandidateComponentProvider</code> 类的 <code>findCandidateComponents() </code>方法具体实现扫描给定类路径包的功能，主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathScanningCandidateComponentProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EnvironmentCapable</span>, ResourceLoaderAware &#123;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_RESOURCE_PATTERN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;**/*.class&quot;</span>;<br><br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogFactory.getLog(getClass());<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">resourcePattern</span> <span class="hljs-operator">=</span> DEFAULT_RESOURCE_PATTERN;<br><br>   <span class="hljs-comment">//保存过滤规则要包含的注解，即Spring默认的@Component、@Repository、@Service、</span><br>   <span class="hljs-comment">//@Controller注解的Bean，以及JavaEE6的@ManagedBean和JSR-330的@Named注解</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TypeFilter&gt; includeFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>   <span class="hljs-comment">//保存过滤规则要排除的注解</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TypeFilter&gt; excludeFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>   ...<br>    <br>   <span class="hljs-comment">//构造方法，该方法在子类ClassPathBeanDefinitionScanner的构造方法中被调用</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathScanningCandidateComponentProvider</span><span class="hljs-params">(<span class="hljs-type">boolean</span> useDefaultFilters)</span> &#123;<br>      <span class="hljs-built_in">this</span>(useDefaultFilters, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEnvironment</span>());<br>   &#125;<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathScanningCandidateComponentProvider</span><span class="hljs-params">(<span class="hljs-type">boolean</span> useDefaultFilters, Environment environment)</span> &#123;<br>      <span class="hljs-comment">//如果使用Spring默认的过滤规则，则向容器注册过滤规则</span><br>      <span class="hljs-keyword">if</span> (useDefaultFilters) &#123;<br>         registerDefaultFilters();<br>      &#125;<br>      setEnvironment(environment);<br>      setResourceLoader(<span class="hljs-literal">null</span>);<br>   &#125;<br><br>  .....<br><br>   <span class="hljs-comment">//向容器注册过滤规则</span><br>   <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDefaultFilters</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//向要包含的过滤规则中添加@Component注解类，注意Spring中@Repository</span><br>      <span class="hljs-comment">//@Service和@Controller都是Component，因为这些注解都添加了@Component注解</span><br>      <span class="hljs-built_in">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(Component.class));<br>      <span class="hljs-comment">//获取当前类的类加载器</span><br>      <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassPathScanningCandidateComponentProvider.class.getClassLoader();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//向要包含的过滤规则添加JavaEE6的@ManagedBean注解</span><br>         <span class="hljs-built_in">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(<br>               ((Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="hljs-literal">false</span>));<br>         logger.debug(<span class="hljs-string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>         <span class="hljs-comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//向要包含的过滤规则添加@Named注解</span><br>         <span class="hljs-built_in">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(<br>               ((Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="hljs-literal">false</span>));<br>         logger.debug(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>         <span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>      &#125;<br>   &#125;<br><br> .......<br>  <br>   <span class="hljs-comment">//扫描给定类路径的包</span><br>   <span class="hljs-keyword">public</span> Set&lt;BeanDefinition&gt; <span class="hljs-title function_">findCandidateComponents</span><span class="hljs-params">(String basePackage)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.componentsIndex != <span class="hljs-literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;<br>         <span class="hljs-keyword">return</span> addCandidateComponentsFromIndex(<span class="hljs-built_in">this</span>.componentsIndex, basePackage);<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> scanCandidateComponents(basePackage);<br>      &#125;<br>   &#125;<br><br>  .......<br>  <br>   <span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title function_">addCandidateComponentsFromIndex</span><span class="hljs-params">(CandidateComponentsIndex index, String basePackage)</span> &#123;<br>      <span class="hljs-comment">//创建存储扫描到的类的集合</span><br>      Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>      <span class="hljs-keyword">try</span> &#123;<br>         Set&lt;String&gt; types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>         <span class="hljs-keyword">for</span> (TypeFilter filter : <span class="hljs-built_in">this</span>.includeFilters) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stereotype</span> <span class="hljs-operator">=</span> extractStereotype(filter);<br>            <span class="hljs-keyword">if</span> (stereotype == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Failed to extract stereotype from &quot;</span>+ filter);<br>            &#125;<br>            types.addAll(index.getCandidateTypes(basePackage, stereotype));<br>         &#125;<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">traceEnabled</span> <span class="hljs-operator">=</span> logger.isTraceEnabled();<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">debugEnabled</span> <span class="hljs-operator">=</span> logger.isDebugEnabled();<br>         <span class="hljs-keyword">for</span> (String type : types) &#123;<br>            <span class="hljs-comment">//为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息</span><br>            <span class="hljs-type">MetadataReader</span> <span class="hljs-variable">metadataReader</span> <span class="hljs-operator">=</span> getMetadataReaderFactory().getMetadataReader(type);<br>            <span class="hljs-comment">//如果扫描到的类符合容器配置的过滤规则</span><br>            <span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;<br>               <span class="hljs-comment">//通过汇编(ASM)读取资源字节码中的Bean定义元信息</span><br>               <span class="hljs-type">AnnotatedGenericBeanDefinition</span> <span class="hljs-variable">sbd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span>(<br>                     metadataReader.getAnnotationMetadata());<br>               <span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<br>                  <span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>                     logger.debug(<span class="hljs-string">&quot;Using candidate component class from index: &quot;</span> + type);<br>                  &#125;<br>                  candidates.add(sbd);<br>               &#125;<br>               <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>                     logger.debug(<span class="hljs-string">&quot;Ignored because not a concrete top-level class: &quot;</span> + type);<br>                  &#125;<br>               &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>                  logger.trace(<span class="hljs-string">&quot;Ignored because matching an exclude filter: &quot;</span> + type);<br>               &#125;<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<span class="hljs-string">&quot;I/O failure during classpath scanning&quot;</span>, ex);<br>      &#125;<br>      <span class="hljs-keyword">return</span> candidates;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title function_">scanCandidateComponents</span><span class="hljs-params">(String basePackage)</span> &#123;<br>      Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">packageSearchPath</span> <span class="hljs-operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<br>               resolveBasePackage(basePackage) + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-built_in">this</span>.resourcePattern;<br>         Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">traceEnabled</span> <span class="hljs-operator">=</span> logger.isTraceEnabled();<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">debugEnabled</span> <span class="hljs-operator">=</span> logger.isDebugEnabled();<br>         <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>            <span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>               logger.trace(<span class="hljs-string">&quot;Scanning &quot;</span> + resource);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resource.isReadable()) &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-type">MetadataReader</span> <span class="hljs-variable">metadataReader</span> <span class="hljs-operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);<br>                  <span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;<br>                     <span class="hljs-type">ScannedGenericBeanDefinition</span> <span class="hljs-variable">sbd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScannedGenericBeanDefinition</span>(metadataReader);<br>                     sbd.setResource(resource);<br>                     sbd.setSource(resource);<br>                     <span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<br>                        <span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>                           logger.debug(<span class="hljs-string">&quot;Identified candidate component class: &quot;</span> + resource);<br>                        &#125;<br>                        candidates.add(sbd);<br>                     &#125;<br>                     <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>                           logger.debug(<span class="hljs-string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);<br>                        &#125;<br>                     &#125;<br>                  &#125;<br>                  <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>                        logger.trace(<span class="hljs-string">&quot;Ignored because not matching any filter: &quot;</span> + resource);<br>                     &#125;<br>                  &#125;<br>               &#125;<br>               <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>                        <span class="hljs-string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);<br>               &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>                  logger.trace(<span class="hljs-string">&quot;Ignored because not readable: &quot;</span> + resource);<br>               &#125;<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<span class="hljs-string">&quot;I/O failure during classpath scanning&quot;</span>, ex);<br>      &#125;<br>      <span class="hljs-keyword">return</span> candidates;<br>   &#125;<br><br><br>  .......<br>  <br>   <span class="hljs-comment">//判断元信息读取器读取的类是否符合容器定义的注解过滤规则</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCandidateComponent</span><span class="hljs-params">(MetadataReader metadataReader)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">//如果读取的类的注解在排除注解过滤规则中，返回false</span><br>      <span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-built_in">this</span>.excludeFilters) &#123;<br>         <span class="hljs-keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>      &#125;<br>      <span class="hljs-comment">//如果读取的类的注解在包含的注解的过滤规则中，则返回ture</span><br>      <span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-built_in">this</span>.includeFilters) &#123;<br>         <span class="hljs-keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;<br>            <span class="hljs-keyword">return</span> isConditionMatch(metadataReader);<br>         &#125;<br>      &#125;<br>      <span class="hljs-comment">//如果读取的类的注解既不在排除规则，也不在包含规则中，则返回false</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   .......<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注册注解BeanDefinition</strong></p><p><code>AnnotationConfigWebApplicationContext</code> 是 <code>AnnotationConfigApplicationContext</code> 的 Web 版， 它们对于注解 Bean 的注册和扫描是基本相同的，但是 <code>AnnotationConfigWebApplicationContext</code> 对注解 Bean 定义的载入稍有不同，<code>AnnotationConfigWebApplicationContext</code> 注入注解 Bean 定义 源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//载入注解Bean定义资源</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> &#123;<br>   <span class="hljs-comment">//为容器设置注解Bean定义读取器</span><br>   <span class="hljs-type">AnnotatedBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> getAnnotatedBeanDefinitionReader(beanFactory);<br>   <span class="hljs-comment">//为容器设置类路径Bean定义扫描器</span><br>   <span class="hljs-type">ClassPathBeanDefinitionScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> getClassPathBeanDefinitionScanner(beanFactory);<br><br>   <span class="hljs-comment">//获取容器的Bean名称生成器</span><br>   <span class="hljs-type">BeanNameGenerator</span> <span class="hljs-variable">beanNameGenerator</span> <span class="hljs-operator">=</span> getBeanNameGenerator();<br>   <span class="hljs-comment">//为注解Bean定义读取器和类路径扫描器设置Bean名称生成器</span><br>   <span class="hljs-keyword">if</span> (beanNameGenerator != <span class="hljs-literal">null</span>) &#123;<br>      reader.setBeanNameGenerator(beanNameGenerator);<br>      scanner.setBeanNameGenerator(beanNameGenerator);<br>      beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);<br>   &#125;<br><br>   <span class="hljs-comment">//获取容器的作用域元信息解析器</span><br>   <span class="hljs-type">ScopeMetadataResolver</span> <span class="hljs-variable">scopeMetadataResolver</span> <span class="hljs-operator">=</span> getScopeMetadataResolver();<br>   <span class="hljs-comment">//为注解Bean定义读取器和类路径扫描器设置作用域元信息解析器</span><br>   <span class="hljs-keyword">if</span> (scopeMetadataResolver != <span class="hljs-literal">null</span>) &#123;<br>      reader.setScopeMetadataResolver(scopeMetadataResolver);<br>      scanner.setScopeMetadataResolver(scopeMetadataResolver);<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.annotatedClasses.isEmpty()) &#123;<br>      <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>         logger.info(<span class="hljs-string">&quot;Registering annotated classes: [&quot;</span> +<br>               StringUtils.collectionToCommaDelimitedString(<span class="hljs-built_in">this</span>.annotatedClasses) + <span class="hljs-string">&quot;]&quot;</span>);<br>      &#125;<br>      reader.register(<span class="hljs-built_in">this</span>.annotatedClasses.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[<span class="hljs-built_in">this</span>.annotatedClasses.size()]));<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.basePackages.isEmpty()) &#123;<br>      <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>         logger.info(<span class="hljs-string">&quot;Scanning base packages: [&quot;</span> +<br>               StringUtils.collectionToCommaDelimitedString(<span class="hljs-built_in">this</span>.basePackages) + <span class="hljs-string">&quot;]&quot;</span>);<br>      &#125;<br>      scanner.scan(<span class="hljs-built_in">this</span>.basePackages.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-built_in">this</span>.basePackages.size()]));<br>   &#125;<br><br>   <span class="hljs-comment">//获取容器定义的Bean定义资源路径</span><br>   String[] configLocations = getConfigLocations();<br>   <span class="hljs-comment">//如果定位的Bean定义资源路径不为空</span><br>   <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (String configLocation : configLocations) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//使用当前容器的类加载器加载定位路径的字节码类文件</span><br>            Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());<br>            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>               logger.info(<span class="hljs-string">&quot;Successfully resolved class for [&quot;</span> + configLocation + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            reader.register(clazz);<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>               logger.debug(<span class="hljs-string">&quot;Could not load class for config location [&quot;</span> + configLocation +<br>                     <span class="hljs-string">&quot;] - trying package scan. &quot;</span> + ex);<br>            &#125;<br>            <span class="hljs-comment">//如果容器类加载器加载定义路径的Bean定义资源失败</span><br>            <span class="hljs-comment">//则启用容器类路径扫描器扫描给定路径包及其子包中的类</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> scanner.scan(configLocation);<br>            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>               <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                  logger.info(<span class="hljs-string">&quot;No annotated classes found for specified class/package [&quot;</span> + configLocation + <span class="hljs-string">&quot;]&quot;</span>);<br>               &#125;<br>               <span class="hljs-keyword">else</span> &#123;<br>                  logger.info(<span class="hljs-string">&quot;Found &quot;</span> + count + <span class="hljs-string">&quot; annotated classes in package [&quot;</span> + configLocation + <span class="hljs-string">&quot;]&quot;</span>);<br>               &#125;<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是解析和注入注解配置资源的全过程分析</p><blockquote><p>参考：<a href="https://github.com/wenbin8/doc/blob/master/Spring/02-Spring-IOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">https://github.com/wenbin8/doc/blob/master/Spring/02-Spring-IOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md</a></p></blockquote><h3 id="IOC容器总结"><a href="#IOC容器总结" class="headerlink" title="IOC容器总结"></a>IOC容器总结</h3><p>现在通过上面的代码，总结一下IOC容器初始化的基本步骤：</p><ol><li>初始化的入口在容器实现中的<code>refresh()</code>调用来完成。</li><li>对Bean定义载入IOC容器使用的方法是<code>loadBeanDefinition()</code>，其中大致过程如下：通过<code>ResourceLoader</code>来完成资源文件位置的定位，<code>DefaultResourceLoader</code>是默认实现，同时上下文本身就给出了<code>ResourceLoader</code>的实现，可以从类路径、文件系统、URL等方式来定位资源位置。如果是<code>XmlBeanFactory</code>作为IOC容器，那么需要为它指定Bean定义的资源，也就是Bean定义文件时通过Resource来把IOC容器处理，容器通过<code>BeanDefinitionReader</code>来完成定义信息的解析和Bean信息注册，往往使用的是<code>XmlBeanDefinitionReader</code>来解析Bean的XML定义文件，实际处理过程是委托给<code>BeanDefinitionParserDelegate</code>来完成的，从而得到bean的定义信息，这些信息在Spring中使用BeanDefinition对象来表示，这个名字可以让我们想到 <code>loadBeanDefinition()</code>，<code>registerBeanDefinition()</code> 这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由IOC实现<code>BeanDefinitionRegistry</code>接口来实现。注册过程就是在IOC容器内部维护的一个 HashMap来保存得到的BeanDefinition的过程。这个HashMap是IOC容器持有Bean信息的场所，以后对Bean的操作都是围绕这个HashMap来实现的。</li><li>然后通过<code>BeanFactory</code>和<code>ApplicationContext</code>来享受到Spring IOC的服务了,在使用IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 <code>ServletContext</code> 中的框架 实现</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Spring Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤器 Filter 和拦截器 Interceptor 的异同</title>
    <link href="/posts/41603.html"/>
    <url>/posts/41603.html</url>
    
    <content type="html"><![CDATA[<p>在Web应用程序开发中，Filter和Interceptor是常用的拦截器机制，可以用于对请求和响应进行拦截和处理。它们都可以在请求到达目标资源之前或者离开目标资源之后，对请求和响应进行处理。</p><span id="more"></span><p>通常情况下，Filter是一个用于在请求到达<code>Servlet</code>或<code>Controller</code>之前拦截和处理请求和响应的组件。它可以修改请求或响应、执行身份验证或授权检查，或执行其他预处理或后处理任务。<code>Filter</code>可以在web.xml文件中进行配置，也可以在现代框架如Spring中使用注解进行配置；而<code>Interceptor</code>一般用于在框架级别拦截和处理请求和响应。它特定于某些框架，如Spring MVC或Struts。<code>Interceptor</code>用于执行横切关注点，如日志记录、身份验证或事务管理。它们可以在框架的配置文件中进行配置，也可以使用注解进行配置。</p><h3 id="Filter介绍"><a href="#Filter介绍" class="headerlink" title="Filter介绍"></a>Filter介绍</h3><p><code>Filter</code>可以被视为<code>Servlet</code>的一种“增强版”，主要用于在处理请求前对其进行预处理，也可以在处理响应后对<code>HttpServletResponse</code>进行后处理，形成一个典型的处理链。虽然<code>Filter</code>也可以生成响应，与<code>Servlet</code>类似，但实际上很少这样使用<code>Filter</code>。使用<code>Filter</code>的完整流程是：<code>Filter</code>对用户请求进行预处理，然后将其转发给<code>Servlet</code>进行处理和生成响应，最后<code>Filter</code>再对服务器响应进行后处理。</p><p>Filter有如下几个用处：</p><ul><li>在<code>HttpServletRequest</code>到达Servlet之前拦截客户端的<code>HttpServletRequest</code></li><li>检查<code>HttpServletRequest</code>，并可能修改<code>HttpServletRequest</code>请求头和数据</li><li>在<code>HttpServletResponse</code>到达客户端之前，拦截<code>HttpServletResponse</code></li><li>检查<code>HttpServletResponse</code>，也可以修改<code>HttpServletResponse</code>请求头和数据</li></ul><p>Filter有如下几个常见用法：</p><ul><li>用户授权的<code>Filter</code>：<code>Filter</code>负责检查用户请求，根据请求过滤用户非法请求。</li><li>日志<code>Filter</code>：详细记录某些特殊的用户请求。</li><li>负责解码的<code>Filter</code>:包括对非标准编码的请求解码。</li><li>能改变XML内容的<code>XSLT Filter</code>等。</li><li><code>Filter</code>可以负责拦截多个请求或响应；一个请求或响应也可以被多个<code>Filter</code>拦截。</li></ul><h3 id="Filter的配置"><a href="#Filter的配置" class="headerlink" title="Filter的配置"></a>Filter的配置</h3><p>过滤器的配置比较简单，直接实现<code>Filter</code> 接口即可，也可以通过<code>@WebFilter</code>注解实现对特定<code>URL</code>拦截，看到<code>Filter</code> 接口中定义了三个方法。</p><ul><li><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 <code>Filter</code> 的整个生命周期只会被调用一次。<strong>注意</strong>：这个方法必须执行成功，否则过滤器会不起作用。</li><li><code>doFilter()</code> ：容器中的每一次请求都会调用该方法， <code>FilterChain</code> 用来调用下一个过滤器 <code>Filter</code>。</li><li><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 <code>Filter</code> 的整个生命周期也只会被调用一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <br>      System.out.println(<span class="hljs-string">&quot;Filter 前置&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <br>      System.out.println(<span class="hljs-string">&quot;Filter 处理中&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <br>      System.out.println(<span class="hljs-string">&quot;Filter 后置&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Interceptor介绍"><a href="#Interceptor介绍" class="headerlink" title="Interceptor介绍"></a>Interceptor介绍</h3><p>拦截器<code>Interceptor</code>是一种在Web应用程序中经常使用的组件，它可以在请求到达<code>Controller</code>之前或之后对请求进行拦截和处理。它是基于AOP的思想，在Spring框架中被广泛应用</p><p>与Filter不同，拦截器是在框架级别上实现的，主要用于对请求进行横切关注点<em>cross-cutting concern</em>的处理，如身份验证、权限控制、日志记录、事务管理等。它可以在请求到达<code>Controller</code>之前或之后进行拦截、处理和转发，以实现特定的业务需求</p><p>拦截器在<code>Spring</code>框架中有多种使用方式，可以使用注解或 <code>XML</code> 配置进行定义。在 <em>Spring MVC</em> 中，可以通过实现<code>HandlerInterceptor</code>接口来自定义拦截器。拦截器可以在<code>Controller</code>方法执行之前或之后进行拦截，并可以在请求处理之前或之后进行一些额外的处理，例如：</p><ul><li>身份验证和授权：<code>Interceptor</code>可以拦截请求并检查用户的身份信息或权限信息，以确保只有授权用户才能访问相关资源</li><li>缓存和性能优化：<code>Interceptor</code>可以对请求进行缓存，避免重复的计算或数据查询，提高应用程序的性能</li><li>日志记录：<code>Interceptor</code>可以记录请求和响应的日志信息，用于监控和错误排查</li><li>异常处理：<code>Interceptor</code>可以拦截异常并进行处理，例如对异常进行统一的日志记录和返回错误信息</li><li>参数转换和校验：<code>Interceptor</code>可以对请求参数进行转换和校验，确保请求参数的正确性和合法性</li></ul><h3 id="Interceptor的配置"><a href="#Interceptor的配置" class="headerlink" title="Interceptor的配置"></a>Interceptor的配置</h3><p>拦截器它是链式调用，一个应用中可以同时存在多个拦截器 <code>Interceptor</code>， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行</p><p>首先编写一个简单的拦截器处理类，请求的拦截是通过<code>HandlerInterceptor</code> 来实现，看到<code>HandlerInterceptor</code> 接口中也定义了三个方法</p><ul><li><code>preHandle()</code> ：这个方法将在请求处理之前进行调用。<strong>注意</strong>：如果该方法的返回值为<code>false</code> ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行</li><li><code>postHandle()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 <strong>有意思的是</strong>：<code>postHandle()</code> 方法被调用的顺序跟 <code>preHandle()</code> 是相反的，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行</li><li><code>afterCompletion()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 前置&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 处理中&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Interceptor 后置&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将自定义好的拦截器处理类进行注册，并通过<code>addPathPatterns</code>、<code>excludePathPatterns</code>等属性设置需要拦截或需要排除的 <code>URL</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor1</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Filter与Interceptor的异同"><a href="#Filter与Interceptor的异同" class="headerlink" title="Filter与Interceptor的异同"></a>Filter与Interceptor的异同</h3><p><code>Filter</code>和<code>Interceptor</code>的相同点在于它们都是在Web应用程序中用于拦截和处理请求和响应的组件。它们都可以用于实现横切关注点的处理，如身份验证、日志记录、性能监控等</p><p>虽然Filter和Interceptor在实现和应用上有一些差异，例如Filter是在Servlet容器层面上实现的，而Interceptor是在应用程序框架层面上实现的，但它们的目的都是为了对请求和响应进行拦截和处理，以实现某些特定的业务需求</p><h4 id="实现原理不同"><a href="#实现原理不同" class="headerlink" title="实现原理不同"></a>实现原理不同</h4><ul><li><code>Filter</code>是基于函数回调实现的：</li></ul><p>每个自定义过滤器都会实现一个<code>doFilter()</code>方法，这个方法有一个关键参数<code>FilterChain</code>。它是一个回调接口，<code>ApplicationFilterChain</code> 是它的具体实现类，该类内部也有一个<code>doFilter()</code>方法，这个方法就是回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ApplicationFilterChain</code> 里面能拿到我们自定义的<code>xxxFilter</code>类，在其内部回调方法<code>doFilter()</code>里调用各个自定义<code>xxxFilter</code>过滤器，并执行 <code>doFilter()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> &#123;<br>        ...<span class="hljs-comment">//省略</span><br>        internalDoFilter(request,response);<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internalDoFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>&#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>            <span class="hljs-comment">//获取第pos个filter    </span><br>            <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];        <br>            <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>            ...<br>            filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而每个<code>xxxFilter</code> 会先执行自身的 <code>doFilter()</code> 过滤逻辑，最后在执行结束前会执行<code>filterChain.doFilter(servletRequest, servletResponse)</code>，也就是回调<code>ApplicationFilterChain</code>的<code>doFilter()</code> 方法，以此循环执行实现函数回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>filterChain.doFilter(servletRequest, servletResponse);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Interceptor</code> 是基于反射实现的</li></ul><p>自定义过滤器可以直接继承 <code>HandlerInterceptor</code> 这个接口 (<code>HandlerInterceptorAdapter</code>这个抽象类已经在<em>springmvc</em> <em>5.3</em>被废弃)，实现其中任意三个方法 <code>preHandle()</code>， <code>postHandle()</code> 和 <code>afterCompletion()</code>，再使用 <code>addInterceptors()</code> 方法将 <em>interceptor bean</em> 注册到 <code>registry</code> 的 <code>List&lt;interceptor&gt;</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorRegistry</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;InterceptorRegistration&gt; registrations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> InterceptorRegistration <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">(HandlerInterceptor interceptor)</span> &#123;<br>        <span class="hljs-type">InterceptorRegistration</span> <span class="hljs-variable">registration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorRegistration</span>(interceptor);<br>        <span class="hljs-built_in">this</span>.registrations.add(registration);<br>        <span class="hljs-keyword">return</span> registration;<br>    &#125;<br>  ...<span class="hljs-comment">//省略其余代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>WebMvcConfigurationSupport</code> 中创建 <code>RequestMappingHandlerMapping</code> 时将自定义的 <code>interceptor</code> 加入到拦截器列表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RequestMappingHandlerMapping <span class="hljs-title function_">requestMappingHandlerMapping</span><span class="hljs-params">(...)</span> &#123;<br><br><span class="hljs-type">RequestMappingHandlerMapping</span> <span class="hljs-variable">mapping</span> <span class="hljs-operator">=</span> createRequestMappingHandlerMapping();<br>mapping.setOrder(<span class="hljs-number">0</span>);<br>mapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));<br><br>   ...<span class="hljs-comment">//省略</span><br><span class="hljs-keyword">return</span> mapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器的使用是在 <code>DispatcherServlet</code> 中的 <code>doDispatch()</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    processedRequest = checkMultipart(request);<br>    multipartRequestParsed = (processedRequest != request);<br><br>    <span class="hljs-comment">// Determine handler for the current request.</span><br>    <span class="hljs-comment">// 拿到请求处理器，里面有拦截器的数组HandlerInterceptor[]</span><br>    <span class="hljs-comment">// 根据当前请求，找到可以处理请求的handler以及handler的所有拦截器作为HandlerExecutionChain返回</span><br>    mappedHandler = getHandler(processedRequest);<br>    <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>        noHandlerFound(processedRequest, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Determine handler adapter for the current request.</span><br>    <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br><br>    ...<span class="hljs-comment">// 省略</span><br><br>    <span class="hljs-comment">// 目标方法执行之前，会执行该方法</span><br>    <span class="hljs-comment">// 遍历所有拦截器，执行拦截器的preHandle方法</span><br>    <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Actually invoke the handler.</span><br>    <span class="hljs-comment">// 执行目标方法</span><br>    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>...<span class="hljs-comment">// 省略</span><br><br>    <span class="hljs-comment">// 倒叙执行所有拦截器的postHandle方法</span><br>    mappedHandler.applyPostHandle(processedRequest, response, mv);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以这里是先调用<code>PreHandle</code>，如果返回了<code>false</code>，则不会执行<code>PostHandle</code>，而<code>afterCompletion</code>的调用这是在<code>catch</code>里和 <code>processDispatchResult</code> 里，先看看 <code>PreHandle</code> 里面的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.interceptorList.size(); i++) &#123;<br><span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptorList.get(i);<br><span class="hljs-keyword">if</span> (!interceptor.preHandle(request, response, <span class="hljs-built_in">this</span>.handler)) &#123;<br>triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">this</span>.interceptorIndex = i;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在有任何一个 <code>preHandle</code> 返回 <code>false</code> 的时候就会触发 <code>triggerAfterCompletion</code> 代码，<code>triggerAfterCompletion</code> 里的代码的for循环 是从 <code>interceptorIndex</code> 开始递减的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">triggerAfterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, <span class="hljs-meta">@Nullable</span> Exception ex)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptorIndex; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptorList.get(i);<br><span class="hljs-keyword">try</span> &#123;<br>interceptor.afterCompletion(request, response, <span class="hljs-built_in">this</span>.handler, ex);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex2) &#123;<br>logger.error(<span class="hljs-string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以执行拦截器的 <code>preHandle</code> 方法的顺序是先来顺序执行所有拦截器的 <code>preHandle</code> 方法</p><ul><li>如果当前拦截器 <code>prehandler</code> 返回为 <code>true</code> ，则执行下一个拦截器的 <code>preHandle</code> 方法</li><li>如果当前拦截器返回为 <code>false</code> ，直接倒序执行所有已经执行了的拦截器的 <code>afterCompletion</code> 方法。</li></ul><p>如果任何一个拦截器返回<code>false</code>。直接跳出不执行目标方法。</p><p>执行拦截器的 <code>postHandle</code> 方法，是倒叙执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, <span class="hljs-meta">@Nullable</span> ModelAndView mv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptorList.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptorList.get(i);<br>interceptor.postHandle(request, response, <span class="hljs-built_in">this</span>.handler, mv);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面成功渲染完成后执行 <code>processDispatchResult()</code>，其中还会倒叙触发 <code>triggerAfterCompletion()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,<span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv,<span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>...<span class="hljs-comment">// 省略</span><br><br><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// Exception (if any) is already handled..</span><br>mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>根据当前请求，找到 <code>HandlerExecutionChain</code> (可以处理请求的<code>handler</code>以及<code>handler</code>的所有拦截器)</li><li>先来顺序执行所有拦截器的 <code>preHandle</code>方法<ol><li>如果当前拦截器 <code>prehandle</code> 返回为 <code>true</code>，则执行下一个拦截器的 <code>preHandle</code></li><li>如果当前拦截器返回为 <code>false</code>，直接倒序执行所有已经执行了的拦截器的 <code>afterCompletion</code></li></ol></li><li>如果任何一个拦截器返回 <code>false</code>，直接跳出不执行目标方法</li><li>所有拦截器都返回 <code>true</code>，则继续执行目标方法</li><li>目标方法执行完成之后，倒序执行所有拦截器的 <code>postHandle</code> 方法</li><li>前面的步骤有任何异常都会直接倒序触发 <code>afterCompletion</code></li><li>页面成功渲染完成以后，也会倒序触发 <code>afterCompletion</code></li></ol><h4 id="使用范围不同"><a href="#使用范围不同" class="headerlink" title="使用范围不同"></a>使用范围不同</h4><p>过滤器(<code>Filter</code>) 实现的是 <code>javax.servlet.Filter</code> 接口，而这个接口是在<code>Servlet</code>规范中定义的，也就是说过滤器<code>Filter</code> 的使用要依赖于<code>Tomcat</code>等容器，导致它只能在<code>web</code>程序中使用</p><p>而拦截器(<code>Interceptor</code>) 它是一个<code>Spring</code>组件，并由<code>Spring</code>容器管理，并不依赖<code>Tomcat</code>等容器，是可以单独使用的。不仅能应用在<code>web</code>程序中，也可以用于<code>Application</code>、<code>Swing</code>等程序中</p><h4 id="触发时机不同"><a href="#触发时机不同" class="headerlink" title="触发时机不同"></a>触发时机不同</h4><p><img src="/posts/41603/filter-chain.png" alt="filter &amp; interceptor"></p><p>过滤器<code>Filter</code>是在请求进入容器后，但在进入<code>servlet</code>之前进行预处理，请求结束是在<code>servlet</code>处理完以后；拦截器 <code>Interceptor</code> 是在请求进入<code>servlet</code>后，在进入<code>Controller</code>之前进行预处理的，<code>Controller</code> 中渲染了对应的视图之后请求结束</p><h4 id="拦截范围不同"><a href="#拦截范围不同" class="headerlink" title="拦截范围不同"></a>拦截范围不同</h4><p>过滤器 <code>Filter</code> 几乎可以拦截所有进入容器的请求</p><p>拦截器 <code>Interceptor</code> 只会对 <code>Controller</code> 请求或访问static目录下的静态资源请求起作用</p><h4 id="初始化时机不同"><a href="#初始化时机不同" class="headerlink" title="初始化时机不同"></a>初始化时机不同</h4><p>过滤器 <code>Filter</code> 是随着 Tomcat 等 web 容器启动时而进行初始化</p><p>拦截器 <code>Interceptor</code> 时随着 spring 启动而进行初始化</p><p>在实际的业务场景中，当使用到过滤器或拦截器时，难免会引入一些依赖的service服务。下面就通过例子进行简要说明：</p><p><strong><code>Filter</code> 中注入<code>service</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> TestService testService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>System.out.println(<span class="hljs-string">&quot;Filter 处理中&quot;</span>);<br>testService.a();<br>filterChain.doFilter(servletRequest, servletResponse);<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong><code>Interceptor</code> 中注入<code>service</code></strong></p><p>直接采用注解 <code>@Autowired</code>，但是在将拦截器注入到 <code>spring</code> 容器中时，不能自己通过 <code>new</code> 来进行创建。需要将拦截器当做一个普通的 <code>bean</code> 注入到spring容器中</p><p>这是因为加载顺序导致的问题，<code>interceptor </code>加载的时间点在 <code>springcontext</code> 之前，而 <code>Bean </code>又是由 <code>spring</code> 进行管理，所以 <code>interceptor</code> 中的 <code>service</code> 还是 <code>Null</code></p><p>解决方法在注册拦截器之前，先将<code>Interceptor</code> 手动进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyInterceptor <span class="hljs-title function_">getMyInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(getMyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="控制执行顺序不同"><a href="#控制执行顺序不同" class="headerlink" title="控制执行顺序不同"></a>控制执行顺序不同</h4><p>实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，不过，有时我们希望某个过滤器或拦截器能优先执行，就涉及到它们的执行顺序</p><p><code>Filter</code> 用<code>@Order</code>注解控制执行顺序，通过<code>@Order</code>控制过滤器的级别，值越小级别越高越先执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br></code></pre></td></tr></table></figure><p><code>Interceptor</code> 默认的执行顺序，就是它的注册顺序，也可以通过<code>Order</code>手动设置控制，值越小越先执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor2</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">2</span>);<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor1</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">1</span>);<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>看到输出结果发现，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法会后执行</p><p><code>postHandle()</code> 方法被调用的顺序跟 <code>preHandle()</code> 是相反的，这点在<a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C">实现原理不同</a>中也有解释，<code>postHandle()</code>是根据 <code>preHandle() </code>的顺序倒叙执行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">Interceptor1 前置<br>Interceptor2 前置<br>Interceptor 前置<br>我是controller<br>Interceptor 处理中<br>Interceptor2 处理中<br>Interceptor1 处理中<br>Interceptor 后置<br>Interceptor2 后置<br>Interceptor1 后置<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>filter</tag>
      
      <tag>interceptor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程（三）</title>
    <link href="/posts/60838.html"/>
    <url>/posts/60838.html</url>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><p>使用线程池主要有以下三个原因：</p><ol><li>创建&#x2F;销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</li><li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li><li><strong>可以对线程做统一管理</strong>。</li></ol><h4 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h4><p>Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。</p><p>我们先看看<code>ThreadPoolExecutor</code>类。</p><h5 id="ThreadPoolExecutor提供的构造方法"><a href="#ThreadPoolExecutor提供的构造方法" class="headerlink" title="ThreadPoolExecutor提供的构造方法"></a>ThreadPoolExecutor提供的构造方法</h5><p>一共有四个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 五个参数的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><br><span class="hljs-comment">// 六个参数的构造函数-1</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory)</span><br><br><span class="hljs-comment">// 六个参数的构造函数-2</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br><br><span class="hljs-comment">// 七个参数的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p><ul><li><p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote></li><li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote></li><li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p></blockquote></li><li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p></li></ul><p>TimeUnit是一个枚举类型 ，包括以下属性：</p><blockquote><p>NANOSECONDS ： 1微毫秒 &#x3D; 1微秒 &#x2F; 1000 MICROSECONDS ： 1微秒 &#x3D; 1毫秒 &#x2F; 1000 MILLISECONDS ： 1毫秒 &#x3D; 1秒 &#x2F;1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</p></blockquote><ul><li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p><p>常用的几个阻塞队列：</p><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p></li><li><p><strong>ArrayBlockingQueue</strong></p><p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p></li><li><p><strong>SynchronousQueue</strong></p><p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p></li><li><p><strong>DelayQueue</strong></p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p></li></ol></li></ul><blockquote><p>我们将在下一章中重点介绍各种阻塞队列</p></blockquote><p>好了，介绍完5个必须的参数之后，还有两个非必须的参数。</p><ul><li><p><strong>ThreadFactory threadFactory</strong></p><p>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-comment">// 省略属性</span><br>    <span class="hljs-comment">// 构造函数</span><br>    DefaultThreadFactory() &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>        Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>            poolNumber.getAndIncrement() +<br>            <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>RejectedExecutionHandler handler</strong></p><p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol></li></ul><h5 id="ThreadPoolExecutor的策略"><a href="#ThreadPoolExecutor的策略" class="headerlink" title="ThreadPoolExecutor的策略"></a>ThreadPoolExecutor的策略</h5><p>线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。</p><p>故线程池也有自己的状态。<code>ThreadPoolExecutor</code>类中使用了一些<code>final int</code>常量变量来表示线程池的状态 ，分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><ul><li><p>线程池创建后处于<strong>RUNNING</strong>状态。</p></li><li><p>调用shutdown()方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker,不会等待阻塞队列的任务完成。</p></li><li><p>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0。</p></li><li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()函数。</p><blockquote><p>ThreadPoolExecutor中有一个控制状态的属性叫<code>ctl</code>，它是一个AtomicInteger类型的变量。线程池状态就是通过AtomicInteger类型的成员变量<code>ctl</code>来获取的。</p><p>获取的<code>ctl</code>值传入<code>runStateOf</code>方法，与<code>~CAPACITY</code>位与运算(<code>CAPACITY</code>是低29位全1的int变量)。</p><p><code>~CAPACITY</code>在这里相当于掩码，用来获取ctl的高3位，表示线程池状态；而另外的低29位用于表示工作线程数</p></blockquote></li><li><p>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</p></li></ul><h5 id="线程池主要的任务处理流程"><a href="#线程池主要的任务处理流程" class="headerlink" title="线程池主要的任务处理流程"></a>线程池主要的任务处理流程</h5><p>处理任务的核心方法是<code>execute</code>，我们看看 JDK 1.8 源码中<code>ThreadPoolExecutor</code>是如何处理线程任务的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 1.8 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();   <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>       <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>           <span class="hljs-keyword">return</span>;<br>       c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>            <span class="hljs-comment">// 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br>    <span class="hljs-comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>         reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p><p><strong>为什么要二次检查线程池的状态?</strong></p><p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p><p><strong>总结一下处理流程</strong></p><ol><li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li><li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li><li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li><li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><p>整个过程如图所示：</p><p><img src="/posts/60838/threadpool.png" alt="img"></p><h5 id="ThreadPoolExecutor如何做到线程复用的？"><a href="#ThreadPoolExecutor如何做到线程复用的？" class="headerlink" title="ThreadPoolExecutor如何做到线程复用的？"></a>ThreadPoolExecutor如何做到线程复用的？</h5><p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。<strong>那么，线程池如何做到线程复用呢？</strong></p><p>原来，ThreadPoolExecutor在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。话不多说，我们继续看看源码（一定要仔细看，前后有联系）</p><p>这里的<code>addWorker</code>方法是在上面提到的<code>execute</code>方法里面调用的，先看看上半部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor.addWorker方法源码上半部分</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程</span><br>                <span class="hljs-comment">// 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数</span><br>                <span class="hljs-comment">// 如果不小于，则返回false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上半部分主要是判断线程数量是否超出阈值，超过了就返回false。我们继续看下半部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ThreadPoolExecutor.addWorker方法源码下半部分</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个worker对象</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 2.实例化一个Thread对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 3.线程池全局锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 4.启动这个线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后启动这个线程对象。</p><p>我们接着看看<code>Worker</code>类，仅展示部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker类部分源码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">final</span> Thread thread;<br>    Runnable firstTask;<br><br>    Worker(Runnable firstTask) &#123;<br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其余代码略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Worker</code>类实现了<code>Runnable</code>接口，所以<code>Worker</code>也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故<code>addWorker</code>方法调用addWorker方法源码下半部分中的第4步<code>t.start</code>，会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</p><p>我们再看看<code>runWorker</code>的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker.runWorker方法源代码</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 1.线程启动之后，通过unlock方法释放锁</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span><br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 2.3执行beforeExecute </span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 2.4执行任务</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 2.5执行afterExecute方法 </span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                <span class="hljs-comment">// 2.6解锁操作</span><br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</p><p>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</p><p>最后看看<code>getTask</code>方法的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker.getTask方法源码</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-comment">// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span><br>        <span class="hljs-comment">// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 2.如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span><br>　　　　 <span class="hljs-comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span><br>        <span class="hljs-comment">// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span><br>            <span class="hljs-comment">// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span><br>            <span class="hljs-comment">// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span><br>            <span class="hljs-comment">// 如果timed为false（allowCoreThreadTimeOut为false</span><br>            <span class="hljs-comment">// 且wc &gt; corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span><br>            <span class="hljs-comment">// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong>allowCoreThreadTimeOut</strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</p><p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断<strong>compareAndDecrementWorkerCount</strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</p><p>源码解析完毕，你理解的源码是否和图中的处理流程一致？如果不一致，那么就多看两遍吧，加油。</p><h4 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h4><p><code>Executors</code>类中提供的几个静态方法来创建线程池。大家到了这一步，如果看懂了前面讲的<code>ThreadPoolExecutor</code>构造方法中各种参数的意义，那么一看到<code>Executors</code>类中提供的线程池的源码就应该知道这个线程池是干嘛的。</p><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p><ol><li>提交任务进线程池。</li><li>因为<strong>corePoolSize</strong>为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。</li><li>尝试将任务添加到<strong>SynchronousQueue</strong>队列。</li><li>如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</li><li>如果SynchronousQueue已有任务在等待，入列操作将会阻塞。</li></ol><p>当需要执行很多<strong>短时间</strong>的任务时，CacheThreadPool的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。</p><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p><p><strong>与CachedThreadPool的区别</strong>：</p><ul><li>因为 corePoolSize &#x3D;&#x3D; maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize&#x3D;0，所以只会创建非核心线程。</li><li>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。</li><li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li><li>都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li></ul><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>有且仅有一个核心线程（ corePoolSize &#x3D;&#x3D; maximumPoolSize&#x3D;1），使用了LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p><h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>创建一个定长线程池，支持定时及周期性任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><br><span class="hljs-comment">//ScheduledThreadPoolExecutor():</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>四种常见的线程池基本够我们使用了，但是《阿里巴巴开发手册》不建议我们直接使用Executors类中的线程池，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>但如果你及团队本身对线程池非常熟悉，又确定业务规模不会大到资源耗尽的程度（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h4><p>我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p><p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p><p>我们自己coding实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。（这块不明白的同学，可以看最下方结语部分的链接）</p><p>这么容易出错的事情，JDK当然帮我们做啦，这就是阻塞队列(BlockingQueue)，<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p><blockquote><p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p></blockquote><p>BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p><h4 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法"></a>BlockingQueue的操作方法</h4><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th align="center">方法\处理方式</th><th align="center">抛出异常</th><th align="center">返回特殊值</th><th align="center">一直阻塞</th><th align="center">超时退出</th></tr></thead><tbody><tr><td align="center">插入方法</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center"><strong>put(e)</strong></td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除方法</td><td align="center">remove()</td><td align="center">poll()</td><td align="center"><strong>take()</strong></td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查方法</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><ul><li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true &#x2F; false。</li><li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li><li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true &#x2F; false。</li></ul><p><strong>注意之处</strong></p><ul><li>不能往阻塞队列中插入null,会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><h4 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h5><p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，故具有数组的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span>&#123;<br>    <span class="hljs-comment">//..省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.Delayed</span> 接口。 <br><br>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 <br></code></pre></td></tr></table></figure><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是非公平锁。<br></code></pre></td></tr></table></figure><blockquote><p>网上大部分博客上<strong>PriorityBlockingQueue</strong>为公平锁，其实是不对的，查阅源码（感谢github:<strong>ambition0802</strong>同学的指出）：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                                  Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;<br>         <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">//默认构造方法-非公平锁</span><br>         ...<span class="hljs-comment">//其余代码略</span><br>     &#125;<br></code></pre></td></tr></table></figure><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p><p>以下方法的返回值，可以帮助理解这个队列：</p><ul><li>iterator() 永远返回空，因为里面没有东西</li><li>peek() 永远返回null</li><li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li><li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li><li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li><li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li><li>isEmpty() 永远返回true</li><li>remove()&amp;removeAll() 永远返回false</li></ul><p><strong>注意</strong></p><p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong>对于使用默认大小的<strong>LinkedBlockingQueue</strong>也是一样的。</p><h4 id="阻塞队列的原理"><a href="#阻塞队列的原理" class="headerlink" title="阻塞队列的原理"></a>阻塞队列的原理</h4><p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p><p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据元素数组</span><br><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-comment">//下一个待取出元素索引</span><br><span class="hljs-type">int</span> takeIndex;<br><span class="hljs-comment">//下一个待添加元素索引</span><br><span class="hljs-type">int</span> putIndex;<br><span class="hljs-comment">//元素个数</span><br><span class="hljs-type">int</span> count;<br><span class="hljs-comment">//内部锁</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-comment">//消费者监视器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-comment">//生产者监视器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-comment">//..省略其他代码</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>put操作的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 1.自旋拿锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2.判断队列是否满了</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            <span class="hljs-comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span><br>            <span class="hljs-comment">// 等待notFull的唤醒，唤醒之后继续执行while循环。</span><br>            notFull.await();<br>        <span class="hljs-comment">// 3.如果没有满，则进入队列</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[putIndex] == null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    <span class="hljs-comment">// 4 唤醒一个等待的线程</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结put的流程：</p><ol><li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li><li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</li><li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li><li>唤醒一个标记为notEmpty（消费者）的线程。</li></ol><p><strong>take操作的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p><ol><li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li><li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</li><li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li><li>唤醒一个标记为notFull（生产者）的线程。</li></ol><p><strong>注意</strong></p><ol><li>put和take操作都需要<strong>先获取锁</strong>，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</li><li>就算拿到锁了之后，也<strong>不一定</strong>会顺利进行put&#x2F;take操作，需要判断<strong>队列是否可用</strong>（是否满&#x2F;空），如果不可用，则会被阻塞，<strong>并释放锁</strong>。</li><li>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，<strong>依然需要拿到锁</strong>才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。</li></ol><h4 id="示例和使用场景"><a href="#示例和使用场景" class="headerlink" title="示例和使用场景"></a>示例和使用场景</h4><h5 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(queueSize);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>();<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            consume();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;从队列取走一个元素，队列剩余&quot;</span>+queue.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            produce();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.put(<span class="hljs-number">1</span>);<br>                    System.out.println(<span class="hljs-string">&quot;向队列取中插入一个元素，队列剩余空间：&quot;</span>+(queueSize-queue.size()));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是这个例子的输出片段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">从队列取走一个元素，队列剩余0个元素<br>从队列取走一个元素，队列剩余0个元素<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：8<br>向队列取中插入一个元素，队列剩余空间：7<br>向队列取中插入一个元素，队列剩余空间：6<br>向队列取中插入一个元素，队列剩余空间：5<br>向队列取中插入一个元素，队列剩余空间：4<br>向队列取中插入一个元素，队列剩余空间：3<br>向队列取中插入一个元素，队列剩余空间：2<br>向队列取中插入一个元素，队列剩余空间：1<br>向队列取中插入一个元素，队列剩余空间：0<br>从队列取走一个元素，队列剩余1个元素<br>从队列取走一个元素，队列剩余9个元素<br></code></pre></td></tr></table></figure><p>注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于<strong>put操作和System.out.println语句这两个操作没有上锁</strong>。考虑到这样的情况：线程1在执行完put&#x2F;take操作后立即失去CPU时间片，然后切换到线程2执行put&#x2F;take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put&#x2F;take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。</p><h5 id="线程池中使用阻塞队列"><a href="#线程池中使用阻塞队列" class="headerlink" title="线程池中使用阻塞队列"></a>线程池中使用阻塞队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                           TimeUnit unit,</span><br><span class="hljs-params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>             Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java中的线程池就是使用阻塞队列实现的，我们在了解阻塞队列之后，无论是使用Executors类中已经提供的线程池，还是自己通过ThreadPoolExecutor实现线程池，都会更加得心应手，想要了解线程池的同学，可以看<a href="http://concurrent.redspider.group/article/03/12.html">第十二章</a>：线程池原理。</p><blockquote><p>注：上面提到了生产者-消费者模式，大家可以参考<a href="http://note.youdao.com/noteshare?id=b4babef5d090f87cea8a97632f380c00">生产者-消费者模型</a>，可以更好的理解阻塞队列。</p></blockquote><h3 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h3><p>前面我们介绍了Java原生的锁——基于对象的锁，它一般是配合synchronized关键字来使用的。实际上，Java在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。</p><h4 id="synchronized-的不足之处"><a href="#synchronized-的不足之处" class="headerlink" title="synchronized 的不足之处"></a>synchronized 的不足之处</h4><p>我们先来看看<code>synchronized</code>有什么不足之处。</p><ul><li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li><li>synchronized无法知道线程有没有成功获取到锁</li><li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li></ul><p>而这些都是locks包下的锁可以解决的。</p><h4 id="锁的几种分类"><a href="#锁的几种分类" class="headerlink" title="锁的几种分类"></a>锁的几种分类</h4><p>锁可以根据以下几种方式来进行分类，下面我们逐一介绍。</p><h5 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h5><p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p><p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p><p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p><p><code>ReentrantLock</code>的中文意思就是可重入锁。也是本文后续要介绍的重点类。</p><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p><p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p><p>ReentrantLock支持非公平锁和公平锁两种。</p><h5 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h5><p>我们前面讲到的synchronized用的锁和ReentrantLock，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。</p><p>而读写锁可以在同一时刻允许多个读线程访问。Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p><blockquote><p>注意，即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。</p></blockquote><p><strong>可见，只是synchronized是远远不能满足多样化的业务对锁的要求的</strong>。接下来我们介绍一下JDK中有关锁的一些接口和类。</p><h4 id="JDK中有关锁的一些接口和类"><a href="#JDK中有关锁的一些接口和类" class="headerlink" title="JDK中有关锁的一些接口和类"></a>JDK中有关锁的一些接口和类</h4><p>众所周知，JDK中关于并发的类大多都在<code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包看名字就知道，是提供了一些并发锁的工具类的。前面我们介绍的AQS（AbstractQueuedSynchronizer）就是在这个包下。下面分别介绍一下这个包下的类和接口以及它们之间的关系。</p><h5 id="抽象类AQS-AQLS-AOS"><a href="#抽象类AQS-AQLS-AOS" class="headerlink" title="抽象类AQS&#x2F;AQLS&#x2F;AOS"></a>抽象类AQS&#x2F;AQLS&#x2F;AOS</h5><p>这三个抽象类有一定的关系，所以这里放到一起讲。</p><p>首先我们看<strong>AQS</strong>（AbstractQueuedSynchronizer），之前专门有章节介绍这个类，它是在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围，所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型。</p><p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。从源码类上的注释可以知道，它是用于表示锁与持有者之间的关系（独占模式）。可以看一下它的主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 独占模式，锁的持有者  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;  <br><br><span class="hljs-comment">// 设置锁持有者  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread t)</span> &#123;  <br>    exclusiveOwnerThread = t;  <br>&#125;  <br><br><span class="hljs-comment">// 获取锁的持有线程  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> exclusiveOwnerThread;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接口Condition-Lock-ReadWriteLock"><a href="#接口Condition-Lock-ReadWriteLock" class="headerlink" title="接口Condition&#x2F;Lock&#x2F;ReadWriteLock"></a>接口Condition&#x2F;Lock&#x2F;ReadWriteLock</h5><p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lock接口中有一个方法是可以获得一个<code>Condition</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>之前我们提到了每个对象都可以用继承自<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待&#x2F;通知模式。</p><p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p><table><thead><tr><th>对比项</th><th>Object监视器</th><th>Condition</th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象的锁</td><td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td></tr><tr><td>调用方式</td><td>直接调用，比如object.notify()</td><td>直接调用，比如condition.await()</td></tr><tr><td>等待队列的个数</td><td>一个</td><td>多个</td></tr><tr><td>当前线程释放锁进入等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁进入等待状态，在等待状态中不中断</td><td>不支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入超时等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待状态直到将来的某个时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的一个线程</td><td>支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的全部线程</td><td>支持</td><td>支持</td></tr></tbody></table><p>Condition和Object的wait&#x2F;notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal&#x2F;signalAll</strong>方法则对应Object的notify&#x2F;notifyAll()。但Condition类似于Object的等待&#x2F;通知机制的加强版。我们来看看主要的方法：</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>await()</td><td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal&#x2F;signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td></tr><tr><td>awaitUninterruptibly()</td><td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td></tr><tr><td>awaitNanos(long)</td><td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td></tr><tr><td>awaitUntil(Date)</td><td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td></tr><tr><td>signal()</td><td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td></tr><tr><td>signalAll()</td><td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td></tr></tbody></table><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个”可重入“锁，从源码上看，它内部有一个抽象类<code>Sync</code>，是继承了AQS，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类<code>NonfairSync</code>和<code>FairSync</code>，它们都继承了Sync。从名字上看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着ReentrantLock可以支持”公平锁“和”非公平锁“。</p><p>通过看这两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了AOS的<code>setExclusiveOwnerThread</code>方法，所以ReentrantLock的锁是”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p><p>在ReentrantLock的构造方法里，可以传入一个<code>boolean</code>类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过<code>isFair()</code>方法来查看。</p><h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p><p>ReentrantReadWriteLock内部的结构大概是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部结构</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<br><span class="hljs-keyword">final</span> Sync sync;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReadLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>            sync = lock.sync;<br>    &#125;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">WriteLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>            sync = lock.sync;<br>    &#125;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><br><span class="hljs-comment">// 构造方法，初始化两个锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 获取读锁和写锁的方法</span><br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> writerLock; &#125;<br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> readerLock; &#125;<br></code></pre></td></tr></table></figure><p>可以看到，它同样是内部维护了两个同步器。且维护了两个Lock的实现类ReadLock和WriteLock。从源码可以发现，这两个内部类用的是外部类的同步器。</p><p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”，将在后文的StampedLock类继续讨论这个问题。</p><h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p><code>StampedLock</code>类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p><p>前面提到了ReentrantReadWriteLock会发生“写饥饿”的现象，但StampedLock不会。它是怎么做到的呢？它的核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p><p>这里篇幅有限，就不介绍StampedLock的源码了，只是分析一下官方提供的用法（在JDK源码类声明的上方或Javadoc里可以找到）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>   <span class="hljs-comment">// 写锁的使用</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       x += deltaX;<br>       y += deltaY;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>     &#125;<br>   &#125;<br><br>   <span class="hljs-comment">// 乐观读锁的使用</span><br>   <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead(); <span class="hljs-comment">// 获取乐观读锁</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>     <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123; <span class="hljs-comment">// //检查乐观读锁后是否有其他写锁发生，有则返回false</span><br>        stamp = sl.readLock(); <span class="hljs-comment">// 获取一个悲观读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          currentX = x;<br>          currentY = y;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           sl.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>        &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>   &#125;<br><br>   <span class="hljs-comment">// 悲观读锁以及读锁升级写锁的使用</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveIfAtOrigin</span><span class="hljs-params">(<span class="hljs-type">double</span> newX, <span class="hljs-type">double</span> newY)</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.readLock(); <span class="hljs-comment">// 悲观读锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;<br>         <span class="hljs-comment">// 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用</span><br>         <span class="hljs-type">long</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> sl.tryConvertToWriteLock(stamp); <br><br>         <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0L</span>) &#123; <span class="hljs-comment">// 如果转换成功</span><br>           stamp = ws; <span class="hljs-comment">// 读锁的票据更新为写锁的</span><br>           x = newX;<br>           y = newY;<br>           <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果转换失败</span><br>           sl.unlockRead(stamp); <span class="hljs-comment">// 释放读锁</span><br>           stamp = sl.writeLock(); <span class="hljs-comment">// 强制获取写锁</span><br>         &#125;<br>       &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlock(stamp); <span class="hljs-comment">// 释放所有锁</span><br>     &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>乐观读锁的意思就是先假定在这个锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个悲观读锁，这里的悲观读锁和ReentrantReadWriteLock中的读锁类似，也是个共享锁。</p></blockquote><p>可以看到，StampedLock获取锁会返回一个<code>long</code>类型的变量，释放锁的时候再把这个变量传进去。简单看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于操作state后获取stamp的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LG_READERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RUNIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;               <span class="hljs-comment">//0000 0000 0001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">WBIT</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> &lt;&lt; LG_READERS; <span class="hljs-comment">//0000 1000 0000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RBITS</span> <span class="hljs-operator">=</span> WBIT - <span class="hljs-number">1L</span>;        <span class="hljs-comment">//0000 0111 1111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RFULL</span> <span class="hljs-operator">=</span> RBITS - <span class="hljs-number">1L</span>;       <span class="hljs-comment">//0000 0111 1110</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ABITS</span> <span class="hljs-operator">=</span> RBITS | WBIT;     <span class="hljs-comment">//0000 1111 1111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SBITS</span> <span class="hljs-operator">=</span> ~RBITS;           <span class="hljs-comment">//1111 1000 0000</span><br><br><span class="hljs-comment">// 初始化时state的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ORIGIN</span> <span class="hljs-operator">=</span> WBIT &lt;&lt; <span class="hljs-number">1</span>;       <span class="hljs-comment">//0001 0000 0000</span><br><br><span class="hljs-comment">// 锁共享变量state</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br><span class="hljs-comment">// 读锁溢出时用来存储多出的读锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> readerOverflow;<br></code></pre></td></tr></table></figure><p>StampedLock用这个long类型的变量的前7位（LG_READERS）来表示读锁，每获取一个悲观读锁，就加1（RUNIT），每释放一个悲观读锁，就减1。而悲观读锁最多只能装128个（7位限制），很容易溢出，所以用一个int类型的变量来存储溢出的悲观读锁。</p><p>写锁用state变量剩下的位来表示，每次获取一个写锁，就加0000 1000 0000（WBIT）。需要注意的是，<strong>写锁在释放的时候，并不是减WBIT，而是再加WBIT</strong>。这是为了<strong>让每次写锁都留下痕迹</strong>，解决CAS中的ABA问题，也为<strong>乐观锁检查变化</strong>validate方法提供基础。</p><p>乐观读锁就比较简单了，并没有真正改变state的值，而是在获取锁的时候记录state的写状态，在操作完成后去检查state的写状态部分是否发生变化，上文提到了，每次写锁都会留下痕迹，也是为了这里乐观锁检查变化提供方便。</p><p>总的来说，StampedLock的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用</p><h3 id="并发容器集合"><a href="#并发容器集合" class="headerlink" title="并发容器集合"></a>并发容器集合</h3><h4 id="同步容器与并发容器"><a href="#同步容器与并发容器" class="headerlink" title="同步容器与并发容器"></a>同步容器与并发容器</h4><p>我们知道在java.util包下提供了一些容器类，而Vector和Hashtable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p><p>而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVector</span> &#123;<br>    <span class="hljs-keyword">private</span> Vector&lt;String&gt; vector;<br><br>    <span class="hljs-comment">//方法一</span><br>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">getLast</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> vector.get(lastIndex);<br>    &#125;<br><br>    <span class="hljs-comment">//方法二</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLast</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>        vector.remove(lastIndex);<br>    &#125;<br><br>    <span class="hljs-comment">//方法三</span><br>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">getLastSysnchronized</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(vector)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> vector.get(lastIndex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//方法四</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLastSysnchronized</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (vector)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>            vector.remove(lastIndex);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法一和方法二为一个组合的话。那么当方法一获取到了<code>vector</code>的size之后，方法二已经执行完毕，这样就导致程序的错误。</p><p>如果方法三与方法四组合的话。通过锁机制保证了在<code>vector</code>上的操作的原子性。</p><p>并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。</p><h4 id="并发容器类介绍"><a href="#并发容器类介绍" class="headerlink" title="并发容器类介绍"></a>并发容器类介绍</h4><p>整体架构(列举常用的容器类)<img src="/posts/60838/1.png" alt="并发容器"></p><p>其中，阻塞队列（BlockingQueue）在<a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a>有介绍，CopyOnWrite容器（CopyOnWritexxx）在<a href="#CopyOnWrite">CopyOnWrite</a>有介绍，这里不做过多介绍。</p><p>下面分别介绍一些常用的并发容器类和接口，因篇幅原因，这里只介绍这些类的用途和基本的原理，不做过多的源码解析。</p><h4 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h4><h5 id="ConcurrentMap接口"><a href="#ConcurrentMap接口" class="headerlink" title="ConcurrentMap接口"></a>ConcurrentMap接口</h5><p>ConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">//插入元素</span><br>    V <span class="hljs-title function_">putIfAbsent</span><span class="hljs-params">(K key, V value)</span>;<br><br>    <span class="hljs-comment">//移除元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key, Object value)</span>;<br><br>    <span class="hljs-comment">//替换元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span>;<br><br>    <span class="hljs-comment">//替换元素</span><br>    V <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V value)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>putIfAbsent：</strong>与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；</p><p><strong>remove：</strong>与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;</p><p><strong>replace(K,V,V)：</strong>增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；</p><p><strong>replace(K,V)：</strong>与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；</p><h5 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h5><p>ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与Hashtable完全不同的加锁策略，提供更高效的并发性和伸缩性。</p><p>ConcurrentHashMap在JDK 1.7 和JDK 1.8中有一些区别。这里我们分开介绍一下。</p><p><strong>JDK 1.7</strong></p><p>ConcurrentHashMap在JDK 1.7中，提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。</p><p>提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。</p><p>可以这样理解分段锁，就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图：<img src="/posts/60838/2.png" alt="分段锁机制"></p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p><p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p><p><strong>JDK 1.8</strong></p><p>而在JDK 1.8中，ConcurrentHashMap主要做了两个优化：</p><ul><li>同HashMap一样，链表也会在长度达到8的时候转化为红黑树，这样可以提升大量冲突时候的查询效率；</li><li>以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合自旋+CAS避免不必要的锁开销，进一步提升并发性能。</li></ul><p>对ConcurrentHashMap源码感兴趣的朋友可以看看这两篇文章：</p><ul><li><a href="https://yasinshaw.com/articles/27">https://yasinshaw.com/articles/27</a></li><li><a href="https://yasinshaw.com/articles/30">https://yasinshaw.com/articles/30</a></li></ul><h5 id="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"><a href="#ConcurrentNavigableMap接口与ConcurrentSkipListMap类" class="headerlink" title="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"></a>ConcurrentNavigableMap接口与ConcurrentSkipListMap类</h5><p>ConcurrentNavigableMap接口继承了NavigableMap接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p><p>ConcurrentNavigableMap接口的主要实现类是ConcurrentSkipListMap类。从名字上来看，它的底层使用的是跳表（SkipList）的数据结构。关于跳表的数据结构这里不做太多介绍，它是一种”空间换时间“的数据结构，可以使用CAS来保证并发安全性。</p><h5 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h5><p>JDK并没有提供线程安全的List类，因为对List来说，<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的List</strong>。因为即使简单的读操作，拿contains() 这样一个操作来说，很难想到搜索的时候如何避免锁住整个list。</p><p>所以退一步，JDK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedQueue和ConcurrentLinkedDeque。因为队列相对于List来说，有更多的限制。这两个类是使用CAS来实现线程安全的。</p><h5 id="并发Set"><a href="#并发Set" class="headerlink" title="并发Set"></a>并发Set</h5><p>JDK提供了ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</p><p>谷歌的guava框架实现了一个线程安全的ConcurrentHashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; s = Sets.newConcurrentHashSet();<br></code></pre></td></tr></table></figure><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><h4 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h4><p>在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p><p>那什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p><p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p><p>这样做的好处在于，我们可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。我们着重给大家介绍一下CopyOnWriteArrayList。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p><strong>优点</strong>： CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。在Java中遍历线程非安全的List(如：ArrayList和 LinkedList)的时候，若中途有别的线程对List容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，则不会抛出异常。</p><p><strong>缺点</strong>： 第一个缺点是CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC因为没有使用Full GC）。比如这些对象占用的内存200M左右，那么再写入100M数据进去，内存就会多占用300M。</p><p>第二个缺点是CopyOnWriteArrayList由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。</p><p>现在我们来看一下CopyOnWriteArrayList的add操作源码，它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br><br>    <span class="hljs-comment">// ReentrantLock加锁，保证线程安全</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 拷贝原容器，长度为原容器长度加一</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 在新副本上执行添加操作</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// 将原容器引用指向新副本</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看一下remove操作的源码，remove的逻辑是将要remove元素之外的其他元素拷贝到新的副本中，然后再将原容器的引用指向新的副本中，因为remove操作也是“写操作”所以也是要加锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><br>        <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object[] elements = getArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(elements, index);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> len - index - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span><br>                setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将要删除元素之外的其他元素拷贝到新副本中，并切换引用</span><br>                Object[] newElements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[len - <span class="hljs-number">1</span>];<br>                System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>                System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                                 numMoved);<br>                setArray(newElements);<br>            &#125;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们再来看看CopyOnWriteArrayList效率最高的读操作的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br> <span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>     <span class="hljs-keyword">return</span> (E) a[index];<br> &#125;<br></code></pre></td></tr></table></figure><p>由上可见“读操作”是没有加锁，直接读取。</p><h4 id="CopyOnWrite的业务中实现"><a href="#CopyOnWrite的业务中实现" class="headerlink" title="CopyOnWrite的业务中实现"></a>CopyOnWrite的业务中实现</h4><p>接下来，我们结合具体业务场景来实现一个CopyOnWriteMap的并发容器并且使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnWriteMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt;, Cloneable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;K, V&gt; internalMap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteMap</span><span class="hljs-params">()</span> &#123;<br>        internalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            Map&lt;K, V&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;(internalMap);<br>            <span class="hljs-type">V</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> newMap.put(key, value);<br>            internalMap = newMap;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalMap.get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; newData)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            Map&lt;K, V&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;(internalMap);<br>            newMap.putAll(newData);<br>            internalMap = newMap;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面就是参考CopyOnWriteArrayList实现的CopyOnWriteMap，我们可以用这个容器来做什么呢？结合我们之前说的CopyOnWrite的复制思想，它最适用于“读多写少”的并发场景。</p><p><strong>场景：</strong>假如我们有一个搜索的网站需要屏蔽一些“关键字”，“黑名单”每晚定时更新，每当用户搜索的时候，“黑名单”中的关键字不会出现在搜索结果当中，并且提示用户敏感字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 黑名单服务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListServiceImpl</span> &#123;<br>    <span class="hljs-comment">//　减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteMap</span>&lt;String, Boolean&gt;(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlackList</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> blackListMap.get(id) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBlackList</span><span class="hljs-params">(String id)</span> &#123;<br>        blackListMap.put(id, Boolean.TRUE);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量添加黑名单</span><br><span class="hljs-comment">     * (使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</span><br><span class="hljs-comment">     * 如使用上面代码里的addBlackList方法)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBlackList</span><span class="hljs-params">(Map&lt;String,Boolean&gt; ids)</span> &#123;<br>        blackListMap.putAll(ids);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要各位小伙伴特别特别注意一个问题，此处的场景是每晚凌晨“黑名单”定时更新，原因是CopyOnWrite容器有<strong>数据一致性</strong>的问题，它只能保证<strong>最终数据一致性</strong>。</p><p>所以如果我们希望写入的数据马上能准确地读取，请不要使用CopyOnWrite容器</p><h3 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h3><p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p><p>它们都在java.util.concurrent包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</p><table><thead><tr><th>类</th><th>作用</th></tr></thead><tbody><tr><td>Semaphore</td><td>限制线程的数量</td></tr><tr><td>Exchanger</td><td>两个线程交换数据</td></tr><tr><td>CountDownLatch</td><td>线程等待直到计数器减为0时开始工作</td></tr><tr><td>CyclicBarrier</td><td>作用跟CountDownLatch类似，但是可以重复使用</td></tr><tr><td>Phaser</td><td>增强的CyclicBarrier</td></tr></tbody></table><p>下面分别介绍这几个类。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h5 id="Semaphore介绍"><a href="#Semaphore介绍" class="headerlink" title="Semaphore介绍"></a>Semaphore介绍</h5><p>Semaphore翻译过来是信号的意思。顾名思义，这个工具类提供的功能就是多个线程彼此“打信号”。而这个“信号”是一个<code>int</code>类型的数据，也可以看成是一种“资源”。</p><p>可以在构造函数中传入初始资源总数，以及是否使用“公平”的同步器。默认情况下，是非公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认情况下使用非公平</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。当然，你也可以申请多个acquire(int permits)或者释放多个release(int permits)。</p><p>每次acquire，permits就会减少一个或者多个。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p><h5 id="Semaphore案例"><a href="#Semaphore案例" class="headerlink" title="Semaphore案例"></a>Semaphore案例</h5><p>Semaphore往往用于资源有限的场景中，去限制线程的数量。举个例子，我想限制同时只能有3个线程在工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">private</span> Semaphore semaphore;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Semaphore semaphore)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.semaphore = semaphore;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire(); <span class="hljs-comment">// 获取permit</span><br>                System.out.println(String.format(<span class="hljs-string">&quot;当前线程是%d, 还剩%d个资源，还有%d个线程在等待&quot;</span>,<br>                        value, semaphore.availablePermits(), semaphore.getQueueLength()));<br>                <span class="hljs-comment">// 睡眠随机时间，打乱释放顺序</span><br>                <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                System.out.println(String.format(<span class="hljs-string">&quot;线程%d释放了资源&quot;</span>, value));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span>&#123;<br>                semaphore.release(); <span class="hljs-comment">// 释放permit</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(i, semaphore)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>当前线程是1, 还剩2个资源，还有0个线程在等待<br>当前线程是0, 还剩1个资源，还有0个线程在等待<br>当前线程是6, 还剩0个资源，还有0个线程在等待<br>线程6释放了资源<br>当前线程是2, 还剩0个资源，还有6个线程在等待<br>线程2释放了资源<br>当前线程是4, 还剩0个资源，还有5个线程在等待<br>线程0释放了资源<br>当前线程是7, 还剩0个资源，还有4个线程在等待<br>线程1释放了资源<br>当前线程是8, 还剩0个资源，还有3个线程在等待<br>线程7释放了资源<br>当前线程是5, 还剩0个资源，还有2个线程在等待<br>线程4释放了资源<br>当前线程是3, 还剩0个资源，还有1个线程在等待<br>线程8释放了资源<br>当前线程是9, 还剩0个资源，还有0个线程在等待<br>线程9释放了资源<br>线程5释放了资源<br>线程3释放了资源</p></blockquote><p>可以看到，在这次运行中，最开始是1, 0, 6这三个线程获得了资源，而其它线程进入了等待队列。然后当某个线程释放资源后，就会有等待队列中的线程获得资源。</p><p>当然，Semaphore默认的acquire方法是会让线程进入等待队列，且会抛出中断异常。但它还有一些方法可以忽略中断或不进入阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 忽略中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><br><span class="hljs-comment">// 不进入等待队列，底层使用CAS</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> tryAcquire<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><h5 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h5><p>Semaphore内部有一个继承了AQS的同步器Sync，重写了<code>tryAcquireShared</code>方法。在这个方法里，会去尝试获取资源。</p><p>如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</p><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。先来一个案例看看如何使用，比如两个线程之间想要传送字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是线程A，得到了另一个线程的数据：&quot;</span><br>                        + exchanger.exchange(<span class="hljs-string">&quot;这是来自线程A的数据&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;这个时候线程A是阻塞的，在等待线程B的数据&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是线程B，得到了另一个线程的数据：&quot;</span><br>                        + exchanger.exchange(<span class="hljs-string">&quot;这是来自线程B的数据&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>这个时候线程A是阻塞的，在等待线程B的数据<br>这是线程B，得到了另一个线程的数据：这是来自线程A的数据<br>这是线程A，得到了另一个线程的数据：这是来自线程B的数据</p></blockquote><p>可以看到，当一个线程调用exchange方法后，它是处于阻塞状态的，只有当另一个线程也调用了exchange方法，它才会继续向下执行。看源码可以发现它是使用park&#x2F;unpark来实现等待状态的切换的，但是在使用park&#x2F;unpark方法之前，使用了CAS检查，估计是为了提高性能。</p><p>Exchanger一般用于两个线程之间更方便地在内存中交换数据，因为其支持泛型，所以我们可以传输任何的数据，比如IO流或者IO缓存。根据JDK里面的注释的说法，可以总结为一下特性：</p><ul><li>此类提供对外的操作是同步的；</li><li>用于成对出现的线程之间交换数据；</li><li>可以视作双向的同步队列；</li><li>可应用于基因算法、流水线设计等场景。</li></ul><p>Exchanger类还有一个有超时参数的方法，如果在指定时间内没有另一个线程调用exchange，就会抛出一个超时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">exchange</span><span class="hljs-params">(V x, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p>那么问题来了，Exchanger只能是两个线程交换数据吗？那三个调用同一个实例的exchange方法会发生什么呢？答案是只有前两个线程会交换数据，第三个线程会进入阻塞状态。</p><p>需要注意的是，exchange是可以重复使用的。也就是说。两个线程可以使用Exchanger在内存中不断地再交换数据。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h5 id="CountDownLatch介绍"><a href="#CountDownLatch介绍" class="headerlink" title="CountDownLatch介绍"></a>CountDownLatch介绍</h5><p>先来解读一下CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p><p>CountDownLatch的方法也很简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-comment">// 等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-comment">// 超时等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> <span class="hljs-comment">// count - 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前还有多少count</span><br></code></pre></td></tr></table></figure><h5 id="CountDownLatch案例"><a href="#CountDownLatch案例" class="headerlink" title="CountDownLatch案例"></a>CountDownLatch案例</h5><p>我们知道，玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。下面我们就来模拟一下这个demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-comment">// 定义前置任务线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, CountDownLatch countDownLatch)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.countDownLatch = countDownLatch;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                System.out.println(task + <span class="hljs-string">&quot; - 任务完成&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 假设有三个模块需要加载</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 主任务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;等待数据加载...&quot;</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;还有%d个前置任务&quot;</span>, countDownLatch.getCount()));<br>                countDownLatch.await();<br>                System.out.println(<span class="hljs-string">&quot;数据加载完成，正式开始游戏！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 前置任务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, countDownLatch)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>等待数据加载…<br>还有3个前置任务<br>加载人物模型 - 任务完成<br>加载背景音乐 - 任务完成<br>加载地图数据 - 任务完成<br>数据加载完成，正式开始游戏！</p></blockquote><h5 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h5><p>其实CountDownLatch类的原理挺简单的，内部同样是一个继承了AQS的实现类Sync，且实现起来还很简单，可能是JDK里面AQS的子类中最简单的实现了，有兴趣的读者可以去看看这个内部类的源码。</p><p>需要注意的是构造器中的<strong>计数值（count）实际上就是闭锁需要等待的线程数量</strong>。这个值只能被设置一次，而且CountDownLatch<strong>没有提供任何机制去重新设置这个计数值</strong>。</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h5 id="CyclicBarrier介绍"><a href="#CyclicBarrier介绍" class="headerlink" title="CyclicBarrier介绍"></a>CyclicBarrier介绍</h5><p>CyclicBarrirer从名字上来理解是“循环的屏障”的意思。前面提到了CountDownLatch一旦计数值<code>count</code>被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用<code>reset()</code>方法重置屏障。</p><h5 id="CyclicBarrier-Barrier被破坏"><a href="#CyclicBarrier-Barrier被破坏" class="headerlink" title="CyclicBarrier Barrier被破坏"></a>CyclicBarrier Barrier被破坏</h5><p>如果参与者（线程）在等待的过程中，Barrier被破坏，就会抛出BrokenBarrierException。可以用<code>isBroken()</code>方法检测Barrier是否被破坏。</p><ol><li>如果有线程已经处于等待状态，调用reset方法会导致已经在等待的线程出现BrokenBarrierException异常。并且由于出现了BrokenBarrierException，将会导致始终无法等待。</li><li>如果在等待的过程中，线程被中断，会抛出InterruptedException异常，并且这个异常会传播到其他所有的线程。</li><li>如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，其他线程会抛出BrokenBarrierException，屏障被损坏。</li><li>如果超出指定的等待时间，当前线程会抛出 TimeoutException 异常，其他线程会抛出BrokenBarrierException异常。</li></ol><h5 id="CyclicBarrier案例"><a href="#CyclicBarrier案例" class="headerlink" title="CyclicBarrier案例"></a>CyclicBarrier案例</h5><p>我们同样用玩游戏的例子。如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, CyclicBarrier cyclicBarrier)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 假设总共三个关卡</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                    System.out.println(String.format(<span class="hljs-string">&quot;关卡%d的任务%s完成&quot;</span>, i, task));<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;本关卡所有前置任务完成，开始游戏...&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, cyclicBarrier)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, cyclicBarrier)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, cyclicBarrier)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>关卡1的任务加载地图数据完成<br>关卡1的任务加载背景音乐完成<br>关卡1的任务加载人物模型完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡2的任务加载地图数据完成<br>关卡2的任务加载背景音乐完成<br>关卡2的任务加载人物模型完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡3的任务加载人物模型完成<br>关卡3的任务加载地图数据完成<br>关卡3的任务加载背景音乐完成<br>本关卡所有前置任务完成，开始游戏…</p></blockquote><p>注意这里跟CountDownLatch的代码有一些不同。CyclicBarrier没有分为<code>await()</code>和<code>countDown()</code>，而是只有单独的一个<code>await()</code>方法。</p><p>一旦调用await()方法的线程数量等于构造方法中传入的任务总量（这里是3），就代表达到屏障了。CyclicBarrier允许我们在达到屏障的时候可以执行一个任务，可以在构造方法传入一个Runnable类型的对象。上述案例就是在达到屏障时，输出“本关卡所有前置任务完成，开始游戏…”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="CyclicBarrier原理"><a href="#CyclicBarrier原理" class="headerlink" title="CyclicBarrier原理"></a>CyclicBarrier原理</h5><p>CyclicBarrier虽说功能与CountDownLatch类似，但是实现原理却完全不同，CyclicBarrier内部使用的是Lock + Condition实现的等待&#x2F;通知模式。详情可以查看这个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br></code></pre></td></tr></table></figure><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><h5 id="Phaser介绍"><a href="#Phaser介绍" class="headerlink" title="Phaser介绍"></a>Phaser介绍</h5><p>Phaser这个单词是“移相器，相位器”的意思（好吧，笔者并不懂这是什么玩意，下方资料来自百度百科）。这个类是从JDK 1.7 中出现的。</p><blockquote><p>移相器（Phaser）能够对波的相位进行调整的一种装置。任何传输介质对在其中传导的波动都会引入相移，这是早期模拟移相器的原理；现代电子技术发展后利用A&#x2F;D、D&#x2F;A转换实现了数字移相，顾名思义，它是一种不连续的移相技术，但特点是移相精度高。 移相器在雷达、导弹姿态控制、加速器、通信、仪器仪表甚至于音乐等领域都有着广泛的应用</p></blockquote><p>Phaser类有点复杂，这里只介绍一些基本的用法和知识点。详情可以查看JDK文档，文档里有这个类非常详尽的介绍。</p><p>前面我们介绍了CyclicBarrier，可以发现它在构造方法里传入“任务总量”<code>parties</code>之后，就不能修改这个值了，并且每次调用<code>await()</code>方法也只能消耗一个<code>parties</code>计数。但Phaser可以动态地调整任务总量！</p><p>名词解释：</p><ul><li>party：对应一个线程，数量可以通过register或者构造参数传入;</li><li>arrive：对应一个party的状态，初始时是unarrived，当调用<code>arriveAndAwaitAdvance()</code>或者 <code>arriveAndDeregister()</code>进入arrive状态，可以通过<code>getUnarrivedParties()</code>获取当前未到达的数量;</li><li>register：注册一个party，每一阶段必须所有注册的party都到达才能进入下一阶段;</li><li>deRegister：减少一个party。</li><li>phase：阶段，当所有注册的party都arrive之后，将会调用Phaser的<code>onAdvance()</code>方法来判断是否要进入下一阶段。</li></ul><p>Phaser终止的两种途径，Phaser维护的线程执行完毕或者<code>onAdvance()</code>返回<code>true</code> 此外Phaser还能维护一个树状的层级关系，构造的时候new Phaser(parentPhaser)，对于Task执行时间短的场景（竞争激烈），也就是说有大量的<strong>party</strong>, 那可以把每个Phaser的任务量设置较小，多个Phaser共同继承一个父Phaser。</p><blockquote><p>Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent. This may greatly increase throughput even though it incurs greater per-operation overhead.</p><p>翻译：如果有大量的party，那许多线程可能同步的竞争成本比较高。所以可以拆分成多个子Phaser共享一个共同的父Phaser。这可能会大大增加吞吐量，即使它会带来更多的每次操作开销。</p></blockquote><h5 id="Phaser案例"><a href="#Phaser案例" class="headerlink" title="Phaser案例"></a>Phaser案例</h5><p>还是游戏的案例。假设我们游戏有三个关卡，但只有第一个关卡有新手教程，需要加载新手教程模块。但后面的第二个关卡和第三个关卡都不需要。我们可以用Phaser来做这个需求。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> Phaser phaser;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, Phaser phaser)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.phaser = phaser;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 第二次关卡起不加载NPC，跳过</span><br>                    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-string">&quot;加载新手教程&quot;</span>.equals(task)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                    System.out.println(String.format(<span class="hljs-string">&quot;关卡%d，需要加载%d个模块，当前模块【%s】&quot;</span>,<br>                            i, phaser.getRegisteredParties(), task));<br><br>                    <span class="hljs-comment">// 从第二个关卡起，不加载NPC</span><br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">&quot;加载新手教程&quot;</span>.equals(task)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;下次关卡移除加载【新手教程】模块&quot;</span>);<br>                        phaser.arriveAndDeregister(); <span class="hljs-comment">// 移除一个模块</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        phaser.arriveAndAwaitAdvance();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phaser</span> <span class="hljs-variable">phaser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phaser</span>(<span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onAdvance</span><span class="hljs-params">(<span class="hljs-type">int</span> phase, <span class="hljs-type">int</span> registeredParties)</span> &#123;<br>                System.out.println(String.format(<span class="hljs-string">&quot;第%d次关卡准备完成&quot;</span>, phase + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">return</span> phase == <span class="hljs-number">3</span> || registeredParties == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载新手教程&quot;</span>, phaser)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>关卡1，需要加载4个模块，当前模块【加载背景音乐】<br>关卡1，需要加载4个模块，当前模块【加载新手教程】<br>下次关卡移除加载【新手教程】模块<br>关卡1，需要加载3个模块，当前模块【加载地图数据】<br>关卡1，需要加载3个模块，当前模块【加载人物模型】<br>第1次关卡准备完成<br>关卡2，需要加载3个模块，当前模块【加载地图数据】<br>关卡2，需要加载3个模块，当前模块【加载背景音乐】<br>关卡2，需要加载3个模块，当前模块【加载人物模型】<br>第2次关卡准备完成<br>关卡3，需要加载3个模块，当前模块【加载人物模型】<br>关卡3，需要加载3个模块，当前模块【加载地图数据】<br>关卡3，需要加载3个模块，当前模块【加载背景音乐】<br>第3次关卡准备完成</p></blockquote><p>这里要注意关卡1的输出，在“加载新手教程”线程中调用了<code>arriveAndDeregister()</code>减少一个party之后，后面的线程使用<code>getRegisteredParties()</code>得到的是已经被修改后的parties了。但是当前这个阶段(phase)，仍然是需要4个parties都arrive才触发屏障的。从下一个阶段开始，才需要3个parties都arrive就触发屏障。</p><p>另外Phaser类用来控制某个阶段的线程数量很有用，但它并在意这个阶段具体有哪些线程arrive，只要达到它当前阶段的parties值，就触发屏障。所以我这里的案例虽然制定了特定的线程（加载新手教程）来更直观地表述Phaser的功能，但是其实Phaser是没有分辨具体是哪个线程的功能的，它在意的只是数量，这一点需要读者注意。</p><h5 id="Phaser原理"><a href="#Phaser原理" class="headerlink" title="Phaser原理"></a>Phaser原理</h5><p>Phaser类的原理相比起来要复杂得多。它内部使用了两个基于Fork-Join框架的原子类辅助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123;<br>    <span class="hljs-comment">// 实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有兴趣的读者可以去看看JDK源代码，这里不做过多叙述。</p><p>总的来说，CountDownLatch，CyclicBarrier，Phaser是一个比一个强大，但也一个比一个复杂。根据自己的业务需求合理选择即可</p><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><h4 id="什么是Fork-Join"><a href="#什么是Fork-Join" class="headerlink" title="什么是Fork&#x2F;Join"></a>什么是Fork&#x2F;Join</h4><p>Fork&#x2F;Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p><p>与其他ExecutorService相关的实现相同的是，Fork&#x2F;Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork&#x2F;Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p><p><strong>fork</strong>在英文里有分叉的意思，<strong>join</strong>在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。</p><p>Fork&#x2F;Join的运行流程大致如下所示：</p><p><img src="/posts/60838/fork_join.png" alt="fork/join流程图"></p><p>需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">solve(任务):<br>    if(任务已经划分到足够小):<br>        顺序执行任务<br>    else:<br>        for(划分任务得到子任务)<br>            solve(子任务)<br>        结合所有子任务的结果到上一层循环<br>        return 最终结合的结果<br></code></pre></td></tr></table></figure><p>通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现<strong>分而治之(divide and conquer)</strong> 的算法思想。</p><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p><p>工作窃取流程如下图所示：</p><p><img src="/posts/60838/3.png" alt="工作窃取算法流程"></p><p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的<strong>头部</strong>拿任务执行，而窃取其他任务的线程从双端队列的<strong>尾部</strong>执行任务。</p><p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入<strong>阻塞状态</strong>以等待再次“工作”。</p><h4 id="Fork-Join的具体实现"><a href="#Fork-Join的具体实现" class="headerlink" title="Fork&#x2F;Join的具体实现"></a>Fork&#x2F;Join的具体实现</h4><p>前面我们说Fork&#x2F;Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有<strong>任务</strong>。在Fork&#x2F;Join框架里提供了抽象类<code>ForkJoinTask</code>来实现任务。</p><h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p><p><strong>fork()方法</strong>:使用线程池中的空闲线程异步提交任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本文所有代码都引自Java 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-comment">// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理</span><br>    <span class="hljs-comment">// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>         <span class="hljs-comment">// 如果不是则将线程加入队列</span><br>        <span class="hljs-comment">// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实fork()只做了一件事，那就是<strong>把任务推入当前工作线程的工作队列里</strong>。</p><p><strong>join()方法</strong>：等待处理任务的线程处理完毕，获得返回值。</p><p>来看下join()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-comment">// doJoin()方法来获取当前任务的执行状态</span><br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        <span class="hljs-comment">// 任务异常，抛出异常</span><br>        reportException(s);<br>    <span class="hljs-comment">// 任务正常完成，获取返回值</span><br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * doJoin()方法用来返回当前任务的执行状态</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <span class="hljs-comment">// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span><br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>    <span class="hljs-comment">// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span><br>    ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        <span class="hljs-comment">// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span><br>        <span class="hljs-comment">// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span><br>        <span class="hljs-comment">// doExec()方法执行任务</span><br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        <span class="hljs-comment">// 如果是处于顶端并且任务执行完毕，返回结果</span><br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        <span class="hljs-comment">// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span><br>        <span class="hljs-comment">// awaitJoin()：使用自旋使任务执行完成，返回结果</span><br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>    <span class="hljs-comment">// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span><br>    externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在之前介绍过说Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图：<img src="/posts/60838/join.png" alt="join流程图"></p><p><strong>RecursiveAction和RecursiveTask</strong></p><p>通常情况下，在创建任务的时候我们一般不直接继承ForkJoinTask，而是继承它的子类<strong>RecursiveAction</strong>和<strong>RecursiveTask</strong>。</p><p>两个都是ForkJoinTask的子类，<strong>RecursiveAction可以看做是无返回值的ForkJoinTask，RecursiveTask是有返回值的ForkJoinTask</strong>。</p><p>此外，两个子类都有执行主要计算的方法compute()，当然，RecursiveAction的compute()返回void，RecursiveTask的compute()有具体的返回值。</p><h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</p><p>ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p><p>我们来大致看下ForkJoinPool的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues;   <br><br>    <span class="hljs-comment">// 线程的运行状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> runState;  <br><br>    <span class="hljs-comment">// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;<br><br>    <span class="hljs-comment">// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinPool common;<br><br>    <span class="hljs-comment">// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用</span><br>    <span class="hljs-comment">// 其他构造方法都是源自于此方法</span><br>    <span class="hljs-comment">// parallelism: 并行度，</span><br>    <span class="hljs-comment">// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                         ForkJoinWorkerThreadFactory factory, // 工作线程工厂</span><br><span class="hljs-params">                         UncaughtExceptionHandler handler, // 拒绝任务的handler</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> mode, // 同步模式</span><br><span class="hljs-params">                         String workerNamePrefix)</span> &#123; <span class="hljs-comment">// 线程名prefix</span><br>        <span class="hljs-built_in">this</span>.workerNamePrefix = workerNamePrefix;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.ueh = handler;<br>        <span class="hljs-built_in">this</span>.config = (parallelism &amp; SMASK) | mode;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">np</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(-parallelism); <span class="hljs-comment">// offset ctl counts</span><br>        <span class="hljs-built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>WorkQueue</strong></p><p>双端队列，ForkJoinTask存放在这里。</p><p>当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</p><p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个<strong>工作队列数组</strong>（volatile WorkQueue[] workQueues，ForkJoinPool中的<strong>每个工作线程都维护着一个工作队列</strong>）。</p><p><strong>runState</strong></p><p>ForkJoinPool的运行状态。<strong>SHUTDOWN</strong>状态用负数表示，其他用2的幂次表示。</p><h4 id="Fork-Join的使用"><a href="#Fork-Join的使用" class="headerlink" title="Fork&#x2F;Join的使用"></a>Fork&#x2F;Join的使用</h4><p>上面我们说ForkJoinPool负责管理线程和任务，ForkJoinTask实现fork和join操作，所以要使用Fork&#x2F;Join框架就离不开这两个类了，只是在实际开发中我们常用ForkJoinTask的子类RecursiveTask 和RecursiveAction来替代ForkJoinTask。</p><p>下面我们用一个计算斐波那契数列第n项的例子来看一下Fork&#x2F;Join的使用：</p><blockquote><p>斐波那契数列数列是一个线性递推数列，从第三项开始，每一项的值都等于前两项之和：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89······</p><p>如果设f(n）为该数列的第n项（n∈N*），那么有：f(n) &#x3D; f(n-1) + f(n-2)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTest</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-comment">// 主要的实现逻辑都在compute()里</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 这里先假设 n &gt;= 0</span><br>            <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// f(n-1)</span><br>                <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">1</span>);<br>                f1.fork();<br>                <span class="hljs-comment">// f(n-2)</span><br>                <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>                f2.fork();<br>                <span class="hljs-comment">// f(n) = f(n-1) + f(n-2)</span><br>                <span class="hljs-keyword">return</span> f1.join() + f2.join();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFib</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        System.out.println(<span class="hljs-string">&quot;CPU核数：&quot;</span> + Runtime.getRuntime().availableProcessors());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">fibonacci</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(<span class="hljs-number">40</span>);<br>        Future&lt;Integer&gt; future = forkJoinPool.submit(fibonacci);<br>        System.out.println(future.get());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>, end - start));<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子在本机的输出：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">CPU核数：<span class="hljs-number">4</span><br>计算结果：<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">9490</span> millis<br></code></pre></td></tr></table></figure><p>需要注意的是，上述计算时间复杂度为<code>O(2^n)</code>，随着n的增长计算效率会越来越低，这也是上面的例子中n不敢取太大的原因。</p><p>此外，也并不是所有的任务都适合Fork&#x2F;Join框架，比如上面的例子任务划分过于细小反而体现不出效率，下面我们试试用普通的递归来求f(n)的值，看看是不是要比使用Fork&#x2F;Join快：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通递归，复杂度为O(2^n)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">plainRecursion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> plainRecursion(n -<span class="hljs-number">1</span>) + plainRecursion(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPlain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> plainRecursion(<span class="hljs-number">40</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;计算结果:&quot;</span> + result);<br>    System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>,  end -start));<br>&#125;<br></code></pre></td></tr></table></figure><p>普通递归的例子输出：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">计算结果:<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">436</span> millis<br></code></pre></td></tr></table></figure><p>通过输出可以很明显的看出来，使用普通递归的效率都要比使用Fork&#x2F;Join框架要高很多。</p><p>这里我们再用另一种思路来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过循环来计算，复杂度为O(n)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeFibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 假设n &gt;= 0</span><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-comment">// 第三个数是前两个数之和</span><br>            third = first + second;<br>            <span class="hljs-comment">// 前两个数右移</span><br>            first = second;<br>            second = third;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testComputeFibonacci</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> computeFibonacci(<span class="hljs-number">40</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;计算结果:&quot;</span> + result);<br>    System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>,  end -start));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子在笔者所用电脑的输出为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">计算结果:<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">0</span> millis<br></code></pre></td></tr></table></figure><p>这里耗时为0不代表没有耗时，是表明这里计算的耗时几乎可以忽略不计，大家可以在自己的电脑试试，即使是n取大很多量级的数据（注意int溢出的问题）耗时也是很短的，或者可以用System.nanoTime()统计纳秒的时间。</p><p>为什么在这里普通的递归或循环效率更快呢？因为Fork&#x2F;Join是使用多个线程协作来计算的，所以会有线程通信和线程切换的开销。</p><p>如果要计算的任务比较简单（比如我们案例中的斐波那契数列），那当然是直接使用单线程会更快一些。但如果要计算的东西比较复杂，计算机又是多核的情况下，就可以充分利用多核CPU来提高计算速度。</p><p>另外，Java 8 Stream的并行操作底层就是用到了Fork&#x2F;Join框架，下一章我们将从源码及案例两方面介绍Java 8 Stream的并行操作</p><h3 id="Stream并行计算原理"><a href="#Stream并行计算原理" class="headerlink" title="Stream并行计算原理"></a>Stream并行计算原理</h3><h4 id="Stream简介"><a href="#Stream简介" class="headerlink" title="Stream简介"></a>Stream简介</h4><p>从Java 8 开始，我们可以使用<code>Stream</code>接口以及<strong>lambda表达式</strong>进行“流式计算”。它可以让我们对集合的操作更加简洁、更加可读、更加高效。</p><p>Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p><h4 id="Stream单线程串行计算"><a href="#Stream单线程串行计算" class="headerlink" title="Stream单线程串行计算"></a>Stream单线程串行计算</h4><p>Stream接口默认是使用串行的方式，也就是说在一个线程里执行。下面举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .reduce((a, b) -&gt; &#123;<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s: %d + %d = %d&quot;</span>,<br>                            Thread.currentThread().getName(), a, b, a + b));<br>                    <span class="hljs-keyword">return</span> a + b;<br>                &#125;)<br>                .ifPresent(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来理解一下这个方法。首先我们用整数1~9创建了一个<code>Stream</code>。这里的Stream.of(T… values)方法是Stream接口的一个静态方法，其底层调用的是Arrays.stream(T[] array)方法。</p><p>然后我们使用了<code>reduce</code>方法来计算这个集合的累加和。<code>reduce</code>方法这里做的是：从前两个元素开始，进行某种操作（我这里进行的是加法操作）后，返回一个结果，然后再拿这个结果跟第三个元素执行同样的操作，以此类推，直到最后的一个元素。</p><p>我们来打印一下当前这个reduce操作的线程以及它们被操作的元素和返回的结果以及最后所有reduce方法的结果，也就代表的是数字1到9的累加和。</p><blockquote><p>main: 1 + 2 &#x3D; 3<br>main: 3 + 3 &#x3D; 6<br>main: 6 + 4 &#x3D; 10<br>main: 10 + 5 &#x3D; 15<br>main: 15 + 6 &#x3D; 21<br>main: 21 + 7 &#x3D; 28<br>main: 28 + 8 &#x3D; 36<br>main: 36 + 9 &#x3D; 45<br>45</p></blockquote><p>可以看到，默认情况下，它是在一个单线程运行的，也就是<strong>main</strong>线程。然后每次reduce操作都是串行起来的，首先计算前两个数字的和，然后再往后依次计算。</p><h4 id="Stream多线程并行计算"><a href="#Stream多线程并行计算" class="headerlink" title="Stream多线程并行计算"></a>Stream多线程并行计算</h4><p>我们思考上面一个例子，是不是一定要在单线程里进行串行地计算呢？假如我的计算机是一个多核计算机，我们在理论上能否利用多核来进行并行计算，提高计算效率呢？</p><p>当然可以，比如我们在计算前两个元素1 + 2 &#x3D; 3的时候，其实我们也可以同时在另一个核计算 3 + 4 &#x3D; 7。然后等它们都计算完成之后，再计算 3 + 7 &#x3D; 10的操作。</p><p>是不是很熟悉这样的操作手法？没错，它就是ForkJoin框架的思想。下面小小地修改一下上面的代码，增加一行代码，使Stream使用多线程来并行计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamParallelDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .parallel()<br>                .reduce((a, b) -&gt; &#123;<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s: %d + %d = %d&quot;</span>,<br>                            Thread.currentThread().getName(), a, b, a + b));<br>                    <span class="hljs-keyword">return</span> a + b;<br>                &#125;)<br>                .ifPresent(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，与上一个案例的代码只有一点点区别，就是在reduce方法被调用之前，调用了parallel()方法。下面来看看这个方法的输出：</p><blockquote><p>ForkJoinPool.commonPool-worker-1: 3 + 4 &#x3D; 7<br>ForkJoinPool.commonPool-worker-4: 8 + 9 &#x3D; 17<br>ForkJoinPool.commonPool-worker-2: 5 + 6 &#x3D; 11<br>ForkJoinPool.commonPool-worker-3: 1 + 2 &#x3D; 3<br>ForkJoinPool.commonPool-worker-4: 7 + 17 &#x3D; 24<br>ForkJoinPool.commonPool-worker-4: 11 + 24 &#x3D; 35<br>ForkJoinPool.commonPool-worker-3: 3 + 7 &#x3D; 10<br>ForkJoinPool.commonPool-worker-3: 10 + 35 &#x3D; 45<br>45</p></blockquote><p>可以很明显地看到，它使用的线程是<code>ForkJoinPool</code>里面的<code>commonPool</code>里面的<strong>worker</strong>线程。并且它们是并行计算的，并不是串行计算的。但由于Fork&#x2F;Join框架的作用，它最终能很好的协调计算结果，使得计算结果完全正确。</p><p>如果我们用Fork&#x2F;Join代码去实现这样一个功能，那无疑是非常复杂的。但Java8提供了并行式的流式计算，大大简化了我们的代码量，使得我们只需要写很少很简单的代码就可以利用计算机底层的多核资源。</p><h4 id="从源码看Stream并行计算原理"><a href="#从源码看Stream并行计算原理" class="headerlink" title="从源码看Stream并行计算原理"></a>从源码看Stream并行计算原理</h4><p>上面我们通过在控制台输出线程的名字，看到了Stream的并行计算底层其实是使用的Fork&#x2F;Join框架。那它到底是在哪使用Fork&#x2F;Join的呢？我们从源码上来解析一下上述案例。</p><p><code>Stream.of</code>方法就不说了，它只是生成一个简单的Stream。先来看看<code>parallel()</code>方法的源码。这里由于我的数据是<code>int</code>类型的，所以它其实是使用的<code>BaseStream</code>接口的<code>parallel()</code>方法。而<code>BaseStream</code>接口的JDK唯一实现类是一个叫<code>AbstractPipeline</code>的类。下面我们来看看这个类的<code>parallel()</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> S <span class="hljs-title function_">parallel</span><span class="hljs-params">()</span> &#123;<br>    sourceStage.parallel = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> (S) <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法很简单，就是把一个标识<code>sourceStage.parallel</code>设置为<code>true</code>。然后返回实例本身。</p><p>接着我们再来看<code>reduce</code>这个方法的内部实现。</p><p>Stream.reduce()方法的具体实现是交给了<code>ReferencePipeline</code>这个抽象类，它是继承了<code>AbstractPipeline</code>这个类的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReferencePipeline抽象类的reduce方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Optional&lt;P_OUT&gt; <span class="hljs-title function_">reduce</span><span class="hljs-params">(BinaryOperator&lt;P_OUT&gt; accumulator)</span> &#123;<br>    <span class="hljs-comment">// 调用evaluate方法</span><br>    <span class="hljs-keyword">return</span> evaluate(ReduceOps.makeRef(accumulator));<br>&#125;<br><br><span class="hljs-keyword">final</span> &lt;R&gt; R <span class="hljs-title function_">evaluate</span><span class="hljs-params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">getOutputShape</span><span class="hljs-params">()</span> == terminalOp.inputShape();<br>    <span class="hljs-keyword">if</span> (linkedOrConsumed)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);<br>    linkedOrConsumed = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> isParallel() <span class="hljs-comment">// 调用isParallel()判断是否使用并行模式</span><br>        ? terminalOp.evaluateParallel(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()))<br>        : terminalOp.evaluateSequential(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isParallel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 根据之前在parallel()方法设置的那个flag来判断。</span><br>    <span class="hljs-keyword">return</span> sourceStage.parallel;<br>&#125;<br></code></pre></td></tr></table></figure><p>从它的源码可以知道，reduce方法调用了evaluate方法，而evaluate方法会先去检查当前的flag，是否使用并行模式，如果是则会调用<code>evaluateParallel</code>方法执行并行计算，否则，会调用<code>evaluateSequential</code>方法执行串行计算。</p><p>这里我们再看看<code>TerminalOp</code>（注意这里是字母l O，而不是数字1 0）接口的<code>evaluateParallel</code>方法。<code>TerminalOp</code>接口的实现类有这样几个内部类：</p><ul><li>java.util.stream.FindOps.FindOp</li><li>java.util.stream.ForEachOps.ForEachOp</li><li>java.util.stream.MatchOps.MatchOp</li><li>java.util.stream.ReduceOps.ReduceOp</li></ul><p>可以看到，对应的是Stream的几种主要的计算操作。我们这里的示例代码使用的是reduce计算，那我们就看看ReduceOp类的这个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.stream.ReduceOps.ReduceOp.evaluateParallel</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;P_IN&gt; R <span class="hljs-title function_">evaluateParallel</span><span class="hljs-params">(PipelineHelper&lt;T&gt; helper,</span><br><span class="hljs-params">                                 Spliterator&lt;P_IN&gt; spliterator)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReduceTask</span>&lt;&gt;(<span class="hljs-built_in">this</span>, helper, spliterator).invoke().get();<br>&#125;<br></code></pre></td></tr></table></figure><p>evaluateParallel方法创建了一个新的ReduceTask实例，并且调用了invoke()方法后再调用get()方法，然后返回这个结果。那这个ReduceTask是什么呢？它的invoke方法内部又是什么呢？</p><p>追溯源码我们可以发现，ReduceTask类是ReduceOps类的一个内部类，它继承了AbstractTask类，而AbstractTask类又继承了CountedCompleter类，而CountedCompleter类又继承了ForkJoinTask类！</p><p>它们的继承关系如下：</p><blockquote><p>ReduceTask -&gt; AbstractTask -&gt; CountedCompleter -&gt; ForkJoinTask</p></blockquote><p>这里的ReduceTask的invoke方法，其实是调用的ForkJoinTask的invoke方法，中间三层继承并没有覆盖这个方法的实现。</p><p>所以这就从源码层面解释了Stream并行的底层原理是使用了Fork&#x2F;Join框架。</p><p>需要注意的是，一个Java进程的Stream并行计算任务默认共享同一个线程池，如果随意的使用并行特性可能会导致方法的吞吐量下降。我们可以通过下面这种方式来让你的某个并行Stream使用自定义的ForkJoin线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">customThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">actualTotal</span> <span class="hljs-operator">=</span> customThreadPool<br>  .submit(() -&gt; roster.parallelStream().reduce(<span class="hljs-number">0</span>, Integer::sum)).get();<br></code></pre></td></tr></table></figure><h4 id="Stream并行计算的性能提升"><a href="#Stream并行计算的性能提升" class="headerlink" title="Stream并行计算的性能提升"></a>Stream并行计算的性能提升</h4><p>我们可以在本地测试一下如果在多核情况下，Stream并行计算会给我们的程序带来多大的效率上的提升。用以下示例代码来计算一千万个随机数的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamParallelDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;本计算机的核数：%d&quot;</span>, Runtime.getRuntime().availableProcessors()));<br><br>        <span class="hljs-comment">// 产生100w个随机数(1 ~ 100)，组成列表</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1000_0000</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000</span>; i++) &#123;<br>            list.add(random.nextInt(<span class="hljs-number">100</span>));<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">prevTime</span> <span class="hljs-operator">=</span> getCurrentTime();<br>        list.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);<br>        System.out.println(String.format(<span class="hljs-string">&quot;单线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));<br><br>        prevTime = getCurrentTime();<br>        list.stream().parallel().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);<br>        System.out.println(String.format(<span class="hljs-string">&quot;多线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCurrentTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>本计算机的核数：8<br>495156156<br>单线程计算耗时：223<br>495156156<br>多线程计算耗时：95</p></blockquote><p>所以在多核的情况下，使用Stream的并行计算确实比串行计算能带来很大效率上的提升，并且也能保证结果计算完全准确。</p><p>本文一直在强调的“多核”的情况。其实可以看到，我的本地电脑有8核，但并行计算耗时并不是单线程计算耗时除以8，因为线程的创建、销毁以及维护线程上下文的切换等等都有一定的开销。所以如果你的服务器并不是多核服务器，那也没必要用Stream的并行计算。因为在单核的情况下，往往Stream的串行计算比并行计算更快，因为它不需要线程切换的开销。</p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>自JDK 1.5 开始，JDK提供了<code>ScheduledThreadPoolExecutor</code>类用于计划任务（又称定时任务），这个类有两个用途：</p><ul><li>在给定的延迟之后运行任务</li><li>周期性重复执行任务</li></ul><p>在这之前，是使用<code>Timer</code>类来完成定时任务的，但是<code>Timer</code>有缺陷：</p><ul><li>Timer是<strong>单线程</strong>模式；</li><li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li><li>Timer的任务调度是基于绝对时间的，对<strong>系统时间</strong>敏感；</li><li>Timer不会捕获执行TimerTask时所抛出的<strong>异常</strong>，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li></ul><p>所以JDK 1.5之后，大家就摒弃<code>Timer</code>,使用<code>ScheduledThreadPoolExecutor</code>吧。</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>假设我有一个需求，指定时间给大家发送消息。那么我们会将消息（包含发送时间）存储在数据库中，然后想用一个定时任务，每隔1秒检查数据库在当前时间有没有需要发送的消息，那这个计划任务怎么写？下面是一个Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>        <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, Executors.defaultThreadFactory());<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">// 新建一个固定延迟时间的计划任务</span><br>        executor.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (haveMsgAtCurrentTime()) &#123;<br>                    System.out.println(df.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>                    System.out.println(<span class="hljs-string">&quot;大家注意了，我要发消息了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">haveMsgAtCurrentTime</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//查询数据库，有没有当前时间需要发送的消息</span><br>        <span class="hljs-comment">//这里省略实现，直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面截取前面的输出（这个demo会一直运行下去）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">48</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">49</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">50</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">51</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">52</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">53</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">54</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">55</span><br>大家注意了，我要发消息了<br></code></pre></td></tr></table></figure><p>这就是<code>ScheduledThreadPoolExecutor</code>的一个简单运用，想要知道奥秘，接下来的东西需要仔细的看哦。</p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,ThreadFactory threadFactory)</span> &#123;<br>         <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>    &#125;<br>    <span class="hljs-comment">//……</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，实现了<code>ScheduledExecutorService</code>。 线程池在之前的章节介绍过了，我们先看看<code>ScheduledExecutorService</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="hljs-type">long</span> delay, TimeUnit unit);<br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,<span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ScheduledExecutorService</code>实现了<code>ExecutorService</code> ,并增加若干定时相关的接口。 前两个方法用于单次调度执行任务，区别是有没有返回值。</p><p>重点理解一下后面两个方法：</p><ul><li><p>scheduleAtFixedRate</p><p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每隔<code>period</code>时长，再次执行任务。注意，period是从<strong>任务开始执行算起</strong>的。开始执行任务后，定时器每隔period时长<strong>检查该任务是否完成</strong>，如果完成则再次启动任务，否则等该任务结束后才再次启动任务。</p></li><li><p>scheduleWithFixDelay</p><p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每当任务执行<strong>完成后</strong>，等待<code>delay</code>时长，再次执行任务。</p></li></ul><h4 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h4><h5 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// delay时长后执行任务command，该任务只执行一次</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 这里的decorateTask方法仅仅返回第二个参数</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<br>                                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay,unit)));<br>    <span class="hljs-comment">// 延时或者周期执行任务的主要方法,稍后统一说明</span><br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看看里面涉及到的几个类和接口<code>ScheduledFuture</code>、 <code>RunnableScheduledFuture</code>、 <code>ScheduledFutureTask</code>的关系：</p><p><img src="/posts/60838/4.jpg" alt="类图"></p><p>我们先看看这几个接口和类：</p><h6 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承Comparable接口，表示该类对象支持排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-comment">// 返回该对象剩余时延</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Delayed</code>接口很简单，继承了<code>Comparable</code>接口，表示对象是可以比较排序的。</p><h6 id="ScheduledFuture接口"><a href="#ScheduledFuture接口" class="headerlink" title="ScheduledFuture接口"></a>ScheduledFuture接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仅仅继承了Delayed和Future接口，自己没有任何代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>, Future&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有添加其他方法。</p><h6 id="RunnableScheduledFuture接口"><a href="#RunnableScheduledFuture接口" class="headerlink" title="RunnableScheduledFuture接口"></a>RunnableScheduledFuture接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;, ScheduledFuture&lt;V&gt; &#123;      <br>    <span class="hljs-comment">// 是否是周期任务，周期任务可被调度运行多次，非周期任务只被运行一次   </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ScheduledFutureTask类"><a href="#ScheduledFutureTask类" class="headerlink" title="ScheduledFutureTask类"></a>ScheduledFutureTask类</h6><p>回到<code>schecule</code>方法中，它创建了一个<code>ScheduledFutureTask</code>的对象，由上面的关系图可知，<code>ScheduledFutureTask</code>直接或者间接实现了很多接口，一起看看<code>ScheduledFutureTask</code>里面的实现方法吧。</p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;<br>    <span class="hljs-comment">// 调用父类FutureTask的构造方法</span><br>    <span class="hljs-built_in">super</span>(r, result);<br>    <span class="hljs-comment">// time表示任务下次执行的时间</span><br>    <span class="hljs-built_in">this</span>.time = ns;<br>    <span class="hljs-comment">// 周期任务，正数表示按照固定速率，负数表示按照固定时延,0表示不是周期任务</span><br>    <span class="hljs-built_in">this</span>.period = period;<br>    <span class="hljs-comment">// 任务的编号</span><br>    <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Delayed接口的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Delayed接口的getDelay方法，返回任务开始执行的剩余时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Comparable接口的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparable接口的compareTo方法，比较两个任务的”大小”。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>    <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>      ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br>      <span class="hljs-comment">// 小于0，说明当前任务的执行时间点早于other，要排在延时队列other的前面</span><br>      <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 大于0，说明当前任务的执行时间点晚于other，要排在延时队列other的后面</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 如果两个任务的执行时间点一样，比较两个任务的编号，编号小的排在队列前面，编号大的排在队列后面</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果任务类型不是ScheduledFutureTask，通过getDelay方法比较</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (getDelay(TimeUnit.NANOSECONDS) -<br>              other.getDelay(TimeUnit.NANOSECONDS));<br>    <span class="hljs-keyword">return</span> (d == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : ((d &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>setNextRunTime</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务执行完后，设置下次执行的时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-comment">// p &gt; 0，说明是固定速率运行的任务</span><br>    <span class="hljs-comment">// 在原来任务开始执行时间的基础上加上p即可</span><br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>      time += p;<br>    <span class="hljs-comment">// p &lt; 0，说明是固定时延运行的任务，</span><br>    <span class="hljs-comment">// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span><br>    <span class="hljs-keyword">else</span><br>      time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Runnable接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>    <span class="hljs-comment">// 如果当前状态下不能执行任务，则取消任务</span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>      cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 不是周期性任务，执行一次任务即可，调用父类的run方法</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>      ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-comment">// 是周期性任务，调用FutureTask的runAndReset方法，方法执行完成后</span><br>    <span class="hljs-comment">// 重新设置任务下一次执行的时间，并将该任务重新入队，等待再次被调度</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>      setNextRunTime();<br>      reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下run方法的执行过程：</p><ol><li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li><li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li><li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li><li>计算下次执行该任务的具体时间；</li><li>重复执行任务。</li></ol><p><code>runAndReset</code>方法是为任务多次执行而设计的。<code>runAndReset</code>方法执行完任务后不会设置任务的执行结果，也不会去更新任务的状态，维持任务的状态为初始状态（<strong>NEW</strong>状态），这也是该方法和<code>FutureTask</code>的<code>run</code>方法的区别。</p><h5 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h5><p>我们看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意，固定速率和固定时延，传入的参数都是Runnable，也就是说这种定时任务是没有返回值的</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-comment">// 创建一个有初始延时和固定周期的任务</span><br>    ScheduledFutureTask&lt;Void&gt; sft =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                    <span class="hljs-literal">null</span>,<br>                                    triggerTime(initialDelay, unit),<br>                                    unit.toNanos(period));<br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>    <span class="hljs-comment">// outerTask表示将会重新入队的任务</span><br>    sft.outerTask = t;<br>    <span class="hljs-comment">// 稍后说明</span><br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>scheduleAtFixedRate</code>这个方法和<code>schedule</code>类似，不同点是<code>scheduleAtFixedRate</code>方法内部创建的是<code>ScheduledFutureTask</code>，带有初始延时和固定周期的任务 。</p><h5 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h5><p><code>FixedDelay</code>也是通过<code>ScheduledFutureTask</code>体现的，唯一不同的地方在于创建的<code>ScheduledFutureTask</code>不同 。这里不再展示源码。</p><h5 id="delayedExecute"><a href="#delayedExecute" class="headerlink" title="delayedExecute"></a>delayedExecute</h5><p>前面讲到的<code>schedule</code>、<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>最后都调用了<code>delayedExecute</code>方法，该方法是定时任务执行的主要方法。 一起来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-comment">// 线程池已经关闭，调用拒绝执行处理器处理</span><br>    <span class="hljs-keyword">if</span> (isShutdown())<br>      reject(task);<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将任务加入到等待队列</span><br>      <span class="hljs-built_in">super</span>.getQueue().add(task);<br>      <span class="hljs-comment">// 线程池已经关闭，且当前状态不能运行该任务，将该任务从等待队列移除并取消该任务</span><br>      <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>          !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>          remove(task))<br>        task.cancel(<span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 增加一个worker，就算corePoolSize=0也要增加一个worker</span><br>        ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delayedExecute</code>方法的逻辑也很简单，主要就是将任务添加到等待队列，然后调用<code>ensurePrestart</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensurePrestart</code>方法主要是调用了<code>addWorker</code>，线程池中的工作线程是通过该方法来启动并执行任务的。 具体可以查看前面讲的线程池章节。</p><p>对于<code>ScheduledThreadPoolExecutor</code>，<code>worker</code>添加到线程池后会在等待队列上等待获取任务，这点是和<code>ThreadPoolExecutor</code>一致的。<strong>但是worker是怎么从等待队列取定时任务的？</strong></p><p>因为<code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务，该等待队列队首应该保存的是最近将要执行的任务，如果队首任务的开始执行时间还未到，<code>worker</code>也应该继续等待。</p><h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p><code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务。</p><p>该等待队列队首应该保存的是<strong>最近将要执行的任务</strong>，所以<code>worker</code>只关心队首任务即可，如果队首任务的开始执行时间还未到，worker也应该继续等待。</p><p>DelayedWorkQueue是一个无界优先队列，使用数组存储，底层是使用堆结构来实现优先队列的功能。我们先看看DelayedWorkQueue的声明和成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;Runnable&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;Runnable&gt; &#123;<br>    <span class="hljs-comment">// 队列初始容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">// 数组用来存储定时任务，通过数组实现堆排序</span><br>    <span class="hljs-keyword">private</span> RunnableScheduledFuture[] queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>[INITIAL_CAPACITY];<br>    <span class="hljs-comment">// 当前在队首等待的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">leader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 锁和监视器，用于leader线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 其他代码，略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当一个线程成为leader，它只要等待队首任务的delay时间即可，其他线程会无条件等待。leader取到任务返回前要通知其他线程，直到有线程成为新的leader。每当队首的定时任务被其他更早需要执行的任务替换时，leader设置为null，其他等待的线程（被当前leader通知）和当前的leader重新竞争成为leader。</p><p>同时，定义了锁lock和监视器available用于线程竞争成为leader。</p><p>当一个新的任务成为队首，或者需要有新的线程成为leader时，available监视器上的线程将会被通知，然后竞争成为leader线程。 有些类似于生产者-消费者模式。</p><p>接下来看看<code>DelayedWorkQueue</code>中几个比较重要的方法</p><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RunnableScheduledFuture <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 取堆顶的任务，堆顶是最近要执行的任务</span><br>        <span class="hljs-type">RunnableScheduledFuture</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> queue[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 堆顶为空，线程要在条件available上等待</span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>          available.await();<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 堆顶任务还要多长时间才能执行</span><br>          <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(TimeUnit.NANOSECONDS);<br>          <span class="hljs-comment">// 堆顶任务已经可以执行了，finishPoll会重新调整堆，使其满足最小堆特性，该方法设置任务在</span><br>          <span class="hljs-comment">// 堆中的index为-1并返回该任务</span><br>          <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> finishPoll(first);<br>          <span class="hljs-comment">// 如果leader不为空，说明已经有线程成为leader并等待堆顶任务</span><br>          <span class="hljs-comment">// 到达执行时间，此时，其他线程都需要在available条件上等待</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>            available.await();<br>          <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// leader为空，当前线程成为新的leader</span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            leader = thisThread;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 当前线程已经成为leader了，只需要等待堆顶任务到达执行时间即可</span><br>              available.awaitNanos(delay);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-comment">// 返回堆顶元素之前将leader设置为空</span><br>              <span class="hljs-keyword">if</span> (leader == thisThread)<br>                leader = <span class="hljs-literal">null</span>;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 通知其他在available条件等待的线程，这些线程可以去竞争成为新的leader</span><br>      <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)<br>        available.signal();<br>      lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>take</code>方法是什么时候调用的呢？在线程池的章节中，介绍了<code>getTask</code>方法，工作线程会循环地从<code>workQueue</code>中取任务。但计划任务却不同，因为如果一旦<code>getTask</code>方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在<code>take</code>方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p><p>总结一下流程：</p><ol><li>如果堆顶元素为空，在available条件上等待。</li><li>如果堆顶任务的执行时间已到，将堆顶元素替换为堆的最后一个元素并调整堆使其满足<strong>最小堆</strong>特性，同时设置任务在堆中索引为-1，返回该任务。</li><li>如果leader不为空，说明已经有线程成为leader了，其他线程都要在available监视器上等待。</li><li>如果leader为空，当前线程成为新的leader，并等待直到堆顶任务执行时间到达。</li><li>take方法返回之前，将leader设置为空，并通知其他线程。</li></ol><p>再来说一下leader的作用，这里的leader是<strong>为了减少不必要的定时等待</strong>，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从<code>take()</code>或<code>poll()</code>返回之前signal其它线程，除非其他线程成为了leader。</p><p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。但只有一个线程返回队首任务，其他的线程在<code>awaitNanos(delay)</code>之后，继续执行for循环，因为队首任务已经被返回了，所以这个时候的for循环拿到的队首任务是新的，又需要重新判断时间，又要继续阻塞。</p><p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在<code>finally</code>中调用了<code>signal()</code>来唤醒一个线程，而不是<code>signalAll()</code>）。</p><h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><p>该方法往队列插入一个值，返回是否成功插入 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">RunnableScheduledFuture</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (RunnableScheduledFuture)x;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>      <span class="hljs-comment">// 队列元素已经大于等于数组的长度，需要扩容，新堆的容量是原来堆容量的1.5倍</span><br>      <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow();<br>      <span class="hljs-comment">// 堆中元素增加1</span><br>      size = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 调整堆</span><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        queue[<span class="hljs-number">0</span>] = e;<br>        setIndex(e, <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 调整堆，使的满足最小堆，比较大小的方式就是上文提到的compareTo方法</span><br>        siftUp(i, e);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;<br>        leader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 通知其他在available条件上等待的线程，这些线程可以竞争成为新的leader</span><br>        available.signal();<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在堆中插入了一个节点，这个时候堆有可能不满足最小堆的定义，<code>siftUp</code>用于将堆调整为最小堆，这属于数据结构的基本内容，本文不做介绍。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内部使用优化的DelayQueue来实现，由于使用队列来实现定时器，有出入队调整堆等操作，所以定时并不是非常非常精确</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h4><h5 id="什么是一致性问题"><a href="#什么是一致性问题" class="headerlink" title="什么是一致性问题"></a>什么是一致性问题</h5><p>多线程充分利用了多核CPU的威力，为我们程序提供了很高的性能。但是有时候，我们需要多个线程互相协作，这里可能就会涉及到数据一致性的问题。 数据一致性指问题的是：发生在<strong>多个主体</strong>对<strong>同一份</strong>数据无法达成<strong>共识</strong>。这里的多个主体，可能是多线程，也可能是多个服务器节点。 当然了，这里的“多个主体”也可以指朋友之间，夫妻之间，所谓“道不同，不相为谋”，说的就是这个理。</p><h5 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h5><p>第一种是<strong>排队</strong>，如果两个人对一个问题的看法不一致，那就排成一队，一个人一个人去修改它，这样后面一个人总是能够得到前面一个人修改后的值，数据也就总是一致的了。我们在操作系统中的锁、互斥量、管程、屏障等等概念，都是利用了排队的思想。排队虽然能够很好的确保数据一致性，但性能非常低。</p><p>第二种是<strong>投票</strong>，投票的话，多个人可以同时去做一件决策，或者同时去修改数据，但最终谁修改成功，是用投票来决定的。这个方式很高效，但它也会产生很多问题，比如网络中断、欺诈等等。想要通过投票达到一致性非常复杂，往往需要严格的数学理论来证明，还需要中间有一些“信使”不断来来回回传递消息，这中间也会有一些性能的开销。 我们在分布式系统中常见的Paxos和Raft算法，就是使用投票来解决一致性问题的。感兴趣的同学可以看看这两篇关于这两个算法的文章。</p><ul><li><a href="https://yasinshaw.com/articles/33">分布式一致性算法：Raft</a></li><li><a href="https://yasinshaw.com/articles/32">分布式一致性算法：Paxos</a></li></ul><p>第三种是<strong>避免</strong>。既然保证数据一致性很难，那我能不能通 过一些手段，去避免多个线程之间产生一致性问题呢？我们程序员熟悉的git就是这个实现，大家在本地分布式修改同一个文件，最后通过版本控制和“冲突解决”去解决这个问题。 而我们今天的正题，ThreadLocal，也是使用的“避免”这种方式</p><h4 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>ThreadLocal提供了<strong>线程局部变量</strong>，一个线程局部变量在多个线程中，分别有独立的值（副本）。</p><h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><p>下图能够比较直观地解释ThreadLocal的线程模型。</p><p><img src="/posts/60838/ThreadLocal.png" alt="ThreadLocal模型"></p><p>对于每一个线程来说，都有自己的独占数据。这些独占数据是进程来分配的，对于Java来说，独占数据很多都是在Thread类里面分配的，而每一个线程里面都有一个 ThreadLocalMap 的对象，它本身是一个哈希表，里面会放一些线程的局部变量（红色长方形）。ThreadLocal 的核心也是这个 ThreadLocalMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread类里的变量：</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// ThreadLocalMap的定义：</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h5><ul><li>构造函数 ThreadLocal()</li><li>初始化 initialValue()</li><li>访问器 get&#x2F;set</li><li>回收 remove</li></ul><p>构造函数是一个泛型的，传入的类型是你要使用的局部变量变量的类型。初始化<code>initialValue()</code> 用于如果你没有调用<code>set()</code>方法的时候，调用 <code>get()</code>方法返回的默认值。如果不重载初始化方法，会返回 <strong>null</strong>。 如果调用了<code>set()</code>方法，再调用<code>get()</code>方法，就不会调用<code>initialValue()</code>方法。 如果调用了<code>set()</code>，再调用<code>remove()</code>，再调用<code>get()</code>，是会调用<code>initialValue()</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;invoke initial value&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default value&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;first thread&quot;</span>);<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;second thread&quot;</span>);<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;third thread&quot;</span>);<br>            THREAD_LOCAL.remove();<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        SECONDS.sleep(<span class="hljs-number">1L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">first thread<br>second thread<br>invoke initial value<br><span class="hljs-keyword">default</span> value<br>invoke initial value<br><span class="hljs-keyword">default</span> value<br></code></pre></td></tr></table></figure><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><h6 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h6><p>ThreadLocalMap类 定义：</p><blockquote><p>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values. No operations are exported outside of the ThreadLocal class. The class is package private to allow declaration of fields &gt;in class Thread.<br>To help deal with very large and long-lived usages, the hash table entries useWeakReferences for keys. However, since &gt;reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p></blockquote><p>由上得知：</p><ol><li>ThreadLocalMap只会被 ThreadLocal 维护</li><li>Entry的key使用的是弱引用(WeakReferences)</li></ol><p>Entry 定义：</p><blockquote><p>The entries in this hash map extend WeakReference, using its main ref field as the key (which is always aThreadLocal object).<br>Note that null keys (i.e. entry.get()&#x3D;&#x3D; null) mean that the key is no longer referenced, so the entry can be expunged from table. Such entries are referred toas “stale entries” in the code that follows.</p></blockquote><p>由上得知：</p><ol><li>Entry的key 必须是 ThreadLocal 类型引用，并且是一个弱引用</li><li>如果 entry.get()&#x3D;&#x3D; null 意味着某Entry的key不再被引用(指向的对象已经被GC) ,所以此 entry 就可以从table 中回收，这时此 entry 在table 中被称为 stale entries</li></ol><p>弱引用(WeakReferences) :如果某个对象<strong>仅</strong>剩下弱引用指向它，那么下一次GC的时候该对象就会被回收掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>   <span class="hljs-comment">//ThreadLocalMap真正存数据的是Entry，且Entry的key使用的是弱引用(WeakReferences)</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>       <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>       Object value;<br><br>       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>           <span class="hljs-built_in">super</span>(k);<br>           value = v;<br>       &#125;<br><br><br>       <span class="hljs-comment">// ....省略</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>Thread、ThreadLocal、ThreadLocalMap、Entry 的关系 如下图所示：<img src="/posts/60838/ThreadLocal2.png" alt="ThreadLocal概念图"></p><h6 id="set-方法"><a href="#set-方法" class="headerlink" title="set() 方法"></a>set() 方法</h6><p>set(T value) 方法:<br>先拿到当前的线程，然后通过它去拿到一个Map，如果这个Map存在，就把value塞进去，否则就创建一个新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#set</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//拿到当前的线程</span><br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);     <span class="hljs-comment">//根据当前的线程拿到ThreadLocalMap</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">//如果map不为空就set value</span><br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            createMap(t, value);            <span class="hljs-comment">//否则创建一个新的ThreadLocalMap，并且set value</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>getMap(Thread t):<br>返回当前线程的 threadLocals参数， 每个线程对应一个自己线程私有的ThreadLocalMap，它被Thread对象持有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#getMap</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-comment">//java.lang.Thread </span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>createMap(Thread t, T firstValue) 方法： 创建一个新的ThreadLocalMap对象，并赋值给当前线程对象。ThreadLocalMap的 key 是当前 ThreadLocal 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#createMap      //创建一个新的ThreadLocalMap对象，赋值给当前线程对象</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//由此得知，ThreadLocalMap的 key 是当前 ThreadLocal 对象 value 是 set()方法传入的值</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="get-方法："><a href="#get-方法：" class="headerlink" title="get() 方法："></a>get() 方法：</h6><p>先通过 getMap(Thread t) 方法拿到当前线程对应的Map，然后从里面取出value。如果没有value，就调用ThreadLocal提供的初始化方法，初始化一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#get</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();                     <span class="hljs-comment">//获得当前线程</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);                        <span class="hljs-comment">//获取当前线程的ThreadLocalMap 对象</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                                    <span class="hljs-comment">//当前线程的ThreadLocalMap 对象 不为空</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);     <span class="hljs-comment">//从当前的ThreadLocalMap 对象中取出 key为当前 ThreadLocal 对象的 Entry</span><br>           <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;                        <br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();                            <span class="hljs-comment">//当前线程的ThreadLocalMap 对象 为空返回初始值        </span><br>&#125;<br></code></pre></td></tr></table></figure><p>setInitialValue() 方法：<br>通过 initialValue() 获得初始值，将初始值赋值给当前线程的ThreadLocalMap 对象，以当前ThreadLocal对象为key ,以初始值为value。 返回该值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#setInitialValue</span><br> <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            createMap(t, value);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h6><p>remove()方法不得不提。首先我们思考一下，既然已经有了弱引用，按理说，如果线程没有持有某个value的时候，会在GC的时候自动清理掉对应的Entry，为什么会有remove()方法存在？<br>因为我们在开发一个多线程的程序时，往往会使用线程池。而线程池的功能就是线程的复用。那如果线程池和ThreadLocal在一起就可能会造成一个问题：</p><ul><li>job A和job B共用了同一个线程，</li><li>job A使用完ThreadLocal，ThreadLocal里面还有job A保存的值，而这个时候可能还没有清理掉，</li><li>job B复用线程进来了，取出来是 job A的值，可能就会造成问题。</li></ul><p>所以在有必要的时候，可以在使用完ThreadLocal的时候，显式调用一下remove()方法。remove()方法的源码也比较简单，就是调用对应的 entry 的 clear()方法。 同时,remove() 方法也能很好的避免内存泄露问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#remove</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//java.lang.ThreadLocal#remove</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear(); <span class="hljs-comment">//删除entry</span><br>            expungeStaleEntry(i); <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用ThreadLocal的注意事项"><a href="#使用ThreadLocal的注意事项" class="headerlink" title="使用ThreadLocal的注意事项"></a>使用ThreadLocal的注意事项</h4><h5 id="ThreadLocal-内存泄露"><a href="#ThreadLocal-内存泄露" class="headerlink" title="ThreadLocal 内存泄露"></a>ThreadLocal 内存泄露</h5><h6 id="ThreadLocal-为什么会内存泄露"><a href="#ThreadLocal-为什么会内存泄露" class="headerlink" title="ThreadLocal 为什么会内存泄露"></a>ThreadLocal 为什么会内存泄露</h6><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        executorService.execute(() -&gt; &#123;<br>            ThreadLocal&lt;RedSpider&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>            <span class="hljs-type">RedSpider</span> <span class="hljs-variable">redSpider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedSpider</span>();<br>            threadLocal.set(redSpider);<br>            <span class="hljs-comment">//threadLocal=null          //将threadLocal 引用赋值为空</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码逻辑图如下:<img src="/posts/60838/5.png" alt="实例代码逻辑图.png"></p><p>我们在前面介绍ThreadLocalMap时已知：ThreadLocalMap中，Entry的key为 WeakReference，当我们给 threadLocal&#x3D;null 时，逻辑图中 强引用 ② 会消失，这样 ThreadLocal对象实例只有一个 Entry中的 key 的一个 弱引用③。因为弱引用的性质，在下一次 GC 时就会回收 ThreadLocal对象实例。这时逻辑图中的引用只剩下 强引用① 和 强引用④ 。如果当前线程迟迟不断掉的话就会一直存在一条强引用链：thread(ref)-&gt;Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;redSpider(ref) 。所以ThreadLocal 内存泄露的原因也就找到了：</p><ol><li>堆中有一个强引用指向 RedSpider对象实例，该实例没法被 GC。</li><li>因为 Entry 的 key 为null ,所以没有任何途径能够接触到redSpider(ref)，因此也不能访问到 RedSpider对象实例。</li></ol><h6 id="ThreadLocal-解决方法"><a href="#ThreadLocal-解决方法" class="headerlink" title="ThreadLocal 解决方法"></a>ThreadLocal 解决方法</h6><p>由上图 源码解析中： <code>remove()</code>方法 中调用了一个<code>expungeStaleEntry()</code> 方法，这个方法是解决问题的关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// staleSlot index of slot known to have null key; </span><br><span class="hljs-comment">// java.lang.ThreadLocal.ThreadLocalMap#expungeStaleEntry</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// ...(省略)</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<code>staleSlot</code> index of slot known to have null key; 该方法的逻辑：</p><ul><li>将entry里值的强引用(强引用④)置为null(这样值对象就对被GC回收)。</li><li>将entry对应引用(弱引用③)置为null(这样Entry就能被GC回收)。</li></ul><p>这样逻辑图中只剩下<code>强引用①</code> 和<code>强引用③</code> ,这样<code>RedSpider对象实例</code> 和对应的 <code>Entry</code> 实例就可以被回收掉了。<br>因此，只要调用了<code>expungeStaleEntry()</code> 就能将无用 Entry 回收清除掉。<br>ThreadLocalMap 中 <code>get()</code>方法 ，<code>set()</code>方法，间接的调用了该方法。<code>remove()</code>方法直接调用了该方法，以下为expungeStaleEntry() 方法的调用链。</p><p><img src="/posts/60838/expungeStaleEntry.png" alt="类图"></p><p>综上所述：针对ThreadLocal 内存泄露的原因，我们可以从两方面去考虑：</p><ol><li>删除无用 Entry 对象，断掉指向ThreadLocal实例的弱引用。即 用完ThreadLocal后手动调用remove()方法。</li><li>可以让ThreadLocal 的强引用一直存在，保证任何时候都可以通过 ThreadLocal 的弱引用访问到 Entry的 value值。即 将ThreadLocal 变量定义为 private static</li></ol><h5 id="ThreadLocal-父子线程传值"><a href="#ThreadLocal-父子线程传值" class="headerlink" title="ThreadLocal 父子线程传值"></a>ThreadLocal 父子线程传值</h5><h6 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h6><p>5.5.4章节中我们简单介绍了一下 InheritableThreadLocal。下面来看看 InheritableThreadLocal是如何使用的。 示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            InheritableThreadLocal&lt;String&gt; itl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();  ①<br>            itl.set(<span class="hljs-string">&quot;InheritableThreadLocal&quot;</span>);<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> itl.get();<br>                <span class="hljs-comment">//拿到父线程放进去的“InheritableThreadLocal”，因为tl是InheritableThreadLocal</span><br>                System.out.println(str);<br>            &#125;);<br>            b.start();<br><br>            <span class="hljs-comment">//确保子线程b执行完毕 </span><br>            Thread.sleep(<span class="hljs-number">10</span>);<br><br>            itl.remove();<br>        &#125;);<br>        a.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>InheritableThreadLocal<br><span class="hljs-comment">//如果 ① 处定义的是 ThreadLocal 执行结果则为 </span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>可以看到使用了 InheritableThreadLocal 后，子线程b 获取到了父线程a set 的值。</p><p>原理： 首先我们看ThreadLocal 类的 <code>set(T value)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#set      </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);     <span class="hljs-comment">//如果map为空，调用createMap 方法</span><br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocal#createMap  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal 类给当前线程的threadLocals变量赋值</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue); <br>&#125;<br><br><span class="hljs-comment">//java.lang.InheritableThreadLocal#createMap </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//InheritableThreadLocal的 inheritableThreadLocals 变量赋值</span><br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue); <br>&#125;<br><br><span class="hljs-comment">//与此线程有关的 ThreadLocal 值，由ThreadLocal 类维护</span><br><span class="hljs-comment">//java.lang.Thread</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//与此线程有关的 InheritableThreadLocal 值，由InheritableThreadLocal 类维护</span><br><span class="hljs-comment">//java.lang.Thread</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>可以看到 当我们调用 <code>set()</code> 方法时，如果声明的是 InheritableThreadLocal 类时，会给当前线程的 inheritableThreadLocals 变量赋值。<br>在Thread 类中只有两处使用到 <code>inheritableThreadLocals</code> 变量。分别是 <code>init()</code>方法和 <code>exit()</code>方法。<code>exit()</code> 方法是给当前线程的一写变量赋值为null，这里不做过多阐述。<code>init()</code>方法是什么？通过查看调用该方法的地方可以看到，Thread 类的所有构造函数都调用了init() 方法。即当我们新建一个线程时，就会调用<code>init()</code> 方法，并给线程的inheritableThreadLocals 变量赋值。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.Thread#init</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><br><span class="hljs-params">                  <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;<br>       <span class="hljs-comment">//省略 ...</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();             <span class="hljs-comment">//这里的parent指的是调用init()方法的线程，即所谓的父线程</span><br>    <span class="hljs-comment">//省略 ...</span><br>    <span class="hljs-comment">//如果inheritThreadLocals 为ture 并且当前线程的inheritableThreadLocals变量不为空</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);  <span class="hljs-comment">//这里传入的是当前线程的 inheritableThreadLocals 变量</span><br>       <span class="hljs-comment">//省略 ...</span><br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocal#createInheritedMap</span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);<br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocalMap Constructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>        <span class="hljs-comment">//父线程 Entry</span><br>        Entry[] parentTable = parentMap.table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>        setThreshold(len);<br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br>        <span class="hljs-comment">//每个Entry都赋值到子线程的Entry</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>                <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//关键的一行 e.value是父线程Entry中的值,childValue()是一个可重载的方法,</span><br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);<br>                    <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>                        h = nextIndex(h, len);<br>                    table[h] = c;<br>                    size++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//java.lang.ThreadLocal#childValue</span><br>T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-comment">//java.lang.InheritableThreadLocal#childValue 对于 InheritableThreadLocal 来说，返回了传入的值。</span><br> <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>    <span class="hljs-keyword">return</span> parentValue;                  <br>&#125;<br></code></pre></td></tr></table></figure><p>当我们再调用 <code>get()</code> 方法获取时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#get</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);     <span class="hljs-comment">//InheritableThreadLocal 对象调用getMap()方法时，会返回当前线程的inheritableThreadLocals 变量</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>); <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><span class="hljs-comment">//java.lang.InheritableThreadLocal#getMap</span><br> ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>   <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上可得：当我们使用 InheritableThreadLocal 时，当前线程的数据会存储在 inheritableThreadLocals变量赋值，将数据存储在inheritableThreadLocals 指向的 ThreadLocalMap 中。当新建一个子线程时，会将当前线程的 inheritableThreadLocals里的 ThreadLocalMap 赋值给 子线程的 inheritableThreadLocals 变量。然后子线程 通过调用InheritableThreadLocal 对象的 <code>get()</code> 方法可以得到相应的值。</p><h6 id="InheritableThreadLocal-无法向线程池中的子线程传递数据"><a href="#InheritableThreadLocal-无法向线程池中的子线程传递数据" class="headerlink" title="InheritableThreadLocal 无法向线程池中的子线程传递数据"></a>InheritableThreadLocal 无法向线程池中的子线程传递数据</h6><p>平常我们开发时很少新建线程来并发编程，一般都是使用线程池。但是 InheritableThreadLocal 无法向线程池中的子线程传递数据 示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        InheritableThreadLocal&lt;String&gt; itl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>        itl.set(<span class="hljs-string">&quot;first&quot;</span>);<br>        executorService.execute(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">firstValue</span> <span class="hljs-operator">=</span> itl.get();<br>            System.out.println(firstValue);<br>        &#125;);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        itl.remove();<br><br>        itl.set(<span class="hljs-string">&quot;second&quot;</span>);<br>        executorService.execute(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">secondValue</span> <span class="hljs-operator">=</span> itl.get();<br>            System.out.println(secondValue);<br>        &#125;);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        itl.remove();<br>    &#125;<br>&#125;<br><br>执行结果：<br>first<br>first<br></code></pre></td></tr></table></figure><p>我们预期得到的结果是 first second，然而现在输出的却是 first first。说明我们 InheritableThreadLocal 对象第二次调用 set()方法失效。 在上面原理中讲过，Thread 对象的 inheritableThreadLocals 变量只有在新建线程时会从父线程的inheritableThreadLocals 变量中拷贝过来。所以后续阶段，没有能使 子线程的inheritableThreadLocals变量变化的地方，所以第二次调用 <code>get()</code>方法输出的还是 first。在线程池中，由于线程复用所以我们也不能通过 InheritableThreadLocal 类来传递值。关于线程池线程复用，详见 12.2.4 ThreadPoolExecutor如何做到线程复用的？ alibaba 提供了 <strong>transmittable-thread-local</strong> 框架来解决了 在使用线程池等会池化复用线程的执行组件情况下传递ThreadLocal值问题。</p><h6 id="transmittable-thread-local"><a href="#transmittable-thread-local" class="headerlink" title="transmittable-thread-local"></a>transmittable-thread-local</h6><p>对于 <strong>transmittable-thread-local</strong> 我们不做过多阐述，只介绍核心思想。 由上文可知：InheritableThreadLocal 是在创建线程时将父类线程赋值到Thread的 inheritableThreadLocals 变量中，当子线程调用对应的get方法时读取inheritableThreadLocals 变量，这样就完成了父子线程之间变量的传递，但是由于我们使用线程池提交任务的时候并非总是新建一个线程来执行任务，这导致InheritableThreadLocal 的工作原理不适用于 线程池。但我们思考一下，InheritableThreadLocal 是父线程创建子线程的时候将值传递，每创建一下新线程都会在 init()方法中进行操作，而我们使用线程池的时候，有那些操作是这种“新建” 的呢？ 没错，线程池每次提交的任务 Runnable对象 就是一个新的，不会重复的。所以我们新建一个类实现Runnable接口，然后将父线程得知封装在我们新建的类中。</p><p>请看示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 在父线程中设置</span><br>        context.set(<span class="hljs-string">&quot;first&quot;</span>);<br>        <span class="hljs-comment">//创建runnable 对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">firstRunnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">firstValue</span> <span class="hljs-operator">=</span> context.get();<br>            System.out.println(firstValue);<br>        &#125;;<br>        <span class="hljs-comment">//封装为TtlRunnable对象</span><br>        <span class="hljs-type">TtlRunnable</span> <span class="hljs-variable">firstTtlRunnable</span> <span class="hljs-operator">=</span> TtlRunnable.get(firstRunnable);<br>        <span class="hljs-comment">//提交任务</span><br>        executorService.execute(firstTtlRunnable);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br><br>        context.set(<span class="hljs-string">&quot;second&quot;</span>);<br>        <span class="hljs-comment">//创建runnable 对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">secondRunnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">secondValue</span> <span class="hljs-operator">=</span> context.get();<br>            System.out.println(secondValue);<br>        &#125;;<br>        <span class="hljs-comment">//封装为TtlRunnable对象</span><br>        <span class="hljs-type">TtlRunnable</span> <span class="hljs-variable">secondTtlRunnable</span> <span class="hljs-operator">=</span> TtlRunnable.get(secondRunnable);<br>        <span class="hljs-comment">//提交任务</span><br>        executorService.execute(secondTtlRunnable);<br><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        context.remove();<br><br>    &#125;<br>&#125;<br><br><br>输出结果：<br>first<br>second<br></code></pre></td></tr></table></figure><p>由此可见，使用TransmittableThreadLocal，将 Runnable 封装成 TtlRunnable 对象完成了线程池中父子线程中值的传递。</p><p>首先我们先看看TransmittableThreadLocal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TtlCopier</span>&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>可以看到 TransmittableThreadLocal类 继承了 InheritableThreadLocal。 然后我们来看看相关方法：<br>set()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com.alibaba.ttl.TransmittableThreadLocal#set</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!disableIgnoreNullValueSemantics &amp;&amp; <span class="hljs-literal">null</span> == value) &#123;<br>        <span class="hljs-comment">// may set null to remove value</span><br>        remove();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//赋值,将value赋值给Thread的 inheritableThreadLocals 变量</span><br>        <span class="hljs-built_in">super</span>.set(value);<br>        <span class="hljs-comment">//将当前对象塞到 TransmittableThreadLocal类 的holder 变量中</span><br>        addThisToHolder();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//java.lang.ThradLocal#set</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//调用的是InheritableThreadLocal的getMap()方法</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t); <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//调用的是InheritableThreadLocal的createMap()方法</span><br>        createMap(t, value);<br>&#125;<br><span class="hljs-comment">//java.lang.InheritableThreadLocal#getMap</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>   <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br><span class="hljs-comment">////java.lang.InheritableThreadLocal#createMap</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br><br><span class="hljs-comment">//com.alibaba.ttl.TransmittableThreadLocal#addThisToHolder</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThisToHolder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!holder.get().containsKey(<span class="hljs-built_in">this</span>)) &#123;<br>        holder.get().put((TransmittableThreadLocal&lt;Object&gt;) <span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// WeakHashMap supports null value.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可知，调用TransmittableThreadLocal 的<code>set(T value)</code>方法会将value 赋值给Thread(调用线程) 的inheritableThreadLocals 变量。然后将当前 TransmittableThreadLocal 对象存了起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Note about the holder:</span><br><span class="hljs-comment">// 1. holder self is a InheritableThreadLocal(a *ThreadLocal*).</span><br><span class="hljs-comment">// 2. The type of value in the holder is WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;.</span><br><span class="hljs-comment">//    2.1 but the WeakHashMap is used as a *Set*:</span><br><span class="hljs-comment">//        the value of WeakHashMap is *always* null, and never used.</span><br><span class="hljs-comment">//    2.2 WeakHashMap support *null* value.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);<br>            &#125;<br>        &#125;;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h4><h5 id="资源持有"><a href="#资源持有" class="headerlink" title="资源持有"></a>资源持有</h5><p>比如我们有三个不同的类。在一次Web请求中，会在不同的地方，不同的时候，调用这三个类的实例。但用户是同一个，用户数据可以保存在<strong>一个线程</strong>里。<img src="/posts/60838/6.png" alt="线程资源持有">这个时候，我们可以在程序1把用户数据放进ThreadLocalMap里，然后在程序2和程序3里面去用它。 这样做的优势在于：持有线程资源供线程的各个部分使用，全局获取，降低<strong>编程难度</strong>。</p><h5 id="线程一致"><a href="#线程一致" class="headerlink" title="线程一致"></a>线程一致</h5><p>这里以JDBC为例。我们经常会用到事务，它是怎么实现的呢？</p><p><img src="/posts/60838/7.png" alt="线程资源一致性"></p><p>原来，我们每次对数据库操作，都会走JDBC getConnection，JDBC保证只要你是同一个线程过来的请求，不管是在哪个part，都返回的是同一个连接。这个就是使用ThreadLocal来做的。 当一个part过来的时候，JDBC会去看ThreadLocal里是不是已经有这个线程的连接了，如果有，就直接返回；如果没有，就从连接池请求分配一个连接，然后放进ThreadLocal里。 这样就可以保证一个事务的所有part都在一个连接里。TheadLocal可以帮助它维护这种一致性，降低<strong>编程难度</strong>。</p><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>假设我们一个线程的调用链路比较长。在中途中出现异常怎么做？我们可以在出错的时候，把错误信息放到ThreadLocal里面，然后在后续的链路去使用这个值。使用TheadLocal可以保证多个线程在处理这个场景的时候保证线程安全。</p><p><img src="/posts/60838/8.png" alt="线程安全"></p><h5 id="并发计算"><a href="#并发计算" class="headerlink" title="并发计算"></a>并发计算</h5><p>如果我们有一个大的任务，可以把它拆分成很多小任务，分别计算，然后最终把结果汇总起来。如果是分布式计算，可能是先存储在自己的节点里。而如果是单机下的多线程计算，可以把每个线程的计算结果放进ThreadLocal里面，最后取出来汇总。</p><p><img src="/posts/60838/9.png" alt="分布式计算"></p><h4 id="ThreadLocal-在一些开源框架中的应用"><a href="#ThreadLocal-在一些开源框架中的应用" class="headerlink" title="ThreadLocal 在一些开源框架中的应用"></a>ThreadLocal 在一些开源框架中的应用</h4><h5 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h5><p>Quartz是一个非常知名的开源任务调度系统。以 <code>2.3.2</code>版本为例 我们要看的源码是Quartz的<strong>SimpleSemaphore</strong>这个类。它是一个信号量的实现，在生产者-消费者模型里，信号量代表的就是队列里有多少item需要处理。 在信号量的模型里面有一个“等待”操作。当消费者消费完后，会轮询等待。<strong>SimpleSemaphore</strong>有一个获取锁的方法<code>**obtainLock()**</code>，我们要看的也是这个方法的内部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSemaphore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Semaphore</span> &#123;<br>ThreadLocal&lt;HashSet&lt;String&gt;&gt; lockOwners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HashSet&lt;String&gt;&gt;();<br><br>    HashSet&lt;String&gt; locks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><br>     <span class="hljs-keyword">private</span> HashSet&lt;String&gt; <span class="hljs-title function_">getThreadLocks</span><span class="hljs-params">()</span> &#123;<br>        HashSet&lt;String&gt; threadLocks = lockOwners.get();<br>        <span class="hljs-keyword">if</span> (threadLocks == <span class="hljs-literal">null</span>) &#123;<br>            threadLocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>            lockOwners.set(threadLocks);<br>        &#125;<br>        <span class="hljs-keyword">return</span> threadLocks;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Grants a lock on the identified resource to the calling thread (blocking</span><br><span class="hljs-comment">     * until it is available).</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if the lock was obtained.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">obtainLock</span><span class="hljs-params">(Connection conn, String lockName)</span> &#123;<br><br>        lockName = lockName.intern();<br><br>        <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>            log.debug(<br>                <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; is desired by: &quot;</span><br>                        + Thread.currentThread().getName());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!isLockOwner(lockName)) &#123;<br>            <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                log.debug(<br>                    <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; is being obtained: &quot;</span><br>                            + Thread.currentThread().getName());<br>            &#125;<br>            <span class="hljs-keyword">while</span> (locks.contains(lockName)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                    <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                        log.debug(<br>                            <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; was not obtained by: &quot;</span><br>                                    + Thread.currentThread().getName());<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                log.debug(<br>                    <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; given to: &quot;</span><br>                            + Thread.currentThread().getName());<br>            &#125;<br>            getThreadLocks().add(lockName);<br>            locks.add(lockName);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>            log.debug(<br>                <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; already owned by: &quot;</span><br>                        + Thread.currentThread().getName()<br>                        + <span class="hljs-string">&quot; -- but not owner!&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;stack-trace of wrongful returner&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>36行的while循环就是去进行轮询操作，while里面的locks是一个<strong>HashSet</strong>，为true代表这个lockName对应的锁正在被别的线程持有，所以当前线程需要等待。 我们看到，在while循环的外层30行，有一个判断，其实是用到了ThreadLocal。这个外层的判断起什么作用呢？其实是<strong>判断当前线程是否已经持有了这个锁</strong>。如果持有了，那就直接跳到最后return true了。因为同一个线程，可能有多个程序片段会调用这个获取锁的方法。 可以看到，使用ThreadLocal可以非常高效地判断当前线程的状态，可以快速检测出当前线程是否已经获取了锁，避免了后续锁的检测和争用。</p><h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h5><p>Mybatis不用多说，搞Java的应该都听过或者用过。我们今天要介绍的是它的SqlSessionManager。Mybatis是一个持久化框架。持久化框架，必然会面临事务的问题。我们的数据库（比如MySQL）可以保证本地事务，但也要求必须在同一个连接才行。 应用程序使用MyBatis，可能会在多个程序片段去访问数据库，做一些增删改查的操作。它们可能需要在同一个事务里面。举个例子，我们修改完订单状态后，可能还需要修改积分，它们应该在同一个事务里。Mybatis使用SqlSessionManager保证了我们同一个线程取出来的连接总是同一个。它是如何做到的呢？其实很简单，就是内部使用了一个ThreadLocal。然后所有的创建连接、取连接都是通过这个ThreadLocal变量的get&#x2F;set方法进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlSessionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSessionFactory</span>, SqlSession &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">// 创建连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startManagedSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.localSqlSession.set(openSession());<br>    &#125;<br><br>    <span class="hljs-comment">// 取连接</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> localSqlSession.get();<br>        <span class="hljs-keyword">if</span> (sqlSession == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionException</span>(<span class="hljs-string">&quot;Error:  Cannot get connection.  No managed session is started.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSession.getConnection();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocal-扩展"><a href="#ThreadLocal-扩展" class="headerlink" title="ThreadLocal 扩展"></a>ThreadLocal 扩展</h4><p><code>Netty</code> 中的<code>FastThreadLocal</code> 和 <code>Dubbo</code> 中的<code>InternalThreadLocal</code> 都对JDK的 <code>ThreadLocal</code> 进行了增强， 本文不做过多阐述</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程（二）</title>
    <link href="/posts/57823.html"/>
    <url>/posts/57823.html</url>
    
    <content type="html"><![CDATA[<p>Java 并发编程原理是指 Java 程序在多线程环境下的工作原理和机制。理解Java并发原理对于编写高效、线程安全的并发程序至关重要</p><span id="more"></span><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h4><ul><li>线程间如何通信？即：线程之间以何种机制来交换信息</li><li>线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序</li></ul><p>有两种并发模型可以解决这两个问题：</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><p>这两种模型之间的区别如下表所示：</p><p><img src="/posts/57823/1.png" alt="两种并发模型的比较"></p><p><strong>在Java中，使用的是共享内存并发模型</strong>。</p><h4 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h4><h5 id="运行时内存的划分"><a href="#运行时内存的划分" class="headerlink" title="运行时内存的划分"></a>运行时内存的划分</h5><p>先谈一下运行时数据区，下面这张图相信大家一点都不陌生：<img src="/posts/57823/2.png" alt="Java运行时数据区域"></p><p>对于每一个线程来说，栈都是私有的，而堆是共有的。</p><p>也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。</p><p>所以，内存可见性是针对的<strong>共享变量</strong>。</p><h5 id="既然堆是共享的，为什么在堆中会有内存不可见问题？"><a href="#既然堆是共享的，为什么在堆中会有内存不可见问题？" class="headerlink" title="既然堆是共享的，为什么在堆中会有内存不可见问题？"></a>既然堆是共享的，为什么在堆中会有内存不可见问题？</h5><p>这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。</p><blockquote><p>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p></blockquote><p>Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示：</p><p><img src="/posts/57823/3.jpg" alt="JMM抽象示意图"></p><p>从图中可以看出：</p><ol><li>所有的共享变量都存在主内存中。</li><li>每个线程都保存了一份该线程使用到的共享变量的副本。</li><li>如果线程A与线程B之间要通信的话，必须经历下面2个步骤：<ol><li>线程A将本地内存A中更新过的共享变量刷新到主内存中去。</li><li>线程B到主内存中去读取线程A之前已经更新过的共享变量。</li></ol></li></ol><p><strong>所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。</strong></p><p>注意，根据JMM的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取</strong>。</p><p>所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。</p><p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是JMM的功劳了，也是JMM存在的必要性之一。<strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p><blockquote><p>Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。这里涉及到的所有内容后面都会有专门的章节介绍。</p></blockquote><h5 id="JMM与Java内存区域划分的区别与联系"><a href="#JMM与Java内存区域划分的区别与联系" class="headerlink" title="JMM与Java内存区域划分的区别与联系"></a>JMM与Java内存区域划分的区别与联系</h5><p>上面两小节分别提到了JMM和Java运行时内存区域的划分，这两者既有差别又有联系：</p><ul><li><p>区别</p><p>两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。</p></li><li><p>联系</p><p>都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p></li></ul><p><strong>实际上，他们表达的是同一种含义，这里不做区分</strong></p><h3 id="重排序与-happens-before"><a href="#重排序与-happens-before" class="headerlink" title="重排序与 happens-before"></a>重排序与 happens-before</h3><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p><p><strong>为什么指令重排序可以提高性能？</strong></p><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p><p>但是，流水线技术最害怕<strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p><p>我们分析一下下面这个代码的执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">a = b + c;<br>d = e - f ;<br></code></pre></td></tr></table></figure><p>先加载b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p><p>为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。</p><p>综上所述，<strong>指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</strong></p><p>指令重排一般分为以下三种：</p><ul><li><p><strong>编译器优化重排</strong></p><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令并行重排</strong></p><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p></li><li><p><strong>内存系统重排</strong></p><p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p></li></ul><p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p><h4 id="顺序一致性模型与JMM的保证"><a href="#顺序一致性模型与JMM的保证" class="headerlink" title="顺序一致性模型与JMM的保证"></a>顺序一致性模型与JMM的保证</h4><p>顺序一致性模型是一个<strong>理论参考模型</strong>，内存模型在设计的时候都会以顺序一致性内存模型作为参考。</p><h5 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h5><p>当程序未正确同步的时候，就可能存在数据竞争。</p><blockquote><p>数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。</p></blockquote><p>如果程序中包含了数据竞争，那么运行的结果往往充满了<strong>不确定性</strong>，比如读发生在了写之前，可能就会读到错误的值；如果一个线程程序能够正确同步，那么就不存在数据竞争。</p><p>Java内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：</p><blockquote><p><strong>如果程序是正确同步的，程序的执行将具有顺序一致性</strong>。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。</p></blockquote><p>这里的同步包括了使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>等关键字来实现<strong>多线程下的同步</strong>。</p><p>如果程序员没有正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，那么即便是使用了同步（单线程下的同步），JMM也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。</p><p>所以如何正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，是程序员应该去了解的。后面会有专门的章节介绍这几个关键字的内存语义及使用。</p><h5 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h5><p>顺序一致性内存模型是一个<strong>理想化的理论参考模型</strong>，它为程序员提供了极强的内存可见性保证。</p><p>顺序一致性模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li></ul><p>为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-&gt;A2-&gt;A3，线程B也有3个操作，B1-&gt;B2-&gt;B3。</p><p>假设<strong>正确使用了同步</strong>，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在<strong>顺序一致性模型</strong>中的执行效果如下所示：</p><p><img src="/posts/57823/4.png" alt="正确同步图"></p><p>操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。</p><p>假设<strong>没有使用同步</strong>，那么在<strong>顺序一致性模型</strong>中的执行效果如下所示：</p><p><img src="/posts/57823/5.png" alt="没有正确同步图"></p><p>操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的<strong>每个操作必须立即对任意线程可见</strong>。</p><p><strong>但是JMM没有这样的保证。</strong></p><p>比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</p><h5 id="JMM中同步程序的顺序一致性效果"><a href="#JMM中同步程序的顺序一致性效果" class="headerlink" title="JMM中同步程序的顺序一致性效果"></a>JMM中同步程序的顺序一致性效果</h5><p>在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是JMM中，临界区内（同步块或同步方法中）的代码可以发生重排序（但不允许临界区内的代码“逃逸”到临界区之外，因为会破坏锁的内存语义）。</p><p>虽然线程A在临界区做了重排序，但是因为锁的特性，线程B无法观察到线程A在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>同时，JMM会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。</p><p><strong>由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门</strong>。</p><h5 id="JMM中未同步程序的顺序一致性效果"><a href="#JMM中未同步程序的顺序一致性效果" class="headerlink" title="JMM中未同步程序的顺序一致性效果"></a>JMM中未同步程序的顺序一致性效果</h5><p>对于未同步的多线程程序，JMM只提供<strong>最小安全性</strong>：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。</p><p>为了实现这个安全性，JVM在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。</p><p><strong>JMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。</strong></p><p>未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异：</p><ol><li>顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果）</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）</li><li>顺序一致性模型保证对所有的内存读写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性。</li></ol><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p><p>JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p><p>而对于程序员，JMM提供了<strong>happens-before规则</strong>（JSR-133规范），满足了程序员的需求——<strong>简单易懂，并且提供了足够强的内存可见性保证。</strong>换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。</p><p>JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。</p><p>happens-before关系的定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li><strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></li></ol><p>happens-before关系本质上和as-if-serial语义是一回事。</p><p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</p><p>总之，<strong>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</strong></p><h5 id="天然的happens-before关系"><a href="#天然的happens-before关系" class="headerlink" title="天然的happens-before关系"></a>天然的happens-before关系</h5><p>在Java中，有以下天然的happens-before关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</li><li>join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// A操作</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// B操作</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<span class="hljs-comment">// C 操作</span><br>System.out.println(sum);<br></code></pre></td></tr></table></figure><p>根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-meta prompt_">1&gt; </span>A happens-before B <br><span class="hljs-meta prompt_">2&gt; </span>B happens-before C <br><span class="hljs-meta prompt_">3&gt; </span>A happens-before C<br></code></pre></td></tr></table></figure><p>注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。</p><p>如果这里发生了重排序，这在视觉上违背了happens-before原则，但是JMM是允许这样的重排序的。</p><p>所以，我们只关心happens-before规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。</p><p>重排序有两类，JMM对这两类重排序有不同的策略：</p><ul><li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都禁止这种重排序。</li><li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h4><p>在介绍volatile之前，我们先回顾及介绍几个基本的概念。</p><h5 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h5><p>在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。</p><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p><h5 id="重排序-1"><a href="#重排序-1" class="headerlink" title="重排序"></a>重排序</h5><p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p><h5 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h5><p>是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。</p><h4 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h4><p>在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：</p><ul><li>保证变量的<strong>内存可见性</strong></li><li>禁止volatile变量与普通变量<strong>重排序</strong>（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）</li></ul><h5 id="内存可见性-1"><a href="#内存可见性-1" class="headerlink" title="内存可见性"></a>内存可见性</h5><p>以一段示例代码开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>; <span class="hljs-comment">// step 1</span><br>        flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// step 2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123; <span class="hljs-comment">// step 3</span><br>            System.out.println(a); <span class="hljs-comment">// step 4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码里，我们使用<code>volatile</code>关键字修饰了一个<code>boolean</code>类型的变量<code>flag</code>。</p><p>所谓内存可见性，指的是当一个线程对<code>volatile</code>修饰的变量进行<strong>写操作</strong>（比如step 2）时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对<code>volatile</code>修饰的变量进行<strong>读操作</strong>（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</p><blockquote><p>在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。</p></blockquote><p>假设在时间线上，线程A先执行方法<code>writer</code>方法，线程B后执行<code>reader</code>方法。那必然会有下图：</p><p><img src="/posts/57823/volatile.jpg" alt="volatile内存示意图"></p><p>而如果<code>flag</code>变量<strong>没有</strong>用<code>volatile</code>修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值<code>a = 0，flag = false</code>。</p><h5 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h5><p>在 JSR-133 之前的旧的 Java 内存模型中，是允许 volatile 变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p><ol><li>线程A写volatile变量，step 2，设置flag为true；</li><li>线程B读同一个volatile，step 3，读取到flag为true；</li><li>线程B读普通变量，step 4，读取到 a &#x3D; 0；</li><li>线程A修改普通变量，step 1，设置 a &#x3D; 1；</li></ol><p>可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p><p>所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的<strong>线程间的通信机制</strong>，<strong>JSR-133</strong>专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p><p>编译器还好说，JVM是怎么还能限制处理器的重排序的呢？它是通过<strong>内存屏障</strong>来实现的。</p><p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li></ol><blockquote><p>注意这里的缓存主要指的是CPU缓存，如L1，L2等</p></blockquote><p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：</p><ul><li>在每个volatile写操作前插入一个StoreStore屏障；</li><li>在每个volatile写操作后插入一个StoreLoad屏障；</li><li>在每个volatile读操作后插入一个LoadLoad屏障；</li><li>在每个volatile读操作后再插入一个LoadStore屏障。</li></ul><p>大概示意图是这个样子：</p><p><img src="/posts/57823/6.png" alt="内存屏障"></p><blockquote><p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p><p><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会把Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p></blockquote><p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p><blockquote><p>第一个volatile读;</p><p>LoadLoad屏障；</p><p>第二个volatile读；</p><p>LoadStore屏障</p></blockquote><p>再介绍一下volatile与普通变量的重排序规则:</p><ol><li>如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序；</li><li>如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序；</li><li>如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。</li></ol><p>举个例子，我们在案例中step 1，是普通变量的写，step 2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。而step 3是volatile变量读，step 4是普通变量读，符合第1个规则，同样不能重排序。</p><p>但如果是下列情况：第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 声明普通变量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 声明volatile变量</span><br><br><span class="hljs-comment">// 以下两个变量的读操作是可以重排序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">// 普通变量读</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> flag; <span class="hljs-comment">// volatile变量读</span><br></code></pre></td></tr></table></figure><h4 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h4><p>从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。</p><p>在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读&#x2F;写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比volatile更强大；在性能上，volatile更有优势</strong>。</p><p>在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">// 不使用volatile关键字</span><br><br>    <span class="hljs-comment">// 双重锁检验</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第7行</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 第10行</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 第10行</span><br><br><span class="hljs-comment">// 可以分解为以下三个步骤</span><br><span class="hljs-number">1</span> memory=allocate();<span class="hljs-comment">// 分配内存 相当于c的malloc</span><br><span class="hljs-number">2</span> ctorInstanc(memory) <span class="hljs-comment">//初始化对象</span><br><span class="hljs-number">3</span> s=memory <span class="hljs-comment">//设置s指向刚分配的地址</span><br><br><span class="hljs-comment">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span><br><span class="hljs-number">1</span> memory=allocate();<span class="hljs-comment">// 分配内存 相当于c的malloc</span><br><span class="hljs-number">3</span> s=memory <span class="hljs-comment">//设置s指向刚分配的地址</span><br><span class="hljs-number">2</span> ctorInstanc(memory) <span class="hljs-comment">//初始化对象</span><br></code></pre></td></tr></table></figure><p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p><p>所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的</p><h3 id="Synchronized-与锁"><a href="#Synchronized-与锁" class="headerlink" title="Synchronized 与锁"></a>Synchronized 与锁</h3><p>首先需要明确的一点是：<strong>Java多线程的锁都是基于对象的</strong>，Java中的每一个对象都可以作为一个锁</p><p>还有一点需要注意的是，我们常听到的<strong>类锁</strong>其实也是对象锁</p><p>Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>说到锁，我们通常会谈到 <code>synchronized</code> 这个关键字。它翻译成中文就是“同步”的意思</p><p>我们通常使用 <code>synchronized </code>关键字来给一段代码或一个方法上锁。它通常有以下三种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键字在实例方法上，锁为当前实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在静态方法上，锁为当前Class对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">classLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在代码块上，锁为括号里面的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里介绍一下“临界区”的概念。所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果<code>synchronized</code>关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。</p><p>通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键字在实例方法上，锁为当前实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在代码块上，锁为括号里面的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，下面这两个方法也应该是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键字在静态方法上，锁为当前Class对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">classLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在代码块上，锁为括号里面的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.getClass()) &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="几种锁"><a href="#几种锁" class="headerlink" title="几种锁"></a>几种锁</h4><p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。</p><p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p><blockquote><p>关于锁降级有两点说明：</p><p>1.不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的，文末有链接。</p><p>2.上面提到的Stop The World期间，以及安全点，这些知识是属于JVM的知识范畴，本文不做细讲。</p></blockquote><p>下面分别介绍这几种锁以及它们之间的升级。</p><h5 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h5><p>前面我们提到，Java的锁都是基于对象的。首先我们来看看一个对象的“锁”的信息是存放在什么地方的。</p><p>每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。对象头的内容如下表：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32&#x2F;64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32&#x2F;64bit</td><td>Array length</td><td>数组的长度（如果是数组）</td></tr></tbody></table><p>我们主要来看看Mark Word的格式：</p><table><thead><tr><th>锁状态</th><th>29 bit 或 61 bit</th><th>1 bit 是否是偏向锁？</th><th>2 bit 锁标志位</th></tr></thead><tbody><tr><td>无锁</td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>此时这一位不用于标识偏向锁</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>此时这一位不用于标识偏向锁</td><td>10</td></tr><tr><td>GC标记</td><td></td><td>此时这一位不用于标识偏向锁</td><td>11</td></tr></tbody></table><p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>Hotspot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><blockquote><p>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁&#x2F;解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p></blockquote><h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h6><p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。</p><p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p><ul><li>成功，表示之前的线程不存在了， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><blockquote><p>CAS: Compare and Swap</p><p>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p></blockquote><p>线程竞争偏向锁的过程如下：</p><p><img src="/posts/57823/7.jpg" alt="img"></p><p>图中涉及到了lock record指针指向当前堆栈中的最近一个lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p><h6 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h6><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:UseBiasedLocking=<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>下面这个经典的图总结了偏向锁的获得和撤销：</p><p><img src="/posts/57823/8.png" alt="img"></p><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。</p><h6 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h6><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p><p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p><p>但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p><p><strong>轻量级锁的释放：</strong></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><p>一张图说明加锁和释放锁的过程：</p><p><img src="/posts/57823/9.png" alt="img"></p><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Contention</span> <span class="hljs-built_in">List</span>：所有请求锁的线程将被首先放置到该竞争队列<br><span class="hljs-variable">Entry</span> <span class="hljs-built_in">List</span>：<span class="hljs-variable">Contention</span> <span class="hljs-built_in">List</span>中那些有资格成为候选人的线程被移到<span class="hljs-variable">Entry</span> <span class="hljs-built_in">List</span><br><span class="hljs-variable">Wait</span> <span class="hljs-built_in">Set</span>：那些调用<span class="hljs-variable">wait</span>方法被阻塞的线程被放置到<span class="hljs-variable">Wait</span> <span class="hljs-built_in">Set</span><br><span class="hljs-variable">OnDeck</span>：任何时刻最多只能有一个线程正在竞争锁，该线程称为<span class="hljs-variable">OnDeck</span><br><span class="hljs-variable">Owner</span>：获得锁的线程称为<span class="hljs-variable">Owner</span><br><span class="hljs-operator">!</span><span class="hljs-variable">Owner</span>：释放锁的线程<br></code></pre></td></tr></table></figure><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到Contention List的队列的队首，然后调用<code>park</code>函数挂起当前线程。</p><p>当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。</p><p>如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><h5 id="总结锁的升级流程"><a href="#总结锁的升级流程" class="headerlink" title="总结锁的升级流程"></a>总结锁的升级流程</h5><p>每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><h5 id="各种锁的优缺点对比"><a href="#各种锁的优缺点对比" class="headerlink" title="各种锁的优缺点对比"></a>各种锁的优缺点对比</h5><p>下表来自《Java并发编程的艺术》：</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><h3 id="CAS-与原子操作"><a href="#CAS-与原子操作" class="headerlink" title="CAS 与原子操作"></a>CAS 与原子操作</h3><h4 id="乐观锁与悲观锁的概念"><a href="#乐观锁与悲观锁的概念" class="headerlink" title="乐观锁与悲观锁的概念"></a>乐观锁与悲观锁的概念</h4><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><p><strong>悲观锁：</strong></p><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p><strong>乐观锁：</strong></p><p>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说<strong>乐观锁天生免疫死锁</strong>。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><h4 id="CAS的概念"><a href="#CAS的概念" class="headerlink" title="CAS的概念"></a>CAS的概念</h4><p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p><p>所以这里的<strong>预期值E本质上指的是“旧值”</strong>。</p><p>我们以一个简单的例子来解释这个过程：</p><ol><li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li><li>我们使用CAS来做这个事情；</li><li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li><li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li></ol><p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p><p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p><p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p><p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p><h4 id="Java实现CAS的原理-Unsafe类"><a href="#Java实现CAS的原理-Unsafe类" class="headerlink" title="Java实现CAS的原理 - Unsafe类"></a>Java实现CAS的原理 - Unsafe类</h4><p>前面提到，CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。</p><p>在Java中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法，其中就有几个关于CAS的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,Object expected, Object x)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,<span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> x)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,<span class="hljs-type">long</span> expected,<span class="hljs-type">long</span> x)</span>;<br></code></pre></td></tr></table></figure><p>当然，他们都是<code>public native</code>的。</p><p>Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p><p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p><h4 id="原子操作-AtomicInteger类源码简析"><a href="#原子操作-AtomicInteger类源码简析" class="headerlink" title="原子操作-AtomicInteger类源码简析"></a>原子操作-AtomicInteger类源码简析</h4><p>上面介绍了Unsafe类的几个支持CAS的方法。那Java具体是如何使用这几个方法来实现原子操作的呢？</p><p>JDK提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。在JDK 11中，有如下17个类：</p><p><img src="/posts/57823/10.jpg" alt="原子类"></p><p>从名字就可以看得出来这些类大概的用途：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段（属性）</li></ul><p>这里我们以<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法为例，来看看Java是如何实现原子操作的。</p><p>先看看这个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-built_in">this</span>, VALUE, delta);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的U其实就是一个<code>Unsafe</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> jdk.internal.misc.<span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();<br></code></pre></td></tr></table></figure><p>所以其实<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法是调用<code>Unsafe</code>类的方法来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：这个方法是在JDK 1.8才新增的。在JDK1.8之前，<code>AtomicInteger</code>源码实现有所不同，是基于for死循环的，有兴趣的读者可以自行了解一下。</p></blockquote><p>我们来一步步解析这段源码。首先，对象<code>o</code>是<code>this</code>，也就是一个<code>AtomicInteger</code>对象。然后<code>offset</code>是一个常量<code>VALUE</code>。这个常量是在<code>AtomicInteger</code>类中声明的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">VALUE</span> <span class="hljs-operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure><p>同样是调用的<code>Unsafe</code>的方法。从方法名字上来看，是得到了一个对象字段偏移量。</p><blockquote><p>用于获取某个字段相对Java对象的“起始地址”的偏移量。</p><p>一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，</p><p>用这个方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</p></blockquote><p>继续看源码。前面我们讲到，CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。</p><p>这里声明了一个v，也就是要返回的值。从<code>getAndAddInt</code>来看，它返回的应该是原来的值，而新的值的<code>v + delta</code>。</p><p>这里使用的是<strong>do-while循环</strong>。这种循环不多见，它的目的是<strong>保证循环体内的语句至少会被执行一遍</strong>。这样才能保证return 的值<code>v</code>是我们期望的值。</p><p>循环体的条件是一个CAS方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">weakCompareAndSetInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,</span><br><span class="hljs-params">                                          <span class="hljs-type">int</span> expected,</span><br><span class="hljs-params">                                          <span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> compareAndSetInt(o, offset, expected, x);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,</span><br><span class="hljs-params">                                             <span class="hljs-type">int</span> expected,</span><br><span class="hljs-params">                                             <span class="hljs-type">int</span> x)</span>;<br></code></pre></td></tr></table></figure><p>可以看到，最终其实是调用的我们之前说到了CAS <code>native</code>方法。那为什么要经过一层<code>weakCompareAndSetInt</code>呢？从JDK源码上看不出来什么。在JDK 8及之前的版本，这两个方法是一样的。</p><blockquote><p>而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p></blockquote><p>根据本文第一篇参考文章（文末链接），它跟<code>volatile</code>有关。</p><p>简单来说，<code>weakCompareAndSet</code>操作仅保留了<code>volatile</code>自身变量的特性，而除去了happens-before规则带来的内存语义。也就是说，<code>weakCompareAndSet</code><strong>无法保证处理操作目标的volatile变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。</strong>这在一定程度上可以提高性能。</p><p>再回到循环条件上来，可以看到它是在不断尝试去用CAS更新。如果更新失败，就继续重试。那为什么要把获取“旧值”v的操作放到循环体内呢？其实这也很好理解。前面我们说了，CAS如果旧值V不等于预期值E，它就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他线程改变之后的旧值了，因此放在了do循环体内。</p><h4 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h4><p>这里介绍一下CAS实现原子操作的三大问题及其解决方案。</p><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从JDK 1.5开始，JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>类来解决ABA问题。</p><p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。</p><p>解决思路是让JVM支持处理器提供的<strong>pause指令</strong>。</p><p>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>这个问题你可能已经知道怎么解决了。有两种解决方案：</p><ol><li>使用JDK 1.5开始就提供的<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h4><p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象队列同步器</code>，从字面意思上理解:</p><ul><li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li><li>队列：使用先进先出（FIFO）队列存储数据；</li><li>同步：实现了同步的功能。</li></ul><p>那AQS有什么用呢？AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><p>当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器，只要子类实现它的几个<code>protected</code>方法就可以了，在下文会有详细的介绍。</p><h4 id="AQS的数据结构"><a href="#AQS的数据结构" class="headerlink" title="AQS的数据结构"></a>AQS的数据结构</h4><p>AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改变state的protected方法，子类可以覆盖这些方法来实现自己的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getState()<br>setState()<br>compareAndSetState()<br></code></pre></td></tr></table></figure><p>这三种操作均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。</p><p>而AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。其数据结构如图：</p><p><img src="/posts/57823/11.png" alt="img"></p><p>但它并不是直接储存线程，而是储存拥有线程的Node节点。</p><h4 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h4><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li><li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore&#x2F;CountDownLatch。</li></ul><p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。</p><p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 标记一个结点（对应的线程）在共享模式下等待</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 标记一个结点（对应的线程）在独占模式下等待</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <br><br>    <span class="hljs-comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 等待状态，取值范围，-3，-2，-1，0，1</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-keyword">volatile</span> Node prev; <span class="hljs-comment">// 前驱结点</span><br>    <span class="hljs-keyword">volatile</span> Node next; <span class="hljs-comment">// 后继结点</span><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 结点对应的线程</span><br>    Node nextWaiter; <span class="hljs-comment">// 等待队列里下一个等待条件的结点</span><br><br><br>    <span class="hljs-comment">// 判断共享模式的方法</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br><br>    Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br><br>    <span class="hljs-comment">// 其它方法忽略，可以参考具体的源码</span><br>&#125;<br><br><span class="hljs-comment">// AQS里面的addWaiter私有方法</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 使用了Node的这个构造函数</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 其它代码省略</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。</p></blockquote><h4 id="AQS的主要方法源码解析"><a href="#AQS的主要方法源码解析" class="headerlink" title="AQS的主要方法源码解析"></a>AQS的主要方法源码解析</h4><p>AQS的设计是基于<strong>模板方法模式</strong>的，它有一些方法必须要子类去实现的，它们主要有：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>这些方法虽然都是<code>protected</code>方法，但是它们并没有在AQS具体实现，而是直接抛出异常（这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>而AQS实现了一系列主要的逻辑。下面我们从源码来分析一下获取和释放资源的主要逻辑：</p><h5 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h5><p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p><p>如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 生成该线程对应的Node节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 将Node插入队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-comment">// 使用CAS尝试，如果成功就返回</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 自旋CAS插入等待队列</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p></blockquote><p>OK，现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 拿到资源后，将head指向该结点。</span><br>                <span class="hljs-comment">// 所以head所指的结点，就是当前获取到资源的那个结点或null。</span><br>                setHead(node); <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果自己可以休息了，就进入waiting状态，直到被unpark()</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)，顺便简单介绍一下park。</p><p>LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p><ul><li>park(boolean isAbsolute, long time)：阻塞当前线程</li><li>unpark(Thread jthread)：使给定的线程停止阻塞</li></ul></blockquote><p>所以<strong>结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的</strong>。</p><p>当然，获取资源的方法除了acquire外，还有以下三个：</p><ul><li>acquireInterruptibly：申请可中断的资源（独占模式）</li><li>acquireShared：申请共享模式的资源</li><li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li></ul><blockquote><p>可中断的意思是，在线程中断时可能会抛出<code>InterruptedException</code></p></blockquote><p>总结起来的一个流程图：</p><p><img src="/posts/57823/acquire.jpg" alt="acquire流程"></p><h5 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h5><p>释放资源相比于获取资源来说，会简单许多。在AQS中只有一小段实现。源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 如果状态是负数，尝试把它设置为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 得到头结点的后继结点head.next</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 如果这个后继结点为空或者状态大于0</span><br>    <span class="hljs-comment">// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 等待队列中所有还有用的结点，都向前移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 如果后继结点不为空，</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程（一）</title>
    <link href="/posts/28394.html"/>
    <url>/posts/28394.html</url>
    
    <content type="html"><![CDATA[<p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态</p><blockquote><p>程序：用某种编程语言 (Java、python等) 编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，是<strong>一段静态代码</strong></p></blockquote><p>此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且 CPU 分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换，不用等待时间片用完</p><blockquote><p>当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行</p></blockquote><p>进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率</p><p><strong>线程的提出</strong></p><p>人们又提出了线程的概念，<strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务</strong></p><p><strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p><p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p><ul><li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li><li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li></ul><p><strong>进程和线程的区别</strong></p><p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I&#x2F;O）</strong>：</p><ul><li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li><li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li><li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li></ul><p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即 CPU 分配时间的单位 </p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指*<em>某一时间点 CPU 寄存器和程序计数器的内容。</em></p><blockquote><p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p><p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p><p>举例说明 线程A - B</p><p>1.先挂起线程A，将其在cpu中的状态保存在内存中。</p><p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</p><p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p></blockquote><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p><p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的，意味着此操作会<strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。如何减少系统中上下文切换次数，是提升多线程性能的一个<strong>重点课题</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="Thread-和-Runnable"><a href="#Thread-和-Runnable" class="headerlink" title="Thread 和 Runnable"></a>Thread 和 Runnable</h4><p>上面我们了解了操作系统中多线程的基本概念。那么在Java中，如何使用多线程？</p><p>首先，我们需要有一个“线程”类。JDK提供了 <code>Thread</code> 类和 <code>Runnable</code> 接口来让我们实现自己的“线程”类。</p><ul><li>继承 <code>Thread </code>类，并重写 <code>run</code> 方法</li><li>实现 <code>Runnable</code> 接口的 <code>run</code> 方法</li></ul><h5 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h5><p>先学会怎么用，再学原理。首先我们来看看怎么用 <code>Thread</code> 和 <code>Runnable</code> 来写一个 Java 多线程程序</p><p>首先是继承 <code>Thread</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意要调用 <code>start()</code> 方法后，该线程<strong>才算启动</strong></p><blockquote><p>我们在程序里面调用了 <code>start()</code> 方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用 <code>run()</code> 方法。</p><p>注意不可多次调用 <code>start()</code> 方法。在第一次调用 <code>start()</code> 方法后，再次调用 <code>start()</code> 方法会抛出<code>IllegalThreadStateException</code> 异常</p></blockquote><h5 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h5><p>接着我们来看一下 <code>Runnable</code> 接口(JDK 1.8 +)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>Runnable</code> 是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>()).start();<br><br>        <span class="hljs-comment">// Java 8 函数式编程，可以省略MyThread类</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Java 8 匿名内部类&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Thread-类构造方法"><a href="#Thread-类构造方法" class="headerlink" title="Thread 类构造方法"></a>Thread 类构造方法</h5><p><code>Thread</code> 类是一个 <code>Runnable</code> 接口的实现类，我们来看看 <code>Thread</code> 类的源码。</p><p>查看 <code>Thread</code> 类的构造方法，发现其实是简单调用一个私有的 <code>init</code> 方法来实现初始化。<code>init</code> 的方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread类源码 </span><br><br><span class="hljs-comment">// 片段1 - init方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><br><span class="hljs-params">                      <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><br><span class="hljs-params">                      <span class="hljs-type">boolean</span> inheritThreadLocals)</span><br><br><span class="hljs-comment">// 片段2 - 构造函数调用init方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>    init(<span class="hljs-literal">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性</span><br><span class="hljs-built_in">this</span>.inheritedAccessControlContext = <br>    acc != <span class="hljs-literal">null</span> ? acc : AccessController.getContext();<br><br><span class="hljs-comment">// 片段4 - 两个对用于支持ThreadLocal的私有属性</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>我们挨个来解释一下 <code>init</code> 方法的这些参数：</p><ul><li><p><strong>g</strong>：线程组，指定这个线程是在哪个线程组下；</p></li><li><p><strong>target</strong>：指定要执行的任务；</p></li><li><p><strong>name</strong>：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</p></li><li><p><strong>acc</strong>：见片段3，用于初始化私有变量 <code>inheritedAccessControlContext</code>。</p><blockquote><p>这个变量有点神奇。它是一个私有变量，但是在<code>Thread</code>类里只有<code>init</code>方法对它进行初始化，在<code>exit</code>方法把它设为<code>null</code>。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href="https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software">Restrict permissions to threads which execute third party software</a></p></blockquote></li><li><p><strong>inheritThreadLocals</strong>：可继承的 <code>ThreadLocal</code>，见片段4，<code>Thread</code> 类里面有两个私有属性来支持 <code>ThreadLocal</code>，我们会在后面的章节介绍 <code>ThreadLocal</code> 的概念</p></li></ul><p>实际情况下，我们大多是直接调用下面两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread(Runnable target)<br>Thread(Runnable target, String name)<br></code></pre></td></tr></table></figure><h5 id="Thread-类的几个常用方法"><a href="#Thread-类的几个常用方法" class="headerlink" title="Thread 类的几个常用方法"></a>Thread 类的几个常用方法</h5><p>这里介绍一下 Thread 类的几个常用的方法：</p><ul><li><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用</li><li><code>start()</code>：开始执行线程的方法，Java 虚拟机会调用线程内的 <code>run()</code> 方法</li><li><code>yield()</code>：yield在英语里有放弃的意思，同样，这里的 <code>yield()</code> 指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了 <code>yield()</code> 方法，程序在调度的时候，也还有可能继续运行这个线程的</li><li><code>sleep()</code>：静态方法，使当前线程睡眠一段时间</li><li><code>join()</code>：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是 Object 类的 wait 方法实现的</li></ul><h5 id="Thread-类与-Runnable-接口的比较："><a href="#Thread-类与-Runnable-接口的比较：" class="headerlink" title="Thread 类与 Runnable 接口的比较："></a>Thread 类与 Runnable 接口的比较：</h5><p>实现一个自定义的线程类，可以有继承 <code>Thread</code> 类或者实现 <code>Runnable</code> 接口这两种方式，它们之间有什么优劣呢？</p><ul><li>由于 Java <strong>单继承，多实现</strong>的特性，Runnable 接口使用起来比 Thread 更灵活</li><li>Runnable 接口出现更符合面向对象，将线程单独进行对象的封装</li><li>Runnable 接口出现，降低了线程对象和线程任务的耦合性</li><li>如果使用线程时不需要使用 Thread 类的诸多方法，显然使用 Runnable 接口更为轻量</li></ul><p>所以，我们通常优先使用<strong>实现 <code>Runnable</code> 接口</strong>这种方式来自定义线程类</p><h4 id="Callable、Future-与-FutureTask"><a href="#Callable、Future-与-FutureTask" class="headerlink" title="Callable、Future 与 FutureTask"></a>Callable、Future 与 FutureTask</h4><p>通常来说，我们使用 <code>Runnable</code> 和 <code>Thread</code> 来创建一个新的线程。但是它们有一个弊端，就是 <code>run</code> 方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值</p><p>JDK提供了 <code>Callable</code> 接口与 <code>Future</code> 接口为我们解决这个问题，这也是所谓的“异步”模型</p><h5 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h5><p><code>Callable </code>与 <code>Runnable</code> 类似，同样是只有一个抽象方法的函数式接口。不同的是，<code>Callable</code>提供的方法是<strong>有返回值</strong>的，而且支持<strong>泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>那一般是怎么使用 <code>Callable</code> 的呢？<code>Callable</code> 一般是配合线程池工具 <code>ExecutorService</code> 来使用的。<code>ExecutorService</code> 可以使用 <code>submit</code> 方法来让一个 <code>Callable</code> 接口执行。它会返回一个 <code>Future</code>，我们后续的程序可以通过这个 <code>Future</code> 的 <code>get</code> 方法得到结果</p><p>这里可以看一个简单的使用demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义Callable</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 模拟计算需要一秒</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 使用</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();<br>        Future&lt;Integer&gt; result = executor.submit(task);<br>        <span class="hljs-comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span><br>        <span class="hljs-comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span><br>        System.out.println(result.get()); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h5 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h5><p><code>Future </code>接口只有几个比较简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> paramBoolean)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> paramLong, TimeUnit paramTimeUnit)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cancel</code> 方法是试图取消一个线程的执行。</p><p>注意是<strong>试图</strong>取消，<strong>并不一定能取消成功</strong>。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<code>boolean </code>类型的返回值是“是否取消成功”的意思。参数 <code>paramBoolean</code> 表示是否采用中断的方式取消线程执行</p><p>所以有时候，为了让任务有能够取消的功能，就使用 <code>Callable</code> 来代替 <code>Runnable</code>。如果为了可取消性而使用  <code>Future</code> 但又不提供可用的结果，则可以声明  <code>Future&lt;?&gt;</code> 形式类型、并返回  <code>null </code>作为底层任务的结果</p><h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><p>上面介绍了 <code>Future</code> 接口。这个接口有一个实现类叫 <code>FutureTask</code>。<code>FutureTask </code>是实现的 <code>RunnableFuture</code> 接口的，而 <code>RunnableFuture</code> 接口同时继承了 <code>Runnable</code> 接口和 <code>Future</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets this Future to the result of its computation</span><br><span class="hljs-comment">     * unless it has been cancelled.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那 <code>FutureTask</code> 类有什么用？为什么要有一个 <code>FutureTask</code> 类？前面说到了 <code>Future</code> 只是一个接口，而它里面的 <code>cancel</code>，<code>get</code>，<code>isDone</code> 等方法要自己实现起来都是<strong>非常复杂</strong>的。所以JDK提供了一个 <code>FutureTask</code> 类来供我们使用</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义Callable，与上面一样</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 模拟计算需要一秒</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 使用</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>        executor.submit(futureTask);<br>        System.out.println(futureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上与第一个Demo有一点小的区别。首先，调用 <code>submit</code> 方法是没有返回值的。这里实际上是调用的 <code>submit(Runnable task)</code> 方法，而上面的Demo，调用的是 <code>submit(Callable&lt;T&gt; task)</code> 方法</p><p>然后，这里是使用 <code>FutureTask</code> 直接取 <code>get</code> 取值，而上面的Demo是通过 <code>submit </code>方法返回的 <code>Future</code> 去取值</p><p>在很多高并发的环境下，有可能 Callable 和 FutureTask 会创建多次。FutureTask 能够在高并发环境下<strong>确保任务只执行一次</strong>。这块有兴趣的同学可以参看FutureTask源码</p><h5 id="FutureTask的几个状态"><a href="#FutureTask的几个状态" class="headerlink" title="FutureTask的几个状态"></a>FutureTask的几个状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * state可能的状态转变路径如下：</span><br><span class="hljs-comment">  * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">  * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">  * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">  * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><blockquote><p>state表示任务的运行状态，初始状态为NEW。运行状态只会在set、setException、cancel方法中终止。COMPLETING、INTERRUPTING是任务完成后的瞬时状态</p></blockquote><p>以上就是Java多线程几个基本的类和接口的介绍</p><h3 id="线程组-ThreadGroup"><a href="#线程组-ThreadGroup" class="headerlink" title="线程组 (ThreadGroup)"></a>线程组 (ThreadGroup)</h3><p>Java 中用 ThreadGroup 来表示线程组，我们可以使用线程组对线程进行批量控制</p><p>ThreadGroup 和 Thread 的关系就如同他们的字面意思一样简单粗暴，每个 Thread 必然存在于一个 ThreadGroup 中，Thread 不能独立于 ThreadGroup 存在。执行 main() 方法线程的名字是 main，如果在 new Thread 时没有显式指定，那么<strong>默认将父线程</strong>（当前执行 new Thread 的线程）线程组设置为自己的线程组</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">testThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;testThread当前线程组名字：&quot;</span> +<br>                    Thread.currentThread().getThreadGroup().getName());<br>            System.out.println(<span class="hljs-string">&quot;testThread线程名字：&quot;</span> +<br>                    Thread.currentThread().getName());<br>        &#125;);<br><br>        testThread.start();<br>    System.out.println(<span class="hljs-string">&quot;执行main所在线程的线程组名字： &quot;</span> + Thread.currentThread().getThreadGroup().getName());<br>        System.out.println(<span class="hljs-string">&quot;执行main方法线程名字：&quot;</span> + Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">执行main所在线程的线程组名字： main<br>执行main方法线程名字：main<br>testThread当前线程组名字：main<br>testThread线程名字：Thread-<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>ThreadGroup 管理着它下面的 Thread，ThreadGroup 是一个标准的<strong>向下引用</strong>的树状结构，这样设计的原因是<strong>防止”上级”线程被”下级”线程引用而无法有效地被GC回收</strong></p><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>Java 中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的<strong>参考值</strong>，线程最终<strong>在操作系统的优先级</strong>是多少还是由操作系统决定</p><p>Java 默认的线程优先级为5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定</p><p>通常情况下，高优先级的线程将会比低优先级的线程有<strong>更高的几率</strong>得到执行。我们使用方法 <code>Thread</code> 类的 <code>setPriority() </code>实例方法来设定线程的优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>        System.out.println(<span class="hljs-string">&quot;我是默认线程优先级：&quot;</span>+a.getPriority());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>        b.setPriority(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;我是设置过的线程优先级：&quot;</span>+b.getPriority());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">我是默认线程优先级：<span class="hljs-number">5</span><br>我是设置过的线程优先级：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>既然有 1-10 的级别来设定了线程的优先级，这时候可能有些读者会问，那么我是不是可以在业务实现的时候，采用这种方法来指定一些线程执行的先后顺序？</p><p>对于这个问题，我们的答案是：<strong>No</strong></p><p>Java中的优先级来说不是特别的可靠，<strong>Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的</strong></p><p>我们通过代码来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.run();<br>            System.out.println(String.format(<span class="hljs-string">&quot;当前执行的线程是：%s，优先级：%d&quot;</span>,<br>                    Thread.currentThread().getName(),<br>                    Thread.currentThread().getPriority()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).forEach(i -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">T1</span>());<br>            thread.setPriority(i);<br>            thread.start();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>某次输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">当前执行的线程是：Thread-<span class="hljs-number">17</span>，优先级：<span class="hljs-number">9</span><br>当前执行的线程是：Thread-<span class="hljs-number">1</span>，优先级：<span class="hljs-number">1</span><br>当前执行的线程是：Thread-<span class="hljs-number">13</span>，优先级：<span class="hljs-number">7</span><br>当前执行的线程是：Thread-<span class="hljs-number">11</span>，优先级：<span class="hljs-number">6</span><br>当前执行的线程是：Thread-<span class="hljs-number">15</span>，优先级：<span class="hljs-number">8</span><br>当前执行的线程是：Thread-<span class="hljs-number">7</span>，优先级：<span class="hljs-number">4</span><br>当前执行的线程是：Thread-<span class="hljs-number">9</span>，优先级：<span class="hljs-number">5</span><br>当前执行的线程是：Thread-<span class="hljs-number">3</span>，优先级：<span class="hljs-number">2</span><br>当前执行的线程是：Thread-<span class="hljs-number">5</span>，优先级：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Java提供一个<strong>线程调度器</strong>来监视和控制处于 <strong>RUNNABLE 状态</strong>的线程。线程的调度策略采用<strong>抢占式</strong>，优先级高的线程比优先级低的线程会有更大的几率优先执行。在优先级相同的情况下，按照“先到先得”的原则。每个Java程序都有一个默认的主线程，就是通过JVM启动的第一个线程main线程</p><p>还有一种线程称为<strong>守护线程（Daemon）</strong>，守护线程默认的优先级比较低。</p><blockquote><p>如果某线程是守护线程，那如果所有的非守护线程都结束了，这个守护线程也会自动结束</p><p>应用场景是：当所有非守护线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦</p><p>一个线程默认是非守护线程，可以通过Thread类的setDaemon(boolean on)来设置</p></blockquote><p>在之前，我们有谈到一个线程必然存在于一个线程组中，那么当线程和线程组的优先级不一致的时候将会怎样呢？我们用下面的案例来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">threadGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;t1&quot;</span>);<br>    threadGroup.setMaxPriority(<span class="hljs-number">6</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadGroup,<span class="hljs-string">&quot;thread&quot;</span>);<br>    thread.setPriority(<span class="hljs-number">9</span>);<br>    System.out.println(<span class="hljs-string">&quot;我是线程组的优先级&quot;</span>+threadGroup.getMaxPriority());<br>    System.out.println(<span class="hljs-string">&quot;我是线程的优先级&quot;</span>+thread.getPriority());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>我是线程组的优先级6<br>我是线程的优先级6</p></blockquote><p>所以，如果某个线程优先级大于线程所在<strong>线程组的最大优先级</strong>，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级</p><h4 id="线程组的常用方法及数据结构"><a href="#线程组的常用方法及数据结构" class="headerlink" title="线程组的常用方法及数据结构"></a>线程组的常用方法及数据结构</h4><h5 id="线程组的常用方法"><a href="#线程组的常用方法" class="headerlink" title="线程组的常用方法"></a>线程组的常用方法</h5><p><strong>获取当前的线程组名字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.currentThread().getThreadGroup().getName()<br></code></pre></td></tr></table></figure><p><strong>复制线程组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前的线程组</span><br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">threadGroup</span> <span class="hljs-operator">=</span> Thread.currentThread().getThreadGroup();<br><span class="hljs-comment">// 复制一个线程组到一个线程数组（获取Thread信息）</span><br>Thread[] threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[threadGroup.activeCount()];<br>threadGroup.enumerate(threads);<br></code></pre></td></tr></table></figure><p><strong>线程组统一异常处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.func.axc.threadgroup;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroupDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">threadGroup1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;group1&quot;</span>) &#123;<br>            <span class="hljs-comment">// 继承ThreadGroup并重新定义以下方法</span><br>            <span class="hljs-comment">// 在线程成员抛出unchecked exception</span><br>            <span class="hljs-comment">// 会执行此方法</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>                System.out.println(t.getName() + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 这个线程是threadGroup1的一员</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadGroup1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 抛出unchecked异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;测试异常&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        thread1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程组的数据结构"><a href="#线程组的数据结构" class="headerlink" title="线程组的数据结构"></a>线程组的数据结构</h5><p>线程组还可以包含其他的线程组，不仅仅是线程。</p><p>首先看看 <code>ThreadGroup</code> 源码中的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup parent; <span class="hljs-comment">// 父亲ThreadGroup</span><br>    String name; <span class="hljs-comment">// ThreadGroupr 的名称</span><br>    <span class="hljs-type">int</span> maxPriority; <span class="hljs-comment">// 线程最大优先级</span><br>    <span class="hljs-type">boolean</span> destroyed; <span class="hljs-comment">// 是否被销毁</span><br>    <span class="hljs-type">boolean</span> daemon; <span class="hljs-comment">// 是否守护线程</span><br>    <span class="hljs-type">boolean</span> vmAllowSuspension; <span class="hljs-comment">// 是否可以中断</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nUnstartedThreads</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 还未启动的线程</span><br>    <span class="hljs-type">int</span> nthreads; <span class="hljs-comment">// ThreadGroup中线程数目</span><br>    Thread threads[]; <span class="hljs-comment">// ThreadGroup中的线程</span><br><br>    <span class="hljs-type">int</span> ngroups; <span class="hljs-comment">// 线程组数目</span><br>    ThreadGroup groups[]; <span class="hljs-comment">// 线程组数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后看看构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 私有构造函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadGroup</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;system&quot;</span>;<br>    <span class="hljs-built_in">this</span>.maxPriority = Thread.MAX_PRIORITY;<br>    <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 默认是以当前ThreadGroup传入作为parent  ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadGroup</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>(Thread.currentThread().getThreadGroup(), name);<br>&#125;<br><br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadGroup</span><span class="hljs-params">(ThreadGroup parent, String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>(checkParentAccess(parent), parent, name);<br>&#125;<br><br><span class="hljs-comment">// 私有构造函数，主要的构造函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadGroup</span><span class="hljs-params">(Void unused, ThreadGroup parent, String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.maxPriority = parent.maxPriority;<br>    <span class="hljs-built_in">this</span>.daemon = parent.daemon;<br>    <span class="hljs-built_in">this</span>.vmAllowSuspension = parent.vmAllowSuspension;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    parent.add(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第三个构造函数里调用了<code>checkParentAccess</code>方法，这里看看这个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查parent ThreadGroup</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Void <span class="hljs-title function_">checkParentAccess</span><span class="hljs-params">(ThreadGroup parent)</span> &#123;<br>    parent.checkAccess();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断当前运行的线程是否具有修改线程组的权限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAccess</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>        security.checkAccess(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里涉及到 <code>SecurityManager</code> 这个类，它是 Java 的安全管理器，它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。</p><p>比如引入了第三方类库，但是并不能保证它的安全性。</p><p>其实 Thread 类也有一个 <code>checkAccess()</code> 方法，不过是用来当前运行的线程是否有权限修改被调用的这个线程实例（Determines if the currently running thread has permission to modify this thread.）</p></blockquote><p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用</p><h3 id="操作系统中的线程状态转换"><a href="#操作系统中的线程状态转换" class="headerlink" title="操作系统中的线程状态转换"></a>操作系统中的线程状态转换</h3><p>首先看看操作系统中的线程状态转换</p><blockquote><p>在现在的操作系统中，线程是被视为轻量级进程的，所以<strong>操作系统线程的状态其实和操作系统进程的状态是一致的</strong></p></blockquote><p><img src="/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="系统进程/线程转换图"></p><p>操作系统线程主要有以下三个状态：</p><ul><li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态</li><li>执行状态(running)：线程正在使用CPU</li><li>等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I&#x2F;O）</li></ul><h4 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread.State 源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    NEW,<br>    RUNNABLE,<br>    BLOCKED,<br>    WAITING,<br>    TIMED_WAITING,<br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h5><p>处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStateNew</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;&#125;);<br>    System.out.println(thread.getState()); <span class="hljs-comment">// 输出 NEW </span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p><p><strong>关于 start() 的两个引申问题</strong></p><ol><li>反复调用同一个线程的start()方法是否可行？</li><li>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</li></ol><p>要分析这两个问题，我们先来看看start()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br>    group.add(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        start0();<br>        started = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，在 start() 内部，这里有一个 threadStatus 的变量。如果它不等于0，调用 start() 是会直接抛出异常的</p><p>我们接着往下看，有一个 <em>native</em> 的 <code>start0()</code> 方法。这个方法里并没有对 <strong>threadStatus</strong> 的处理。到了这里我们仿佛就拿这个 threadStatus 没辙了，我们通过 debug 的方式再看一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStartMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;&#125;);<br>    thread.start(); <span class="hljs-comment">// 第一次调用</span><br>    thread.start(); <span class="hljs-comment">// 第二次调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我是在 start() 方法内部的最开始打的断点，叙述下在我这里打断点看到的结果：</p><ul><li>第一次调用时 threadStatus 的值是0。</li><li>第二次调用时 threadStatus 的值不为0</li></ul><p>查看当前线程状态的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread.getState方法源码：</span><br><span class="hljs-keyword">public</span> State <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// get current thread state</span><br>    <span class="hljs-keyword">return</span> sun.misc.VM.toThreadState(threadStatus);<br>&#125;<br><br><span class="hljs-comment">// sun.misc.VM 源码：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> State <span class="hljs-title function_">toThreadState</span><span class="hljs-params">(<span class="hljs-type">int</span> var0)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((var0 &amp; <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> State.RUNNABLE;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var0 &amp; <span class="hljs-number">1024</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> State.BLOCKED;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var0 &amp; <span class="hljs-number">16</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> State.WAITING;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var0 &amp; <span class="hljs-number">32</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> State.TIMED_WAITING;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var0 &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> State.TERMINATED;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (var0 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? State.NEW : State.RUNNABLE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，我们结合上面的源码可以得到引申的两个问题的结果：</p><blockquote><p>两个问题的答案都是不可行，在调用一次start()之后，threadStatus的值会改变（threadStatus !&#x3D;0），此时再次调用start()方法会抛出IllegalThreadStateException异常。</p><p>比如，threadStatus为2代表当前线程状态为TERMINATED。</p></blockquote><h5 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h5><p>表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待CPU分配资源</p><p><strong>Java 中线程的 RUNNABLE 状态</strong></p><p>看了操作系统线程的几个状态之后我们来看看Thread源码里对RUNNABLE状态的定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">/**<br> * Thread state for a runnable thread.  A thread in the runnable<br> * state is executing in the Java virtual machine but it may<br> * be waiting for other resources from the operating system<br> * such as processor.<br> */<br></code></pre></td></tr></table></figure><blockquote><p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的。</p></blockquote><h5 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h5><p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区</p><p>我们用BLOCKED状态举个生活中的例子：</p><blockquote><p>假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行<br>假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（食堂唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态</p></blockquote><h5 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h5><p>等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p><p>调用如下3个方法会使线程进入等待状态：</p><ul><li>Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li><li>Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；</li><li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度</li></ul><p>我们延续上面的例子继续解释一下WAITING状态：</p><blockquote><p>你等了好几分钟现在终于轮到你了，突然你们有一个“不懂事”的经理突然来了。你看到他你就有一种不祥的预感，果然，他是来找你的。</p><p>他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。</p><p>此时，假设你还是线程t2，你的经理是线程t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你t2的状态就是WAITING。然后经理t1获得锁，进入RUNNABLE状态。</p><p>要是经理t1不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</p></blockquote><h5 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h5><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒</p><p>调用如下方法会使线程进入超时等待状态：</p><ul><li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li><li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()&#x2F;notifyAll()唤醒；</li><li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li></ul><p>我们继续延续上面的例子来解释一下TIMED_WAITING状态：</p><blockquote><p>到了第二天中午，又到了饭点，你还是到了窗口前</p><p>突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个bug</p><p>好吧，你说那你就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了</p><p>这时你还是线程t1，你改bug的同事是线程t2。t2让t1等待了指定时间，此时t1等待期间就属于TIMED_WATING状态</p><p>t1等待10分钟后，就自动唤醒，拥有了去争夺锁的资格</p></blockquote><h5 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h5><p>终止状态。此时线程已执行完毕。</p><h4 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h4><p>根据上面关于线程状态的介绍我们可以得到下面的<strong>线程状态转换图</strong>：<img src="/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="线程状态转换图"></p><h5 id="BLOCKED与RUNNABLE状态的转换"><a href="#BLOCKED与RUNNABLE状态的转换" class="headerlink" title="BLOCKED与RUNNABLE状态的转换"></a>BLOCKED与RUNNABLE状态的转换</h5><p>我们在上面说到：处于BLOCKED状态的线程是因为在等待锁的释放。假如这里有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockedTest</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            testMethod();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            testMethod();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;b&quot;</span>);<br><br>    a.start();<br>    b.start();<br>    System.out.println(a.getName() + <span class="hljs-string">&quot;:&quot;</span> + a.getState()); <span class="hljs-comment">// 输出？</span><br>    System.out.println(b.getName() + <span class="hljs-string">&quot;:&quot;</span> + b.getState()); <span class="hljs-comment">// 输出？</span><br>&#125;<br><br><span class="hljs-comment">// 同步方法争夺锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初看之下，大家可能会觉得线程a会先调用同步方法，同步方法内又调用了Thread.sleep()方法，必然会输出TIMED_WAITING，而线程b因为等待线程a释放锁所以必然会输出BLOCKED。</p><p>其实不然，有两点需要值得大家注意，一是<strong>在测试方法blockedTest()内还有一个main线程</strong>，二是<strong>启动线程后执行run方法还是需要消耗一定时间的</strong>。</p><blockquote><p>测试方法的main线程只保证了a，b两个线程调用start()方法（转化为RUNNABLE状态），如果CPU执行效率高一点，还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。</p><p>当然，如果CPU执行效率低一点，其中某个线程也是可能打印出BLOCKED状态的（此时两个线程已经开始争夺锁了）。</p></blockquote><p>这时你可能又会问了，要是我想要打印出BLOCKED状态我该怎么处理呢？BLOCKED状态的产生需要两个线程争夺锁才行。那我们处理下测试方法里的main线程就可以了，让它“休息一会儿”，调用一下<code>Thread.sleep()</code>方法。</p><p>这里需要注意的是main线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到BLOCKED状态的。</p><p>我们把上面的测试方法blockedTest()改动一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockedTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    ······<br>    a.start();<br>    Thread.sleep(<span class="hljs-number">1000L</span>); <span class="hljs-comment">// 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒</span><br>    b.start();<br>    System.out.println(a.getName() + <span class="hljs-string">&quot;:&quot;</span> + a.getState()); <span class="hljs-comment">// 输出？</span><br>    System.out.println(b.getName() + <span class="hljs-string">&quot;:&quot;</span> + b.getState()); <span class="hljs-comment">// 输出？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中两个线程的状态转换如下</p><ul><li>a的状态转换过程：RUNNABLE（<code>a.start()</code>） -&gt; TIMED_WATING（<code>Thread.sleep()</code>）-&gt;RUNABLE（sleep()时间到）-&gt;<em>BLOCKED(未抢到锁)</em> -&gt; TERMINATED</li><li>b的状态转换过程：RUNNABLE（<code>b.start()</code>) -&gt; <em>BLOCKED(未抢到锁)</em> -&gt;TERMINATED</li></ul><blockquote><p>斜体表示可能出现的状态， 大家可以在自己的电脑上多试几次看看输出。同样，这里的输出也可能有多钟结果。</p></blockquote><h5 id="WAITING状态与RUNNABLE状态的转换"><a href="#WAITING状态与RUNNABLE状态的转换" class="headerlink" title="WAITING状态与RUNNABLE状态的转换"></a>WAITING状态与RUNNABLE状态的转换</h5><p>根据转换图我们知道有3个方法可以使线程从RUNNABLE状态转为WAITING状态。我们主要介绍下**Object.wait()<strong>和</strong>Thread.join()**。</p><p><strong>Object.wait()</strong></p><blockquote><p>调用wait()方法前线程必须持有对象的锁。</p><p>线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()&#x2F;notifyAll()方法唤醒等待锁的线程。</p><p>需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</p><p>同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p></blockquote><p><strong>Thread.join()</strong></p><blockquote><p>调用join()方法，会一直等待这个线程执行完毕（转换为TERMINATED状态）。</p></blockquote><p>我们再把上面的例子线程启动那里改变一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockedTest</span><span class="hljs-params">()</span> &#123;<br>    ······<br>    a.start();<br>    a.join();<br>    b.start();<br>    System.out.println(a.getName() + <span class="hljs-string">&quot;:&quot;</span> + a.getState()); <span class="hljs-comment">// 输出 TERMINATED</span><br>    System.out.println(b.getName() + <span class="hljs-string">&quot;:&quot;</span> + b.getState());<br>&#125;<br></code></pre></td></tr></table></figure><p>要是没有调用join方法，main线程不管a线程是否执行完毕都会继续往下走。</p><p>a线程启动之后马上调用了join方法，这里main线程就会等到a线程执行完毕，所以这里a线程打印的状态固定是<strong>TERMINATED</strong>。</p><p>至于b线程的状态，有可能打印RUNNABLE（尚未进入同步方法），也有可能打印TIMED_WAITING（进入了同步方法）。</p><h5 id="TIMED-WAITING与RUNNABLE状态转换"><a href="#TIMED-WAITING与RUNNABLE状态转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态转换"></a>TIMED_WAITING与RUNNABLE状态转换</h5><p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p><p><strong>Thread.sleep(long)</strong></p><blockquote><p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</p></blockquote><p><strong>Object.wait(long)</strong></p><blockquote><p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p><p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p></blockquote><p><strong>Thread.join(long)</strong></p><blockquote><p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p><p>我们再来改一改刚才的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockedTest</span><span class="hljs-params">()</span> &#123;<br>    ······<br>    a.start();<br>    a.join(<span class="hljs-number">1000L</span>);<br>    b.start();<br>    System.out.println(a.getName() + <span class="hljs-string">&quot;:&quot;</span> + a.getState()); <span class="hljs-comment">// 输出 TIEMD_WAITING</span><br>    System.out.println(b.getName() + <span class="hljs-string">&quot;:&quot;</span> + b.getState());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用a.join(1000L)，因为是指定了具体a线程执行的时间的，并且执行时间是小于a线程sleep的时间，所以a线程状态输出TIMED_WAITING。</p></blockquote><p>b线程状态仍然不固定（RUNNABLE或BLOCKED）。</p><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><blockquote><p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p><p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p></blockquote><p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p><ul><li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li><li>Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li><li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态</li></ul><blockquote><p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去</p></blockquote><h3 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h3><p>在Java中，锁的概念都是基于对象的，所以我们又经常称它为对象锁。线程和锁的关系，我们可以用婚姻关系来理解。一个锁同一时间只能被一个线程持有。也就是说，一个锁如果和一个线程“结婚”（持有），那其他线程如果需要得到这个锁，就得等这个线程和这个锁“离婚”（释放）</p><p>在我们的线程之间，有一个同步的概念。什么是同步呢，假如我们现在有2位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，老师突然来修改了一些答案，可能A和B最后写出的暑假作业就不一样。我们为了A,B能写出2本相同的暑假作业，我们就需要让老师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，老师再修改答案。这就是线程A，线程B的线程同步。</p><p>可以解释为：线程同步是线程之间按照<strong>一定的顺序</strong>执行。</p><p>为了达到线程同步，我们可以使用锁来实现</p><p>我们先来看看一个无锁的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoneLock</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread A &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread B &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行这个程序，你会在控制台看到，线程A和线程B各自独立工作，输出自己的打印值。如下是我的电脑上某一次运行的结果。每一次运行结果都会不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">....<br>Thread A <span class="hljs-number">48</span><br>Thread A <span class="hljs-number">49</span><br>Thread B <span class="hljs-number">0</span><br>Thread A <span class="hljs-number">50</span><br>Thread B <span class="hljs-number">1</span><br>Thread A <span class="hljs-number">51</span><br>Thread A <span class="hljs-number">52</span><br>....<br></code></pre></td></tr></table></figure><p>那我现在有一个需求，我想等A先执行完之后，再由B去执行，怎么办呢？最简单的方式就是使用一个“对象锁”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread A &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread B &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>()).start();<br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里声明了一个名字为 <code>lock</code> 的对象锁。我们在 <code>ThreadA</code> 和 <code>ThreadB</code> 内需要同步的代码块里，都是用 <code>synchronized </code>关键字加上了同一个对象锁<code>lock</code></p><p>上文我们说到了，根据线程和锁的关系，同一时间只有一个线程持有一个锁，那么线程B就会等线程A执行完成后释放 <code>lock</code>，线程B才能获得锁 <code>lock</code></p><blockquote><p>这里在主线程里使用sleep方法睡眠了10毫秒，是为了防止线程B先得到锁。因为如果同时start，线程A和线程B都是出于就绪状态，操作系统可能会先让B运行。这样就会先输出B的内容，然后B执行完成之后自动释放锁，线程A再执行</p></blockquote><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h4><p>上面一种基于“锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会耗费服务器资源</p><p>而等待&#x2F;通知机制是另一种方式</p><p>Java多线程的等待&#x2F;通知机制是基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>, <code>notifyAll()</code>方法来实现的</p><blockquote><p>notify()方法会随机叫醒一个正在等待的线程，而notifyAll()会叫醒所有正在等待的线程</p></blockquote><p>前面我们讲到，一个锁同一时刻只能被一个线程持有。而假如线程A现在持有了一个锁<code>lock</code>并开始执行，它可以使用<code>lock.wait()</code>让自己进入等待状态。这个时候，<code>lock</code>这个锁是被释放了的</p><p>这时，线程B获得了<code>lock</code>这个锁并开始执行，它可以在某一时刻，使用<code>lock.notify()</code>，通知之前持有<code>lock</code>锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”</p><blockquote><p>需要注意的是，这个时候线程B并没有释放锁<code>lock</code>，除非线程B这个时候使用<code>lock.wait()</code>释放锁，或者线程B执行结束自行释放锁，线程A才能得到<code>lock</code>锁</p></blockquote><p>我们用代码来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitAndNotify</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;ThreadA: &quot;</span> + i);<br>                        lock.notify();<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                lock.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;ThreadB: &quot;</span> + i);<br>                        lock.notify();<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                lock.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>()).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>()).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>ThreadA: <span class="hljs-number">0</span><br>ThreadB: <span class="hljs-number">0</span><br>ThreadA: <span class="hljs-number">1</span><br>ThreadB: <span class="hljs-number">1</span><br>ThreadA: <span class="hljs-number">2</span><br>ThreadB: <span class="hljs-number">2</span><br>ThreadA: <span class="hljs-number">3</span><br>ThreadB: <span class="hljs-number">3</span><br>ThreadA: <span class="hljs-number">4</span><br>ThreadB: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>在这个Demo里，线程A和线程B首先打印出自己需要的东西，然后使用 <code>notify()</code> 方法叫醒另一个正在等待的线程，然后自己使用 <code>wait() </code>方法陷入等待并释放 <code>lock</code> 锁</p><blockquote><p>需要注意的是等待&#x2F;通知机制使用的是使用同一个对象锁，如果你两个线程使用的是不同的对象锁，那它们之间是不能用等待&#x2F;通知机制通信的</p></blockquote><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>JDK提供了一个类似于“信号量”功能的类 <code>Semaphore</code>。但本文不是要介绍这个类，而是介绍一种基于<code>volatile</code>关键字的自己实现的信号量通信</p><p>后面会有专门的章节介绍 <code>volatile</code> 关键字，这里只是做一个简单的介绍</p><blockquote><p>volatile关键字能够保证内存的可见性，如果用volatile关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的</p></blockquote><p>比如我现在有一个需求，我想让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推。我应该怎样实现呢？</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Signal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">signal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (signal &lt; <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">if</span> (signal % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;threadA: &quot;</span> + signal);<br>                    signal++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (signal &lt; <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">if</span> (signal % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;threadB: &quot;</span> + signal);<br>                    signal = signal + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>()).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>()).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>threadA: <span class="hljs-number">0</span><br>threadB: <span class="hljs-number">1</span><br>threadA: <span class="hljs-number">2</span><br>threadB: <span class="hljs-number">3</span><br>threadA: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>我们可以看到，使用了一个 <code>volatile</code> 变量 <code>signal</code> 来实现了“信号量”的模型。这里需要注意的是，<code>volatile</code> 变量需要进行原子操作</p><p>需要注意的是，<code>signal++</code> 并不是一个原子操作，所以我们在实际开发中，会根据需要使用 <code>synchronized</code> 给它“上锁”，或者是使用 <code>AtomicInteger </code>等原子类。并且上面的程序也<strong>并不是线程安全的</strong>，因为执行 <code>while</code> 语句后，可能当前线程就暂停等待时间片了，等线程醒来，可能 signal 已经大于等于5了</p><blockquote><p>这种实现方式并不一定高效，本例只是演示信号量</p></blockquote><h4 id="信号量的应用场景："><a href="#信号量的应用场景：" class="headerlink" title="信号量的应用场景："></a>信号量的应用场景：</h4><p>假如在一个停车场中，车位是我们的公共资源，线程就如同车辆，而看门的管理员就是起的“信号量”的作用。</p><p>因为在这种场景下，多个线程（超过2个）需要相互合作，我们用简单的“锁”和“等待通知机制”就不那么方便了。这个时候就可以用到信号量。</p><p>其实JDK中提供的很多多线程通信工具类都是基于信号量模型的。我们会在后面第三篇的文章中介绍一些常用的通信工具类。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是基于“管道流”的通信方式。JDK提供了 <code>PipedWriter</code>、 <code>PipedReader</code>、 <code>PipedOutputStream</code>、 <code>PipedInputStream</code>。其中，前面两个是基于字符的，后面两个是基于字节流的。</p><p>这里的示例代码使用的是基于字符的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pipe</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> PipedReader reader;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReaderThread</span><span class="hljs-params">(PipedReader reader)</span> &#123;<br>            <span class="hljs-built_in">this</span>.reader = reader;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;this is reader&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> ((receive = reader.read()) != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.print((<span class="hljs-type">char</span>)receive);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriterThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> PipedWriter writer;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WriterThread</span><span class="hljs-params">(PipedWriter writer)</span> &#123;<br>            <span class="hljs-built_in">this</span>.writer = writer;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;this is writer&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                writer.write(<span class="hljs-string">&quot;test&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    writer.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">PipedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedWriter</span>();<br>        <span class="hljs-type">PipedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedReader</span>();<br>        writer.connect(reader); <span class="hljs-comment">// 这里注意一定要连接，才能通信</span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(reader)).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WriterThread</span>(writer)).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-built_in">this</span> is reader<br><span class="hljs-built_in">this</span> is writer<br>test<br></code></pre></td></tr></table></figure><p>我们通过线程的构造函数，传入了<code>PipedWrite</code>和<code>PipedReader</code>对象。可以简单分析一下这个示例代码的执行流程：</p><ol><li>线程ReaderThread开始执行，</li><li>线程ReaderThread使用管道reader.read()进入”阻塞“，</li><li>线程WriterThread开始执行，</li><li>线程WriterThread用writer.write(“test”)往管道写入字符串，</li><li>线程WriterThread使用writer.close()结束管道写入，并执行完毕，</li><li>线程ReaderThread接受到管道输出的字符串并打印，</li><li>线程ReaderThread执行完毕。</li></ol><h4 id="管道通信的应用场景："><a href="#管道通信的应用场景：" class="headerlink" title="管道通信的应用场景："></a>管道通信的应用场景：</h4><p>这个很好理解。使用管道多半与I&#x2F;O流相关。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p><h4 id="其它通信相关"><a href="#其它通信相关" class="headerlink" title="其它通信相关"></a>其它通信相关</h4><p>以上介绍了一些线程间通信的基本原理和方法。除此以外，还有一些与线程通信相关的知识点，这里一并介绍。</p><h5 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h5><p><code>join()</code> 方法是 Thread 类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等 join 的这个线程执行完成后，再继续执行当前线程</p><p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束</p><p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Join</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我是子线程，我先睡一秒&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                System.out.println(<span class="hljs-string">&quot;我是子线程，我睡完了一秒&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>());<br>        thread.start();<br>        thread.join();<br>        System.out.println(<span class="hljs-string">&quot;如果不加join方法，我会先被打出来，加了就不一样了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)</p><p>实际上，通过源码你会发现，join()方法及其重载方法底层都是利用了wait(long)这个方法</p><p>对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理</p></blockquote><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间。它有这样两个方法：</p><ul><li>Thread.sleep(long)</li><li>Thread.sleep(long, int)</li></ul><blockquote><p>同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法</p></blockquote><p>这里需要强调一下：<strong>sleep方法是不会释放当前的锁的，而wait方法会。</strong>这也是最常见的一个多线程面试题</p><p>它们还有这些区别：</p><ul><li>wait可以指定时间，也可以不指定；而sleep必须指定时间</li><li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁</li><li>wait必须放在同步块或同步方法中，而sleep可以在任意位置</li></ul><h5 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h5><p>ThreadLocal是一个本地线程副本变量工具类。内部是一个<strong>弱引用</strong>的Map来维护。这里不详细介绍它的原理，而是只是介绍它的使用，以后有独立章节来介绍ThreadLocal类的原理。</p><blockquote><p>关于ThreadLocal类的原理，可以先看看这几篇文章：<a href="https://yasinshaw.com/articles?keyword=threadlocal">https://yasinshaw.com/articles?keyword=threadlocal</a></p></blockquote><p>有些朋友称 ThreadLocal 为<strong>线程本地变量</strong>或<strong>线程本地存储</strong>。严格来说，ThreadLocal 类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个<strong>副本</strong>，每个线程可以访问自己内部的副本变量</p><p>ThreadLocal 类最常用的就是 set 方法和 get 方法。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; threadLocal;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(ThreadLocal&lt;String&gt; threadLocal)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadLocal = threadLocal;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            threadLocal.set(<span class="hljs-string">&quot;A&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;ThreadA输出：&quot;</span> + threadLocal.get());<br>        &#125;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>            <span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; threadLocal;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(ThreadLocal&lt;String&gt; threadLocal)</span> &#123;<br>                <span class="hljs-built_in">this</span>.threadLocal = threadLocal;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                threadLocal.set(<span class="hljs-string">&quot;B&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;ThreadB输出：&quot;</span> + threadLocal.get());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(threadLocal)).start();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(threadLocal)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>ThreadA输出：A<br>ThreadB输出：B<br></code></pre></td></tr></table></figure><p>可以看到，虽然两个线程使用的同一个ThreadLocal实例（通过构造方法传入），但是它们各自可以存取自己当前线程的一个值</p><p>那ThreadLocal有什么作用呢？如果只是单纯的想要线程隔离，在每个线程中声明一个私有变量就好了呀，为什么要使用ThreadLocal？</p><p>如果开发者希望将类的某个静态变量（user ID或者transaction ID）与线程状态关联，则可以考虑使用ThreadLocal</p><p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接</p><h5 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h5><p>InheritableThreadLocal 类与 ThreadLocal 类稍有不同，Inheritable 是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 原理</title>
    <link href="/posts/48481.html"/>
    <url>/posts/48481.html</url>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 是Java集合框架中实现了 <code>Map</code> 接口的一个常用类。它提供了一种键值对的映射关系，并允许存储不重复的键和允许存储多个值。<code>HashMap </code> 是基于哈希表数据结构实现的，它提供了快速的插入、查找和删除操作</p><span id="more"></span><p><img src="/posts/48481/image-20230727201757816.png" alt="image-20230727201757816"></p><p>在 <code>HashMap</code> 中，每个键(key)都唯一，并且与一个值(value)相关联。键(key)用于查找值(value)，因此可以通过键(key)快速访问和修改对应的值(value)。不同于 <code>List</code> 接口的有序性，<code>HashMap</code> 是无序的，不保证键值对的顺序</p><p><strong><code>HashMap</code> 主要方法</strong>：</p><ul><li><p><code>V get(Object key)</code>: 返回与指定键关联的值，如果键不存在则返回null</p></li><li><p><code>V put(K key, V value)</code>: 将指定的键值对添加到 <code>HashMap</code> 中。如果该键已经存在，则更新对应的值，并返回旧值；如果该键不存在，则添加新的键值对，并返回null</p></li><li><p><code>V remove(Object key)</code>: 从 <code>HashMap</code> 中移除指定键对应的键值对，并返回对应的值。如果键不存在，则返回null</p></li><li><p><code>boolean containsKey(Object key)</code>: 检查 <code>HashMap</code> 中是否包含指定的键，如果包含则返回true，否则返回false</p></li><li><p><code>boolean containsValue(Object value)</code>: 检查 <code>HashMap</code> 中是否包含指定的值，如果包含则返回true，否则返回false</p></li><li><p><code>int size()</code>: 返回 <code>HashMap</code> 中键值对的数量</p></li><li><p><code>boolean isEmpty()</code>: 检查 <code>HashMap</code> 是否为空，如果为空则返回true，否则返回false</p></li><li><p><code>void clear()</code>: 清空 <code>HashMap</code> 中的所有键值对</p></li></ul><h4 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 构造方法 1 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">/** 构造方法 2 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">/** 构造方法 3 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><span class="hljs-comment">/** 构造方法 4 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HashMap</code> 的构造方法：</p><ul><li><p><code>HashMap()</code>: 创建一个空的 <code>HashMap</code>，默认初始容量为16，负载因子为0.75</p></li><li><p><code>HashMap(int initialCapacity)</code>: 创建一个空的 <code>HashMap</code>，指定初始容量，负载因子为0.75</p></li><li><p><code>HashMap(int initialCapacity, float loadFactor)</code>: 创建一个空的 <code>HashMap</code>，指定初始容量和负载因子</p></li><li><p><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>: 创建一个包含指定映射m的 <code>HashMap</code></p></li></ul><h4 id="初始容量、负载因子、阈值"><a href="#初始容量、负载因子、阈值" class="headerlink" title="初始容量、负载因子、阈值"></a>初始容量、负载因子、阈值</h4><p>一般情况下，都会使用无参构造方法创建 HashMap。但当我们对时间和空间复杂度有要求的时候，使用默认值有时可能达不到我们的要求，这个时候我们就需要手动调参。在 HashMap 构造方法中，可供我们调整的参数有两个，一个是初始容量 <strong>initialCapacity</strong>，另一个负载因子 <strong>loadFactor</strong>。通过这两个设定这两个参数，可以进一步影响阈值大小。但初始阈值 threshold 仅由 initialCapacity 经过移位操作计算得出。他们的作用分别如下：</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td><strong>initialCapacity</strong></td><td>HashMap 初始容量</td></tr><tr><td><strong>loadFactor</strong></td><td>负载因子</td></tr><tr><td><strong>threshold</strong></td><td>当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The default initial capacity - MUST be a power of two. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/** The load factor used when none specified in constructor. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br><span class="hljs-comment">/** The next size value at which to resize (capacity * load factor). */</span><br><span class="hljs-type">int</span> threshold;<br></code></pre></td></tr></table></figure><p>默认情况下，HashMap 初始容量是<strong>16</strong>，负载因子为 <strong>0.75</strong>。这里并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来，即 <code>threshold = capacity * loadFactor</code>。但当你仔细看构造方法3时，会发现阈值并不是由上面公式计算而来，而是通过一个方法算出来的。这里也先不说明，后面在分析扩容方法时，再来解释这个问题。接下来，我们来看看<strong>初始化 threshold 的方法</strong>长什么样的的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>详解如下</strong>：</p><p>先来分析有关n位操作部分：先来假设n的二进制为01xxx…xxx。接着对n右移1位：001xx…xxx，再位或：011xx…xxx；对n右移2为：00011…xxx，再位或：01111…xxx；此时前面已经有四个1了，再右移4位且位或可得8个1。同理，有8个1，右移8位肯定会让后八位也为1。</p><p>综上可得，该算法让最高位的1后面的位全变为1，最后再让结果n+1，即得到了2的整数次幂的值了。<strong>由于int是32位，所以&gt;&gt;&gt;16便能满足</strong></p><p>现在回来看看第一条语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int n <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>让 <code>cap-1</code> 再赋值给n的目的是另找到的目标值<strong>大于或等于</strong>原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16，显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。<strong>总结起来就一句话：找到大于或等于 cap 的最小2的幂</strong></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>HashMap 的查找操作比较简单，即先<strong>定位键值对所在的桶的位置</strong>，然后<strong>再对链表或红黑树进行查找</strong>。通过这两步即可完成查找，该操作相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 1. 定位键值对所在桶的位置</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                <br>            <span class="hljs-comment">// 2. 对链表进行查找</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找的核心逻辑是封装在 getNode 方法中的。先来看看查找过程的<strong>第一步 - 确定桶</strong>位置，其实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// index = (n - 1) &amp; hash</span><br>first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]<br></code></pre></td></tr></table></figure><p>这里通过 <code>(n - 1)&amp; hash</code> 即可算出桶的在桶数组中的位置。因为 HashMap 中桶数组的大小 length <strong>总是2的幂</strong>，此时，<code>(n - 1) &amp; hash</code> <strong>等价于对 length 取余</strong>。但取余的计算效率没有位运算高，所以使用了位运算 <code>(n - 1) &amp; hash</code> </p><p>上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算键的 hash 值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做有两个好处。计算余数时，由于 n 比较小，hash 只有低4位参与了计算，高位的计算可以认为是无效的。这样<strong>导致了计算结果只与低位信息有关，高位数据没发挥作用</strong>。为了处理这个缺陷，我们可以上图中的 <strong>hash 高4位数据与低4位数据进行异或运算</strong>，即 <code>hash ^ (hash &gt;&gt;&gt; 4)</code>。通过这种方式，让<strong>高位数据与低位数据进行异或，以此加大低位信息的随机性</strong>，变相的让高位数据参与到计算中</p><p>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，<strong>所以要右移16位</strong></p><p>上面所说的是重新计算 hash 的一个好处，除此之外，<strong>重新计算 hash 的另一个好处是可以增加 hash 的复杂度</strong>。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>和查找一样，遍历操作也是大家使用频率比较高的一个操作。对于 遍历 HashMap，我们一般都会用下面的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Object key : map.keySet()) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般都是对 HashMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 keySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> map.keySet();<br><span class="hljs-type">Iterator</span> <span class="hljs-variable">ite</span> <span class="hljs-operator">=</span> keys.iterator();<br><span class="hljs-keyword">while</span> (ite.hasNext()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> ite.next();<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在遍历 HashMap 的过程中会发现，多次对 HashMap 进行遍历时，遍历结果顺序都是一致的。但这个顺序和插入的顺序一般都是不一致的。遍历相关的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>    Set&lt;K&gt; ks = keySet;<br>    <span class="hljs-keyword">if</span> (ks == <span class="hljs-literal">null</span>) &#123;<br>        ks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeySet</span>();<br>        keySet = ks;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ks;<br>&#125;<br><br><span class="hljs-comment">// 键集合</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;K&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>                 &#123; <span class="hljs-keyword">return</span> size; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>               &#123; HashMap.<span class="hljs-built_in">this</span>.clear(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>     &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyIterator</span>(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-keyword">return</span> containsKey(o); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 省略部分代码</span><br>&#125;<br><br><span class="hljs-comment">// 键迭代器</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span> <br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;K&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> nextNode().key; &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;<br>    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br>    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span><br>    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot</span><br><br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        Node&lt;K,V&gt;[] t = table;<br>        current = next = <span class="hljs-literal">null</span>;<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry </span><br>            <span class="hljs-comment">// 寻找第一个包含链表节点引用的桶</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;K,V&gt;[] t;<br>        Node&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 寻找下一个包含链表节点引用的桶</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-comment">//省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的源码，遍历所有的键时，首先要获取键集合 <code>KeySet</code> 对象，然后再通过 KeySet 的迭代器 <code>KeyIterator</code> 进行遍历。KeyIterator 类继承自 <code>HashIterator</code> 类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>首先是先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对接在链表最后一个位置，或者更新键值对</p><p>HashMap 是变长集合，所以需要考虑扩容的问题。其次，在 JDK 1.8 中，HashMap 引入了红黑树优化过长链表，这里还要考虑多长的链表需要进行优化</p><p><img src="/posts/48481/d669d29c.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 对key的hashCode()做hash</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 初始化桶数组 table，table 被延迟到插入新数据时再进行初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可，并对null做处理 </span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>            <br>        <span class="hljs-comment">// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)  <br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对链表进行遍历，并统计链表长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 如果链表长度大于或等于树化阈值（8），则进行树化操作</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 条件为 true，表示当前链表包含要插入的键值对，终止遍历</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断要插入的键值对是否存在 HashMap 中</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 键值对数量超过阈值时，则进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入操作的入口方法是 <code>put(K,V)</code>，但核心逻辑在<code>V putVal(int, K, V, boolean, boolean)</code> 方法中。putVal 方法主要做了这么几件事情：</p><ol><li>当桶数组 table 为空时，通过扩容的方式初始化 table</li><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</li><li>如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树</li><li>判断键值对数量是否大于阈值，大于的话则进行扩容操作</li></ol><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶</p><p>在详细分析之前，先来说一下扩容相关的背景知识：</p><p>在 HashMap 中，桶数组的长度<strong>均是2的幂</strong>，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容</p><p>HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们<strong>移动到合适的位置</strong>上去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果 table 不为空，表明已经初始化过了</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当 table 容量超过容量最大值，则不再扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125; <br>        <span class="hljs-comment">// 按旧容量和阈值的2倍计算新容量和阈值的大小</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化时，将 threshold 的值赋值给 newCap，</span><br><span class="hljs-comment">         * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span><br><span class="hljs-comment">         */</span> <br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 调用无参构造方法时，桶数组容量为默认容量，</span><br><span class="hljs-comment">         * 阈值为默认容量与默认负载因子乘积</span><br><span class="hljs-comment">         */</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-comment">// newThr 为 0 时，按阈值计算公式进行计算</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 重新映射时，需要对红黑树进行拆分</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 遍历链表，并将链表节点按原顺序进行分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 将分组后的链表映射到新桶中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源码总共做了3件事，分别是：</p><ol><li>计算新桶数组的容量 newCap 和新阈值 newThr</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组</li></ol><p> newCap 和 newThr 计算过程，该计算过程对应 resize 源码的第一和第二个条件分支，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一个条件分支</span><br><span class="hljs-keyword">if</span> ( oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 嵌套条件分支</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;<br>&#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) &#123;...&#125;<br><span class="hljs-keyword">else</span> &#123;...&#125;<br><br><span class="hljs-comment">// 第二个条件分支</span><br><span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>通过这两个条件分支对不同情况进行判断，进而算出不同的容量值和阈值。它们所覆盖的情况如下：</p><p>分支一：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>oldCap &gt; 0</td><td>桶数组 table 已经被初始化</td><td></td></tr><tr><td>oldThr &gt; 0</td><td>threshold &gt; 0，且桶数组未被初始化</td><td>调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap &#x3D; oldThr，newThr 在第二个条件分支中算出</td></tr><tr><td>oldCap &#x3D;&#x3D; 0 &amp;&amp; oldThr &#x3D;&#x3D; 0</td><td>桶数组未被初始化，且 threshold 为 0</td><td>调用 HashMap() 构造方法会产生这种情况。</td></tr></tbody></table><p>这里把 <code>oldThr &gt; 0</code> 情况单独拿出来说一下。在这种情况下，会将 oldThr 赋值给 newCap，等价于<code>newCap = threshold = tableSizeFor(initialCapacity)</code>。我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap</p><p>嵌套分支：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>oldCap &gt;&#x3D; 230</td><td>桶数组容量大于或等于最大桶容量 230</td><td>这种情况下不再扩容</td></tr><tr><td>newCap &lt; 230 &amp;&amp; oldCap &gt; 16</td><td>新桶数组容量小于最大值，且旧桶数组容量大于 16</td><td>该种情况下新阈值 newThr &#x3D; oldThr &lt;&lt; 1，移位可能会导致溢出</td></tr></tbody></table><p>分支二：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>newThr &#x3D;&#x3D; 0</td><td>第一个条件分支未计算 newThr 或嵌套分支在计算过程中导致 newThr 溢出归零</td><td></td></tr></tbody></table><p>说完 newCap 和 newThr 的计算过程，接下来再来分析一下键值对节点重新映射的过程</p><p>在 JDK 1.8 中，重新映射节点需要考虑节点类型。对于树形节点，需先拆分红黑树再映射。对于链表类型节点，则需先对链表进行分组，然后再映射。需要的注意的是，分组后，组内节点相对位置保持不变</p><p>往底层数据结构中插入节点时，一般都是<strong>先通过模运算计算桶位置</strong>，接着<strong>把节点放入桶</strong>中即可。事实上，我们可以把重新映射看做插入操作。在 JDK 1.7 中，也确实是这样做的。但在 JDK 1.8 中，则对这个过程进行了一定的优化，逻辑上要稍微复杂一些</p><p>JDK1.8做了哪些优化。经过观测可以发现，我们使用的是<strong>2次幂的扩展</strong>（指长度扩为原来2倍），所以，元素的位置要么是在原位置，要么是在<strong>原位置再移动2次幂</strong>的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="/posts/48481/4d8022db.png" alt="img"></p><p>元素在重新计算 hash 之后，因为n变为2倍，那么 n-1 的 mask 范围在高位多1bit(红色)，因此新的 index 就会发生这样的变化：</p><p><img src="/posts/48481/d773f86e.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，<strong>不需要像JDK1.7的实现那样重新计算hash</strong>，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，<strong>是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/posts/48481/3cc9813a.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则<strong>链表元素会倒置</strong>，但是从上图可以看出，<strong>JDK1.8不会倒置</strong></p><h4 id="链表树化、红黑树链化与拆分"><a href="#链表树化、红黑树链化与拆分" class="headerlink" title="链表树化、红黑树链化与拆分"></a>链表树化、红黑树链化与拆分</h4><p>JDK 1.8 对 HashMap 实现进行了改进。最大的改进莫过于在引入了红黑树处理频繁的碰撞，代码复杂度也随之上升。比如，以前只需实现一套针对链表操作的方法即可。而引入红黑树后，需要另外实现红黑树相关的操作，而红黑树是一种<strong>自平衡的二叉查找树</strong>，本身就比较复杂</p><p>在展开说明之前，先把树化的相关代码贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当桶数组容量小于该值时，优先进行扩容，而不是树化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;<br>    TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, val, next);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将普通节点链表转换成树形节点链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 桶数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// hd 为头节点（head），tl 为尾节点（tail）</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 将普通节点替换成树形节点</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 将普通链表转成由树形节点链表</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// 将树形链表转换成红黑树</span><br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br><br>TreeNode&lt;K,V&gt; <span class="hljs-title function_">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>在扩容过程中，树化要满足两个条件：</p><ol><li>链表长度大于等于 <strong>TREEIFY_THRESHOLD</strong></li><li>桶数组容量大于等于 <strong>MIN_TREEIFY_CAPACITY</strong></li></ol><p>第一个条件比较好理解，这里就不说了。这里来说说加入第二个条件的原因，个人觉得原因如下：</p><p>当桶数组容量<strong>比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化</strong>。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以<strong>在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事</strong></p><p>回到上面的源码中，我们继续看一下 treeifyBin 方法。该方法主要的作用是将普通链表转成为由 TreeNode 型节点组成的链表，并在最后调用 treeify 是将该链表转为红黑树。TreeNode 继承自 Node 类，所以 TreeNode 仍然包含 next 引用，原链表的节点顺序最终通过 next 引用被保存下来</p><p>HashMap 在设计之初，并没有考虑到以后会引入红黑树进行优化。所以并没有像 TreeMap 那样，要求键类实现 comparable 接口或提供相应的比较器。但由于树化过程需要比较两个键对象的大小，在键类没有实现 comparable 接口的情况下，怎么比较键与键之间的大小了就成了一个棘手的问题。为了解决这个问题，HashMap 是做了三步处理，确保可以比较出两个键的大小，如下：</p><ol><li>比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li><li>检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li><li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder</li></ol><blockquote><p> tie break 是网球术语，可以理解为加时赛的意思，起这个名字还是挺有意思的。</p></blockquote><p>通过上面三次比较，最终就可以比较出孰大孰小。比较出大小后就可以构造红黑树了</p><p>链表转成红黑树后，<strong>原链表的顺序仍然会被引用仍被保留了</strong>（红黑树的根节点会被移动到链表的第一位），我们仍然可以按遍历链表的方式去遍历上面的红黑树。这样的结构<strong>为后面红黑树的切分以及红黑树转成链表做好了铺垫</strong></p><h5 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h5><p>扩容后，普通节点需要重新映射，红黑树节点也不例外。按照一般的思路，我们可以先把红黑树转成链表，之后再重新映射链表即可。这种处理方式是大家比较容易想到的，但这样做会损失一定的效率。如上节所说，在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行。这样就避免了将红黑树转成链表后再进行映射，无形中提高了效率</p><p>以上就是红黑树拆分的逻辑，下面看一下具体实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 红黑树转链表阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> bit)</span> &#123;<br>    TreeNode&lt;K,V&gt; b = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span><br>    TreeNode&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span><br><span class="hljs-comment">     * 下面的循环是对红黑树节点进行分组，与上面类似</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-literal">null</span>; e = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)e.next;<br>        e.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-literal">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>            ++lc;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-literal">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>            ++hc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span><br>        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index] = loHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index] = loHead;<br>            <span class="hljs-comment">/* </span><br><span class="hljs-comment">             * hiHead == null 时，表明扩容后，</span><br><span class="hljs-comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) <br>                loHead.treeify(tab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 与上面类似</span><br>    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index + bit] = hiHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index + bit] = hiHead;<br>            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>)<br>                hiHead.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码上可以看得出，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 UNTREEIFY_THRESHOLD，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化</p><h5 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h5><p>前面说过，红黑树中仍然保留了原链表节点顺序。有了这个前提，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">untreeify</span><span class="hljs-params">(HashMap&lt;K,V&gt; map)</span> &#123;<br>    Node&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 遍历 TreeNode 链表，并用 Node 替换</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; q = <span class="hljs-built_in">this</span>; q != <span class="hljs-literal">null</span>; q = q.next) &#123;<br>        <span class="hljs-comment">// 替换节点类型</span><br>        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>            hd = p;<br>        <span class="hljs-keyword">else</span><br>            tl.next = p;<br>        tl = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hd;<br>&#125;<br><br>Node&lt;K,V&gt; <span class="hljs-title function_">replacementNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此扩容相关内容结束</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>如果大家坚持看完了前面的内容，到本节就可以轻松一下。当然，前提是不去看红黑树的删除操作。不过红黑树并非本文讲解重点，本节中也不会介绍红黑树相关内容，所以大家不用担心。</p><p>HashMap 的删除操作并不复杂，仅需三个步骤即可完成。第一步是定位桶位置，第二步遍历链表并找到键值相等的节点，第三步删除节点。相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) == <span class="hljs-literal">null</span> ?<br>        <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">// 1. 定位桶位置</span><br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;<br>        <span class="hljs-comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2. 遍历链表，找到待删除节点</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3. 删除节点，并修复链表或红黑树</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除操作本身并不复杂，有了前面的基础，理解起来也就不难了，这里就不多说了。</p><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><h5 id="被-transient-所修饰-table-变量"><a href="#被-transient-所修饰-table-变量" class="headerlink" title="被 transient 所修饰 table 变量"></a>被 transient 所修饰 table 变量</h5><p>如果大家细心阅读 HashMap 的源码，会发现桶数组 table 被申明为 transient。transient 表示易变的意思，在 Java 中，被该关键字修饰的变量不会被默认的序列化机制序列化。我们再回到源码中，考虑一个问题：桶数组 table 是 HashMap 底层重要的数据结构，不序列化的话，别人还怎么还原呢？</p><p>这里简单说明一下吧，HashMap 并没有使用默认的序列化机制，而是通过实现 <code>readObject/writeObject</code> 两个方法自定义了序列化的内容。这样做是有原因的，试问一句，HashMap 中存储的内容是什么？不用说，大家也知道是 <code>键值对</code> 。所以只要我们把键值对序列化了，我们就可以根据键值对数据重建 HashMap。有的朋友可能会想，序列化 table 不是可以一步到位，后面直接还原不就行了吗？这样一想，倒也是合理。但序列化 talbe 存在着<strong>两个问题</strong>：</p><ol><li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li><li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误</li></ol><p>以上两个问题中，第一个问题比较好理解，第二个问题解释一下。HashMap 的<code>get/put/remove</code>等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，<strong>不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样</strong>的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题</p><p>综上所述，大家应该能明白 HashMap 不序列化 table 的原因了</p><h5 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h5><p><code>HashMap</code> 的实现是非线程安全的，如果在多线程环境下使用，可以考虑使用 <code>ConcurrentHashMap</code>来代替。另外，需要注意的是，<code>HashMap</code>中的键必须实现正确的<code>hashCode()</code>和<code>equals()</code>方法，以确保正确的映射和查找行为</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本章对 HashMap 常见操作相关代码进行了详细分析，并在最后补充了一些其他细节。在本章中，插入操作一节的内容说的最多，主要是因为插入操作涉及的点特别多，一环扣一环。包含但不限于“table 初始化、扩容、树化”等，总体来说，插入操作分析起来难度还是很大的。好在，最后分析完了。</p><p>本章篇幅虽比较大，但仍未把 HashMap 所有的点都分析到。比如，红黑树的增删查等操作。当然，我个人看来，以上的分析已经够了。毕竟大家是类库的使用者而不是设计者，没必要去弄懂每个细节。所以如果某些细节实在看不懂的话就跳过吧，对我们开发来说，知道 HashMap 大致原理即可</p><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000012926722">https://segmentfault.com/a/1190000012926722</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Map</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Map</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合</title>
    <link href="/posts/55978.html"/>
    <url>/posts/55978.html</url>
    
    <content type="html"><![CDATA[<p><strong>Java</strong> 集合（<strong>Java Collections</strong>）是 Java 编程语言中用于存储、处理和操作一组对象的框架。它提供了一组接口和类，用于在不同的数据结构上执行各种操作。Java集合框架提供了多种集合类型，包括列表（<strong>List</strong>）、集（<strong>Set</strong>）、映射（<strong>Map</strong>）等</p><span id="more"></span><p><img src="/posts/55978/Collection-framework-hierarchy.png" alt="FrameworkHierarchy - Java Collections - Edureka"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的 <code>java.util</code> 包提供了集合类：<code>Collection</code>，它是除 <code>Map</code> 外所有其他集合类的根接口。Collection 是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection 接口是 Set，Queue，List的父接口</p><ul><li><strong>List 是一个有序的队列</strong>，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList，ArrayList，Vector，Stack</li><li><strong>Set 是一个不允许有重复元素的集合</strong>。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的</li><li><strong>Queue 也就是队列</strong>，是一种遵循<strong>先进先出</strong>（<code>FIFO: First In, First Out</code>）原则的数据集合，数据在Queue中的流动是单向的，从队尾流向队首。Queue 的实现类有 LinkedList，ArrayDeque，PriorityQueue</li></ul><p>Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作</p><ul><li><p><code>int size()</code>：返回集合中的元素个数</p></li><li><p><code>boolean isEmpty()</code>：检查集合是否为空，如果集合中没有元素，则返回true，否则返回false</p></li><li><p><code>boolean contains(Object o)</code>：检查集合中是否包含指定的元素o，如果包含则返回true，否则返回false</p></li><li><p><code>boolean add(E e)</code>：将元素e添加到集合中，如果添加成功，则返回true。对于某些集合，可能会限制添加重复元素</p></li><li><p><code>boolean remove(Object o)</code>：从集合中移除指定的元素o，如果元素存在并成功移除，则返回true，否则返回false</p></li><li><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将给定集合c中的所有元素添加到当前集合中，如果集合发生变化，则返回true</p></li><li><p><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从当前集合中移除与给定集合c中相同的所有元素，如果集合发生变化，则返回true</p></li><li><p><code>boolean retainAll(Collection&lt;?&gt; c)</code>：保留当前集合和给定集合c中共有的元素，移除其他元素，如果集合发生变化，则返回true</p></li><li><p><code>void clear()</code>：清空集合中的所有元素</p></li><li><p><code>boolean containsAll(Collection&lt;?&gt; c)</code>：检查当前集合是否包含给定集合c中的所有元素，如果是，则返回true</p></li><li><p><code>Object[] toArray()</code>：将集合转换为Object类型的数组</p></li><li><p><code>&lt;T&gt; T[] toArray(T[] a)</code>：将集合转换为指定类型的数组</p></li></ul><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><blockquote><p>在 Java 集合框架中，<code>List</code> 接口是一个有序的集合，允许包含重复元素。它扩展自 <code>Collection</code> 接口，因此继承了 <code>Collection</code> 中定义的一些通用方法，并且定义了一些特定于列表的方法。<code>List</code>接口中的元素可以根据插入的顺序访问，并且可以通过索引来访问和操作列表中的元素</p></blockquote><p><strong>List 集合特点</strong></p><ul><li>集合中的元素允许重复</li><li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序</li><li>集合中的元素可以通过索引来访问或者设置</li></ul><p>List 接口为 Collection 直接接口。List 所代表的是有序的 Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>、<code>Stack</code></p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以<strong>如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率</strong></p><p><code>size、isEmpty、get、set、iterator</code>和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）</p><p><strong>ArrayList擅长于随机访问。同时ArrayList是非同步的</strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>同样实现List接口的LinkedList与ArrayList不同，<strong>ArrayList是一个动态数组，而LinkedList是一个双向链表</strong>。所以它除了有ArrayList的基本操作方法外还额外提供了<code>get，remove，insert</code>方法在LinkedList的首部或尾部</p><p>由于实现的方式不同，<strong>LinkedList不能随机访问</strong>，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作</p><p>与ArrayList一样，<strong>LinkedList也是非同步的</strong>。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(...));<br></code></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>与ArrayList相似，但是Vector是同步的。所以说<strong>Vector是线程安全的动态数组</strong>。它的操作与ArrayList几乎一样</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈</p><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>Set 是一种<strong>不包括重复元素的 Collection</strong>。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许 <code>null</code> 的存在但是仅有一个。由于Set接口的特殊性，<strong>所有传入Set集合中的元素都必须不同</strong>，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致 <code>e1.equals(e2)==true</code>，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集 <code>HashSet</code>、链式散列集 <code>LinkedHashSet</code> 和树形集 <code>TreeSet</code></p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 是 set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的。当想 HashSet 集合中添加元素时，首先会调用 <code>hashcode</code> 方法来确定元素的存储位置，然后再调用元素对象的 <code>equals()</code>方法来确保该位置没有重复元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        hashSet.add(<span class="hljs-string">&quot;Jack&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Rose&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Eve&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Rose&quot;</span>);<br>        hashSet.forEach(obj-&gt; System.out.println(obj));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出结果为</span><br>    Eve<br>    Rose<br>    Jack<br></code></pre></td></tr></table></figure><p>向集合中存入元素时，为了保证 HashSet 正常工作，要求在存入对象是，需要重写 Object 类中的 <code>hashCode()</code>和 <code>equals()</code>方法。上个例子将字符串存入 HashSet 时，String 类已经默认重写了 hashCode 的方法，但是有时候传入自定义类型的对象存入 HashSet，需要重写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;zhang&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;row&quot;</span>));<br>        hashSet.forEach();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String id;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id+<span class="hljs-string">&quot; &quot;</span>+name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id.hashCode();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == object)&#123;        <span class="hljs-comment">//判断是否是同一个对象</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">//如果是，返回true</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(!(object <span class="hljs-keyword">instanceof</span> Student))&#123;        <span class="hljs-comment">//判断对象是为Student类型</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//如果不是，返回false</span><br>        &#125;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) object;            <span class="hljs-comment">//将对象强转为Student类型</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.id.equals(student.id);        <span class="hljs-comment">//判断id值是否相同</span><br>        <span class="hljs-keyword">return</span> b;                                    <span class="hljs-comment">//返回判断结果</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br>[<span class="hljs-number">2</span> zhang, <span class="hljs-number">4</span> jack, <span class="hljs-number">6</span> row, <span class="hljs-number">8</span> name]<br></code></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 是一个有序集合，其底层是基于 TreeMap 实现的，非线程安全。TreeSet 可以确保集合元素处于排序状态。<strong>TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</strong>当我们构造 TreeSet 时，若使用不带参数的构造函数，则 TreeSet 的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数</p><blockquote><p>注意：TreeSet集合不是通过 hashcode 和 equals 函数来比较元素的。它是通过 compare 或者 comparaeTo 函数来判断元素是否相等。compare 函数通过判断两个对象的 id，相同的 id 判断为重复元素，不会被加入到集合中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自然排序</span><br><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">18</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">19</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">19</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">19</span>));<br>        System.out.println(treeSet);<br><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    定义Teacher类实现Comparable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;:&quot;</span>+age;<br>    &#125;<br><span class="hljs-comment">//    重写Comparable接口的compareTo()的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> (Teacher) obj;<br><span class="hljs-comment">//     定义比较方式，先比较年龄，再比较名称name</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.age- teacher.age&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.age- teacher.age==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(teacher.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br>[jack:<span class="hljs-number">18</span>, rose:<span class="hljs-number">19</span>, tom:<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure><p>Teacher类实现了 Comparable 接口，并重写 compareTo() 方法。在 compareTo() 方法中，首先针对 age 值进行修改，根据比较结果返回-1和1，当 age 相同时，再对 name 进行比较。教师 Teacher 对象首先按照年龄升序排序，年龄相同时会按照姓名进行升序排序，并且 TreeSet 集合会将重复的元素去掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定制排序</span><br><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.创建集合时，传入Comparator接口实现定制排序规则</span><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>());<br>        treeSet.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(treeSet);<br>        <span class="hljs-comment">// 2.创建集合时，使用Lambda表达式定制排序规则</span><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>((obj1,obj2)-&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (String) obj1;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (String) obj2;<br>            <span class="hljs-keyword">return</span> s1.length() - s2.length();<br>        &#125;);<br>        treeSet1.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(treeSet1);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object obj1, Object obj2)</span>&#123; <span class="hljs-comment">//定制排序方式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> (String) obj1;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> (String) obj2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> str1.length()-str2.length();<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet 继承自 HashSet，其底层是<strong>基于LinkedHashMap来实现的</strong>，有序，非同步。LinkedHashSet 集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，<strong>LinkedHashSet将会以元素的添加顺序访问集合的元素</strong></p><h3 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p>在 Java 集合框架中，<code>Queue </code>接口是一种特殊的集合，用于存储元素按照先进先出（<em>FIFO，First-In-First-Out</em>）的顺序进行排列。这意味着首先添加到队列的元素将首先被移除。<code>Queue</code> 继承自 <code>Collection</code>接口，并在其基础上定义了一些特定于队列的方法</p><p><code>Queue</code> 接口中定义了以下一些常用的方法：</p><ul><li><code>boolean add(E e)</code>：将元素<strong>e</strong>添加到队列的尾部。如果队列容量有限且已满，该方法将抛出一个 <code>IllegalStateException</code>异常</li><li><code>boolean offer(E e)</code>：将元素<strong>e</strong>添加到队列的尾部。如果队列容量有限且已满，该方法将返回false，否则返回true</li><li><code>E remove()</code>：移除并返回队列头部的元素。如果队列为空，该方法将抛出一个 <code>NoSuchElementException</code> 异常</li><li><code>E poll()</code>：移除并返回队列头部的元素。如果队列为空，该方法将返回null</li><li><code>E element()</code>：返回队列头部的元素，但不移除它。如果队列为空，该方法将抛出一个<code>NoSuchElementException</code>异常</li><li><code>E peek()</code>：返回队列头部的元素，但不移除它。如果队列为空，该方法将返回 null</li></ul><p>除了上述常用方法，<code>Queue</code>接口还继承自<code>Collection</code>接口中的一些其他方法，比如<code>size()</code>、<code>isEmpty()</code>、<code>contains(Object o)</code>等。</p><p><code>Queue </code> 接口的实现类通常有：</p><ul><li><code>LinkedList</code>：<code>LinkedList</code> 可以用作队列的实现，因为它同时支持链表的特性和队列的特性</li><li><code>ArrayDeque</code>：<code>ArrayDeque</code> 是一个基于数组的双端队列，可以用作队列和栈的实现</li><li><code>PriorityQueue</code>：<code>PriorityQueue</code> 是一个优先级队列，可以根据元素的优先级进行排序。默认情况下，按照自然顺序排序，或者也可以通过自定义比较器指定排序规则</li></ul><p><code>Queue</code> 接口在Java中非常有用，特别是在多线程和异步编程中。可以帮助我们实现任务队列、消息队列等常见的场景</p><h3 id="ArrayList-的实现"><a href="#ArrayList-的实现" class="headerlink" title="ArrayList 的实现"></a>ArrayList 的实现</h3><p>ArrayList 可以理解为动态数组，就是 Array 的复杂版本。与 Java 中的数组相比，它的容量能动态增长ArrayList 是 List 接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的）</p><p>每个 ArrayList 实例都有一个<strong>容量</strong>，该容量是指<strong>用来存储列表元素的数组的大小</strong>。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造 ArrayList 时指定其容量。在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量</p><p>注意，此实现<strong>不是同步</strong>的。如果多个线程同时访问一个 ArrayList 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）</p><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p><strong>私有属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p><code>elementData</code> 存储 <code>ArrayList</code> 内的元素，<code>size</code> 表示它包含的元素的数量</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为<strong>10</strong>的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 默认容量 10</span><br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 创建一个包含collection的ArrayList    </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储"></a>元素存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;  <br>   RangeCheck(index);  <br><br>   <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) elementData[index];  <br>   elementData[index] = element;  <br>   <span class="hljs-keyword">return</span> oldValue;  <br>&#125;    <br><br><span class="hljs-comment">// 将指定的元素添加到此列表的尾部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;  <br>   ensureCapacity(size + <span class="hljs-number">1</span>);   <br>   elementData[size++] = e;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;    <br><br><span class="hljs-comment">// 将指定的元素插入此列表中的指定位置。</span><br><span class="hljs-comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)  <br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size);  <br><span class="hljs-comment">// 如果数组长度不足，将进行扩容。</span><br>   ensureCapacity(size+<span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>   <span class="hljs-comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span><br><span class="hljs-comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。</span><br><span class="hljs-comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。</span><br>   System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);  <br>   elementData[index] = element;  <br>   size++;  <br>&#125;    <br><br><span class="hljs-comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;  <br>   Object[] a = c.toArray();  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;  <br>   ensureCapacity(size + numNew);  <span class="hljs-comment">// Increments modCount  </span><br>   System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);  <br>   size += numNew;  <br>   <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;  <br>&#125;    <br><br><span class="hljs-comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)  <br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(  <br>           <span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);  <br><br>   Object[] a = c.toArray();  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;  <br>   ensureCapacity(size + numNew);  <span class="hljs-comment">// Increments modCount  </span><br><br>   <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;  <br>   <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)  <br>       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  <br><br>   System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);  <br>   size += numNew;  <br>   <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;  <br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取"></a>元素读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回此列表中指定位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>   RangeCheck(index);  <br> <br>   <span class="hljs-keyword">return</span> (E) elementData[index];  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p><code>ArrayList</code> 提供了根据下标或者指定对象两种方式的删除功能。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 移除此列表中指定位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    RangeCheck(index);  <br>  <br>    modCount++;  <br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) elementData[index];  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)  <br>       System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);  <br>    elementData[--size] = <span class="hljs-literal">null</span>; <br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当移除成功后返回 true，否则返回 false。<code>remove(Object o)</code> 中通过遍历 element 寻找是否存在传入对象，一旦找到就调用 <code>fastRemove</code> 移除对象。因为 <code>fastRemove</code> 跳过了判断边界的处理，因为找到元素就相当于确定了 index 不会超过边界，而且 <code>fastRemove</code> 并不返回被移除的元素。下面是 <code>fastRemove</code> 的代码，基本和 <code>remove(index)</code> 一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来实现。在实际添加大量元素前，我也可以使用 <code>ensureCapacity</code> 来手动增加 <code>ArrayList</code> 实例的容量，以减少递增式再分配的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &gt; <span class="hljs-number">0</span>)<br>        ensureCapacityInternal(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以看出，<strong>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中</strong>，每次数组容量的增长大约是其原容量的 1.5 倍（从 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code> 这行代码得出）。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量</p><h4 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h4><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p><h3 id="LinkedList-的实现"><a href="#LinkedList-的实现" class="headerlink" title="LinkedList 的实现"></a>LinkedList 的实现</h3><p>Java 中的 LinkedList 类实现了 List 接口和 Deque 接口，是一种链表类型的数据结构，支持高效的插入和删除操作，同时也实现了Deque接口，使得 LinkedList 类也具有队列的特性。LinkedList 类的底层实现的数据结构是一个双端的链表</p><h4 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>LinkedList 底层<strong>通过双向链表实现</strong>。双向链表的每个节点用内部类 <em>Node</em> 表示。LinkedList 通过 <code>first</code> 和 <code>last</code> 引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候 <code>first</code> 和 <code>last</code> 都指向 <code>null</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><p>LinkedList 类中有一个内部私有类 Node，这个类就代表双端链表的节点 Node。在 <code>Node&lt;E&gt;</code> 中，成员变量 <code>item</code> 用来存储具体的元素值，另外两个 <code>Node&lt;E&gt;</code> 类型的变量 <code>next</code> 和 <code>prev</code> 分别表示该节点的<strong>后一个节点</strong>和<strong>上一个节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意这个节点的初始化方法，给定三个参数，分别前驱节点，本节点的值，后继结点。这个方法将在LinkedList的实现中多次调用</p></blockquote><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    <span class="hljs-comment">// 添加所有元素</span><br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedList 主要就两个构造方法，一个无参的构造，什么也没做，另一个接受集合的构造，该方法初始化了 LinkedList 对象并添加了所有集合c的元素</p><p>LinkedList 因为基于链表，所以<strong>不需要提前申请内存大小</strong>，也就不存在初始化指定容量大小，因而LinkedList 是没有初始化指定 size 的构造方法的</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="尾部添加"><a href="#尾部添加" class="headerlink" title="尾部添加"></a>尾部添加</h5><p>LinkedList 的添加方法有很多，首先最简单也是最常用的尾部添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要逻辑就是 <code>linkLast(E e)</code> 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 构造新的节点，上一节点指向原来的last</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    <span class="hljs-comment">// 操作数自增</span><br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>尾部添加，就是构造新的节点 <code>newNode</code>，并将改节点的上一节点 <code>prev</code> 指向原来的 <code>last</code>，同时改节点为新的last节点。<code>l == null</code> 判断是否当前是第一次添加，如果 <code>l</code> 为 <code>null</code>，则 <code>newNode</code> 同时也是头结点，当前集合中仅有 <code>newNode</code> 一个元素，不为 <code>null</code> 时，因为双向链表，所有 <code>l</code> 的下一个节点 <code>next</code> 指向了<code>newNode</code></p><p>最后就是大小 size 自增与操作计数 modCount 的自增，尾部添加元素就完成了</p><p>尾部操作除了 add，还有个 <code>addLast(E e)</code> 方法，两者除了返回值不一样没有任何差别，都是调用的 linkLast 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中间添加"><a href="#中间添加" class="headerlink" title="中间添加"></a>中间添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkPositionIndex(index);<br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于中间添加，需要首先进行范围检查，即保证插入位置 <code>index</code> 在 <code>[0, size]</code> 之间，否则抛出数组越界异常 <code>IndexOutOfBoundsException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isPositionIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= size;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>index == size</code>，其实就是尾部插入，所以调用了 linkLast，这个刚刚尾部插入已经说过。</p><p>如果 <code>index &lt; size</code>，中间插入的时候，需要分两步：</p><ol><li><code>node(int index)</code> 方法获取到 index 位置的元素 succ</li><li><code>linkBefore(E e, Node&lt;E&gt; succ)</code> 将需要插入的元素 element 连接到 succ 后面</li></ol><p>node 方法是一个频繁被调用的方法，LinkedList 的很多操作都依赖于该方法查找到对应的元素。根据索引 index 获取元素时，因为双向链表的支持前后遍历，所以进行了位置判断，<code>index &lt; (size &gt;&gt; 1)</code>，与中间位置比较，靠前则前序遍历，否则后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">//前序遍历</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历逻辑很简单，循环到index上一个节点（后序则是下一个）位置，获取next（后序使用prev）返回index位置对应的节点Node对象succ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    succ.prev = newNode;<br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>linkBefore 和 linkLast 几乎完全一样，除了一个是添加到 last 节点后，一个是添加到 succ 节点后。</p><p>对于中间插入，如果 index 为 0 时，其实就是头部插入，这个时候比不用调用 node 方法去查找元素了，所以 LinkedList 也提供了一个 addFirst(E e) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    linkFirst(e);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        last = newNode;<br>    <span class="hljs-keyword">else</span><br>        f.prev = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><p>LinkedList 提供尾部批量插入和中间批量插入，但内部实现其实都是调用的 <code>addAll(int index, Collection&lt;? extends E&gt; c)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 范围校验</span><br>    checkPositionIndex(index);<br>    Object[] a = c.toArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// succ是index位置元素，pred是index的前一个元素</span><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-keyword">if</span> (index == size) &#123; <span class="hljs-comment">// 尾部插入</span><br>        succ = <span class="hljs-literal">null</span>;<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br>    <span class="hljs-comment">// 循环插入</span><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) o;<br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            pred.next = newNode;<br>        pred = newNode;<br>    &#125;<br>    <span class="hljs-comment">// 衔接处理</span><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-literal">null</span>) &#123;<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.next = succ;<br>        succ.prev = pred;<br>    <br>    size += numNew;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addAll(int index, Collection&lt;? extends E&gt; c)</code> 方法初一看，好像有些复杂，但明白其原理后，就变得清晰多了。链表插入就如同接水管，先从某一个位置断开水管，然后用接口连接上需要接入的部分。这个方法里，关键的是两个 Node 对象 pred 和 succ，succ 是 index 位置元素，pred 是 index 的前一个元素（变动）</p><p>特殊情况 <code>index == size</code> 时，即尾部插入，所以 succ 就是 null 了，而 pred 则为尾部节点 last</p><p>然后就是循环赋值了，在循环中构造 node 节点，类似于 linkLast</p><p>最后的是衔接处理，如果尾部插入的话，那 pred 就是尾部节点了（循环赋值时有 <code>pred = newNode</code> 处理），所以只需要指定 <code>last = pred</code> 。而中间插入，指明 <code>pred.next = succ</code>、<code>succ.prev = pred</code> 即将 index 位置与新的前一个元素绑定到一起</p><h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; .....&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 此处直接调用了add方法</span><br>    <span class="hljs-keyword">return</span> add(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用linkLast方法</span><br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建新节点，prev节点指向当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 新节点作为新的last节点</span><br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 如果原last节点为null，表示该链表为空，则将节点同时作为first节点</span><br>      first = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原last节点的next节点</span><br>      l.next = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以很容易的看出，<code>offer</code> 方法直接调用了 <code>add</code> 方法，<code>add</code> 方法中调用了 <code>linkLast</code> 方法，并直接返回了true，表示该元素肯定可以插入成功。具体执行元素插入的逻辑在 <code>linkLast</code> 方法中完成，通过上面代码中的注释可以看出，<code>linkLast </code>方法主要功能是在链表尾端添加一个新节点</p><p><strong><code>offerFirst </code>和 <code>offerLast</code></strong></p><p>当了解了 <code>offer</code> 方法后，我们再看下 <code>offerFirst </code>和 <code>offerLast</code> 的实现。从下面代码中可以知道，<code>offerFirst</code> 和 <code>offerLast</code> 方法分别调用了 <code>addFirst</code> 和 <code>addLast</code> 方法，然后在 <code>addFirst</code> 和 <code>addLast</code> 方法中，又分别调用了 <code>linkFirst</code> 和 <code>linkLast</code> 方法</p><p><code>linkLast </code>方法上已经讲到，主要功能是在链表尾端添加一个新节点；而 <code>linkFirst</code> 方法，其主要功能是在链表首端添加一个新节点，具体逻辑与 <code>linkLast</code> 方法类似，本处不再赘述，可以参考下面代码中的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; .....&#123;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    linkFirst(e);<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表头部，添加一个新元素，并作为新的first节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-comment">// 创建新节点，next节点指向当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    <span class="hljs-comment">// 新节点作为新的first节点</span><br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 如果原first节点为null，表示该链表为空，则将节点同时作为last节点</span><br>      last = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原first节点的prev节点</span><br>      f.prev = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 本处省略，详见上一代码块</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>LinkedList 除了提供通用的 get，因为其属性中含有 first 和 last 节点，也提供了 getFirst 和 getLast 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 getFirst 和 getLast，因为是成员变量，省去了查找的过程，直接返回其节点 item 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 范围校验</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// node方法获取节点</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure><p>而通过指针的获取，主要就是调用node方法找对index对应的节点</p><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>对于 LinkedList 集合中元素的修改，需要先查找到该元素，然后更改其 Node 节点数据 item 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// 获取index对应位置的Node对象</span><br>    Node&lt;E&gt; x = node(index);<br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> x.item;<br>    x.item = element;<br>    <span class="hljs-keyword">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>LinkedList 提供了很多种删除元素的方法，但是内部实现逻辑基本都相同，即找到对应的 Node 节点，然后将指向该节点的指向替换</p><h5 id="根据索引移除"><a href="#根据索引移除" class="headerlink" title="根据索引移除"></a>根据索引移除</h5><p>我们先来看看根据索引的 <code>remove(int index)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// 解除节点指针连接</span><br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>删除时的范围检查就不说了，node方法也不再多提，删除的主要逻辑就是 <code>unlink(Node&lt;E&gt; x)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-comment">// 下一节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 前一节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br>    <span class="hljs-comment">// 前一节点prev存在则将prev的下一节点指向next，不存在则当前移除节点其实就是头结点，next就是新的first</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 下一节点next存在，则将next上一节点指向prev，不存在则说明当前移除的是未节点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 触发GC工作</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    <span class="hljs-comment">// 操作计数器自增</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个 unlink 方法就是个标准的双向链表删除操作，三个节点 prev，x，next，删除 x 其实就是将 prev 指向 next，并 next 指向 prev，只是其中多了一些特殊的判断</p><p>看了按索引删除的 remove，再来看另外两个特例 removeFirst 和 removeLast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-literal">null</span>;<br>    f.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>        last = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-literal">null</span>;<br>    size--;<br>    <span class="hljs-comment">// 操作计数器自增</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p>unlinkFirst 就是个简化版的 unlink 方法，因为只用处理头结点，下一个节点 next 存在就将 next 作为新的first</p><p>同理 removeLast 也是类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> &#123;<br>    <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> l.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>    l.item = <span class="hljs-literal">null</span>;<br>    l.prev = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    last = prev;<br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>)<br>        first = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>        prev.next = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 LinkedList 还有个无参的 remove，这个是 Deque 接口定义的，实现也就是调用的 removeFirst</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据元素移除"><a href="#根据元素移除" class="headerlink" title="根据元素移除"></a>根据元素移除</h5><p>根据元素移除其实和根据索引移除没有太大差别，只不过找到对应节点的方式发生了变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 判断元素是否为null，因为LinkedList支持添加null</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，无论元素是否为 null，都是先找到该节点，然后调用了unlink 方法</p><p>因为支持双向遍历的特性，LinkedList 很人性的提供了前序删除和后序删除的方法，即 <code>removeFirstOccurrence</code> 与 <code>removeLastOccurrence</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> remove(o);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 后序遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 后序遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>removeLastOccurrence</code> 只是反序遍历了集合</p><h5 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h5><p>在 LinkedList 类中，并没有 removeAll 方法，因为他未对其进行重写，而是使用了父类 <code>AbstractCollection</code> 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>    Objects.requireNonNull(c);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">modified</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 使用迭代器</span><br>    Iterator&lt;?&gt; it = iterator();<br>    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (c.contains(it.next())) &#123;<br>            it.remove();<br>            modified = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> modified;<br>&#125;<br></code></pre></td></tr></table></figure><p>removeAll 的实现原理其实就是迭代删除，迭代器的获取方法 <code>iterator()</code> 在 <code>AbstractCollection</code> 类中只是个抽象方法，AbstractList 类有其实现，但 <code>AbstractSequentialList</code> 类中覆写该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> listIterator();<br>&#125;<br></code></pre></td></tr></table></figure><p>iterator 方法会调用 listIterator()，这个方法实现在 AbstractList 类中，他调用了 <code>listIterator(int index)</code> 方法，但 LinkedList 重写了该方法，所以兜兜转转最终还是回到了 LinkedList 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    checkPositionIndex(index);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 ListItr 对象是 LinkedList 的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>    <span class="hljs-comment">// 期待计数器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br></code></pre></td></tr></table></figure><p>ListItr 在初始化的时候，会将操作计数器 modCount 赋值给 <code>expectedModCount</code>，而之后的每次 remove 方法，都会校验 expectedModCount 与 modCount 是否相等，否则会抛出异常</p><p>ListItr 的 remove 方法，每次调用后，都将 <code>expectedModCount</code> 自增，已达到和 unlink 中 modCount++ 的同步，从而使得 <code>modCount == expectedModCount</code> 一直成立，这也是为什么我们循环删除 LinkedList 元素时需要使用其迭代器的 remove 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 校验modCount</span><br>    checkForComodification();<br>    <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>    Node&lt;E&gt; lastNext = lastReturned.next;<br>    <span class="hljs-comment">// unlink删除节点逻辑，该方法中有modCount++;</span><br>    unlink(lastReturned);<br>    <span class="hljs-keyword">if</span> (next == lastReturned)<br>        next = lastNext;<br>    <span class="hljs-keyword">else</span><br>        nextIndex--;<br>    lastReturned = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// expectedModCount自增</span><br>    expectedModCount++;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// expectedModCount与modCount必须相等</span><br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue-的实现"><a href="#PriorityQueue-的实现" class="headerlink" title="PriorityQueue 的实现"></a>PriorityQueue 的实现</h3><p><code>PriorityQueue</code> 是Java集合框架中实现了 <code>Queue</code> 接口的一个特殊类，它是一个优先级队列。在优先级队列中，元素被赋予优先级，具有最高优先级的元素将首先被取出（取决于其排序顺序）。默认情况下，<code>PriorityQueue</code> 会对元素进行自然排序（如果元素实现了 <code>Comparable</code> 接口），也可以通过自定义比较器来指定排序规则</p><p><code>PriorityQueue</code> 内部使用堆数据结构来实现，这使得插入和移除元素的时间复杂度都是O(log n)，其中n是优先级队列的大小</p><p><strong><code>PriorityQueue</code> 的构造方法：</strong></p><ul><li><p><code>PriorityQueue()</code>: 创建一个空的优先级队列，默认初始容量为11</p></li><li><p><code>PriorityQueue(int initialCapacity)</code>: 创建一个空的优先级队列，指定初始容量</p></li><li><p><code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code>: 创建一个空的优先级队列，指定初始容量和自定义的比较器</p></li><li><p><code>PriorityQueue(Collection&lt;? extends E&gt; c)</code>: 创建一个包含指定集合c中元素的优先级队列，默认按照元素的自然顺序排序</p></li><li><p><code>PriorityQueue(PriorityQueue&lt;? extends E&gt; c)</code>: 创建一个与指定优先级队列c具有相同元素的新优先级队列</p></li></ul><p><strong><code>PriorityQueue</code> 主要方法：</strong></p><ul><li><p><code>boolean add(E e)</code> 或 <code>boolean offer(E e)</code>: 添加元素到队列中</p></li><li><p><code>E poll()</code>: 移除并返回队列中的头部元素，如果队列为空则返回null。</p></li><li><p><code>E remove()</code>: 移除并返回队列中的头部元素，如果队列为空则抛出<code>NoSuchElementException</code>异常</p></li><li><p><code>E peek()</code>: 返回队列中的头部元素但不移除它，如果队列为空则返回null</p></li><li><p><code>E element()</code>: 返回队列中的头部元素但不移除它，如果队列为空则抛出<code>NoSuchElementException</code>异常。</p></li><li><p><code>int size()</code>: 返回队列中的元素个数</p></li><li><p><code>boolean isEmpty()</code>: 检查队列是否为空</p></li><li><p><code>void clear()</code>: 清空队列中的所有元素</p></li></ul><h5 id="add-和-offer"><a href="#add-和-offer" class="headerlink" title="add() 和 offer()"></a>add() 和 offer()</h5><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="/posts/55978/939998-20160512205600890-346195840.png" alt="PriorityQueue_offer.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//offer(E e)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<span class="hljs-comment">//不允许放入null元素</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//自动扩容</span><br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//队列原来为空，这是插入的第一个元素</span><br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        siftUp(i, e);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//siftUp()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//parentNo = (nodeNo-1)/2</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//调用比较器的比较方法</span><br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序</p><h5 id="element-和-peek"><a href="#element-和-peek" class="headerlink" title="element() 和 peek()"></a>element() 和 peek()</h5><p><code>element()</code> 和 <code>peek()</code> 的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong></p><p><img src="/posts/55978/939998-20160512205615171-1414392177.png" alt="PriorityQueue_peek.png"></p><p>代码也就非常简洁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//peek()</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="remove-和-poll"><a href="#remove-和-poll" class="headerlink" title="remove() 和 poll()"></a>remove() 和 poll()</h5><p><code>remove()</code> 和 <code>poll()</code> 方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/posts/55978/939998-20160512205634609-402016454.png" alt="PriorityQueue_poll.png"></p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) queue[s];<br>    queue[s] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素(也就是最小的那个元素)。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//siftDown()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>    <span class="hljs-comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//leftNo = parentNo*2+1</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> queue[child];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<span class="hljs-comment">//然后用c取代原来的值</span><br>        k = child;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素(如果有多个相等，只删除一个)，该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述</p><p><img src="/posts/55978/939998-20160512205651859-11099237.png" alt="PriorityQueue_remove2.png"></p><p>具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//remove(Object o)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(o);<br>    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    <span class="hljs-keyword">if</span> (s == i) <span class="hljs-comment">//情况1</span><br>        queue[i] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">moved</span> <span class="hljs-operator">=</span> (E) queue[s];<br>        queue[s] = <span class="hljs-literal">null</span>;<br>        siftDown(i, moved);<span class="hljs-comment">//情况2</span><br>        ......<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashSet 由于是对 HashMap 的简单包装，所以将在下篇文章讲 HashMap 时在讨论</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Collection</tag>
      
      <tag>List</tag>
      
      <tag>Set</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github pages + Hexo个人博客搭建</title>
    <link href="/posts/20774.html"/>
    <url>/posts/20774.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/">Hexo</a>是一个使用Node.js编写的静态网站生成器。它允许使用Markdown文件创建和管理博客或网站。Hexo提供了一个命令行界面（CLI），可以轻松创建新的文章、生成网站并将其部署到Web服务器。</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="GitHub-账号"><a href="#GitHub-账号" class="headerlink" title="GitHub 账号"></a>GitHub 账号</h4><p>首先需要有一个GitHub账号，没有的话到<a href="https://github.com/">官网</a>注册一个</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>攻略自行搜索，或者<a href="https://git-scm.com/downloads">这里</a></p><h4 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h4><p>Hexo是基于NodeJS编写的，所以使用时需要安装NodeJS和npm工具，<a href="https://nodejs.org/zh-cn/download">官网教程</a></p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>安装Node.js后，可以使用npm全局安装Hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>hexo -v # 查看版本<br>hexo -h # 帮助<br></code></pre></td></tr></table></figure><p>安装完Hexo后，可以通过运行以下命令创建一个新的站点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init my-blog<br></code></pre></td></tr></table></figure><p>这将创建一个名为<code>my-blog</code>的新目录，其中包含Hexo站点的基本结构。进入新目录并运行以下命令安装依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd my-blog # 下文未作说明的话，一律默认当前目录为my-blog<br>npm install<br></code></pre></td></tr></table></figure><p>安装完依赖项后，可以通过运行以下命令生成页面 &amp; 启动本地开发服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo generate # 生成站点的静态文件，可以简写为 `hexo g`，生成的页面文件在public目录下<br>hexo server # 启动本地开发服务器，简写为 `hexo s`<br></code></pre></td></tr></table></figure><p>这将在 <a href="http://localhost:4000/">http://localhost:4000</a> 启动一个本地Web服务器，可以在此处预览您的站点</p><p>然后可以通过运行以下命令创建新的文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;My First Post&quot;<br></code></pre></td></tr></table></figure><p>这将在当前目录下 <code>source/_posts</code> 目录中创建一个名为”My First Post”的新Markdown文件。可以编辑markdown文件以编写内容</p><p>编写完成后重新发布，建议每次都使用 <code>clean</code> 命令清理当前的页面缓存文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理生成的页面文件。当配置未生效时，建议执行清理命令<br>hexo generate # 生成站点的静态文件<br>hexo server # 启动本地开发服务器<br></code></pre></td></tr></table></figure><p>或者直接简写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>在GitHub上创建一个新的代码仓库存放个人blog页面</p><blockquote><p>注意: 此仓库用于存放个人博客页面，仓库名必须使用 <code>&lt;GitHub用户名&gt;.github.io</code> 格式</p></blockquote><img src="image-20230719173627451.png" alt="创建blog仓库" style="zoom:50%;" /><p>仓库创建完成后，可以在仓库根路径下创建一个名为 <code>index.html</code> 的静态 HTML 文件来验证个人博客搭建是否成功</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Suga yoiya&#x27;s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Blog World ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 <code>&lt;GitHub用户名&gt;.github.io</code> 仓库对应的 GitHub Pages 设置页面 (访问路径为<code>Settings -&gt; Pages</code>) 可以找到个人博客的主页访问地址：https:&#x2F;&#x2F;&lt;GitHub 用户名&gt;.github.io</p><p><img src="/posts/20774/image-20230719173839138.png" alt="GitHub pages页面"></p><p>若能在浏览器中正常访问该地址，即代表个人 GitHub Pages 搭建成功</p><h4 id="创建GitHub-personal-access-tokens-PAT"><a href="#创建GitHub-personal-access-tokens-PAT" class="headerlink" title="创建GitHub personal access tokens (PAT)"></a>创建GitHub personal access tokens (PAT)</h4><p>在 <code>Settings</code> - <code>Developer Settings</code> - <code>Personal access tokens</code> - <code>tokens(classic)</code> 下</p><p><img src="/posts/20774/image-20230719174912316.png" alt="创建PAT"></p><p>验证密码后，选择合适的过期时间和scopes</p><p><img src="/posts/20774/image-20230719175021649.png" alt="PAT过期时间/权限选择"></p><p>生成成功，记得先复制保存下来</p><p><img src="/posts/20774/image-20230719175202710.png" alt="PAT生成成功"></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>Hexo的默认主题不够好看怎么办？官方提供了数百种主题选择，可以根据个人喜好更换，链接<a href="https://hexo.io/themes/">hexo themes</a></p><p>这里使用<a href="https://hexo.fluid-dev.com/">Fluid</a>主题的安装与配置</p><h4 id="安装Fluid主题"><a href="#安装Fluid主题" class="headerlink" title="安装Fluid主题"></a>安装Fluid主题</h4><p><a href="https://hexo.fluid-dev.com/docs/start/">官方</a>提供了两种安装方式</p><ul><li>方式一</li></ul><p>Hexo 5.0.0 版本以上，<strong>推荐</strong>通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将该目录下<code>./node_modules/hexo-theme-fluid/_config.yml</code>文件内容复制进去</p><ul><li>方式二</li></ul><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h4 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h4><p>修改Hexo 博客目录中的 <code>_config.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-string">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h4 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h4><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 标题<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br></code></pre></td></tr></table></figure><p> <strong>注意</strong>：<code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p><h4 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h4><ul><li>方式一</li></ul><blockquote><p>适用于通过 Npm 安装主题。</p></blockquote><p>在博客目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><ul><li>方式二</li></ul><blockquote><p>适用于通过 Release 压缩包安装主题，且没有自行修改任何代码的情况。</p></blockquote><ol><li>先将原文件夹重命名为别的名称，例如 <code>fluid-bkp</code>，用于升级失败进行回退；</li><li>按照安装步骤，重新下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">release</a>并解压重命名为 <code>fluid</code>；</li><li>如果某些配置发生了变化（改名或弃用），release 的说明里会特别提示，同步修改原配置文件即可。</li></ol><ul><li>方式三</li></ul><blockquote><p>适用于<strong>自定义</strong>了一些代码，或想体验其他分支的情况，以 dev 分支为例。</p></blockquote><ol><li>确定自己的 fluid 目录已经开启 git，并且所有改动都已 commit；</li><li>把 fluid 仓库的 develop 分支拉取到自己当前的分支上（也可新建一个分支再拉取）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull https://github.com/fluid-dev/hexo-theme-fluid.git develop<br></code></pre></td></tr></table></figure><ol start="3"><li>解决代码冲突，保留自己修改的部分（如何解决冲突可自行搜索）。</li></ol><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>如果要使用markdown嵌入图片，建议再安装一个插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>，它可以方便的解析markdown中图片对应文章的路径</p><h4 id="安装hexo-renderer-marked"><a href="#安装hexo-renderer-marked" class="headerlink" title="安装hexo-renderer-marked"></a>安装hexo-renderer-marked</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-marked --save<br></code></pre></td></tr></table></figure><h4 id="启用该插件"><a href="#启用该插件" class="headerlink" title="启用该插件"></a>启用该插件</h4><p>找到 <code>_config.yml</code> 中 <code>post_asset_folder</code> 将它的值设置为 <code>true</code> ，然后在下面添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># hexo-renderer-marked config</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># hexo-renderer-marked还有很多其他config，具体可以在https://github.com/hexojs/hexo-renderer-marked#options查看</span><br></code></pre></td></tr></table></figure><p>创建文件名为 <code>my-first-post</code> 文章</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> my-<span class="hljs-keyword">first</span>-<span class="hljs-built_in">post</span><br></code></pre></td></tr></table></figure><p>如上命令执行成功后，在 <code>source/_posts/</code> 目录下生成了一个 markdown 文件和一个同名的资源目录，整体目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span>/_posts (main)&gt; tree</span><br>.<br>├── hello-world.md<br>├── my-first-post       # markdown图片目录<br>└── my-first-post.md    # markdown文件本身<br></code></pre></td></tr></table></figure><p>我这里使用Typora编辑markdown文件，<strong>为了方便插入图片，将my-first-post.md文件先放进同名资源目录下</strong></p><p>此时目录结构为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span>/_posts (main)&gt; tree</span><br>.<br>├── hello-world.md<br>└── my-first-post             # markdown图片目录<br>└── my-first-post.md    # markdown文件本身<br></code></pre></td></tr></table></figure><p>再使用Typora打开编辑，修改Typora的偏好设置为：</p><p><img src="/posts/20774/image-20230719141142351.png" alt="image-20230719141142351"></p><p>之后插入的图片就会自动放在当前文件夹(my-first-post)下，目录结构大概为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span>/_posts (main)&gt; tree</span><br>.<br>├── hello-world.md<br>└── my-first-post             # markdown图片目录<br>├── my-first-post.md    # markdown文件本身<br>├── image-1.png    # markdown中图片1<br>├── image-2.png    # markdown中图片2<br>└── image-3.png    # markdown中图片3<br></code></pre></td></tr></table></figure><p>等到编辑完成后再移出来，这样的好处是不需要手动编辑markdown中图片的路径信息，发布后 <code>hexo-renderer-marked</code> 插件会自己渲染图片路径到对应文章目录结构下，此时的文件目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span>/_posts (main)&gt; tree</span><br>.<br>├── hello-world.md<br>├── my-first-post             # markdown图片目录<br>│├── image-1.png    # markdown中图片1<br>│├── image-2.png    # markdown中图片2<br>│└── image-3.png    # markdown中图片3<br>└── my-first-post.md    # markdown文件本身<br></code></pre></td></tr></table></figure><p>缺点就是编辑时要再将md文件放入资源文件夹中进行编辑，不然编辑器中看不到图片的显示，以及如果后续继续往其中插入图片时图片的路径前后不一致，<strong>总之比起自行修改大量图片的文件路径，这个方法只需要移动markdown文件本体</strong></p><p>当然图片的引用方式也不止一种，更多详细介绍可参考<a href="https://hexo.io/zh-cn/docs/asset-folders">官方文档</a></p><h4 id="发布到本地"><a href="#发布到本地" class="headerlink" title="发布到本地"></a>发布到本地</h4><p>在上一部编辑完成后将md文件移到图片资源文件夹上层后即可执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>在本地 <a href="http://localhost:4000/">http://localhost:4000/</a> 就能看到新发布的文章了</p><h3 id="配置指南"><a href="#配置指南" class="headerlink" title="配置指南"></a>配置指南</h3><p>此处也以 <code>Fluid</code> 主题为例，本指南不包括所有的配置说明，几乎每个配置在<strong>主题配置</strong>(以下主题配置都指的是 <code>_config.fluid.yml</code> )中都有注释，可配合<a href="https://hexo.fluid-dev.com/docs/guide/">官方指南</a>共同参考使用。同样，<strong>站点配置</strong>代表的是 <code>_config.yml</code></p><h4 id="覆盖配置"><a href="#覆盖配置" class="headerlink" title="覆盖配置"></a>覆盖配置</h4><blockquote><p>覆盖配置可以使<strong>主题配置</strong>放置在 fluid 目录之外，避免在更新主题时丢失自定义的配置。</p></blockquote><p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>_config.fluid.yml</code> 文件，将该目录下<code>./node_modules/hexo-theme-fluid/_config.yml</code>文件内容复制进去，<strong>这一步我们在安装主题的时候已经做了</strong>，以后如果修改任何主题配置，都只需修改 <code>_config.fluid.yml</code> 的配置即可。</p><p>注意：</p><ul><li>只要存在于 <code>_config.fluid.yml</code> 的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的。</li><li>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 <code>_config.fluid.yml</code> 同步修改。</li><li>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code> 查看命令行输出。</li><li>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icons 注释掉，否则无法覆盖配置</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h4 id="页面顶部大图"><a href="#页面顶部大图" class="headerlink" title="页面顶部大图"></a>页面顶部大图</h4><ul><li>图片来源</li></ul><p>主题配置中，每个页面都有名为 <code>banner_img</code> 的属性，可以使用本地图片的相对路径，也可以为外站链接，比如：</p><p>指向本地图片：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/example.jpg</span>   <span class="hljs-comment"># 对应存放在当前博客的 /source/img/bg/example.jpg</span><br></code></pre></td></tr></table></figure><p>指向外站链接：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://static.zkqiang.cn/example.jpg</span><br></code></pre></td></tr></table></figure><h4 id="博客标题"><a href="#博客标题" class="headerlink" title="博客标题"></a>博客标题</h4><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的 <code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。</p><p>如需单独区别设置，可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">博客标题</span><br></code></pre></td></tr></table></figure><h4 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-home-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;tag&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/tags/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-tags-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/about/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;联系我&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>key</code>: 用于关联有<a href="#%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE">语言配置</a>，如不存在关联则显示 key 本身的值</li><li><code>link</code>: 跳转链接</li><li><code>icon</code>: 图标的 css class，可以省略（即没有图标），主题内置图标详见<a href="https://hexo.fluid-dev.com/docs/icon/">这里</a></li><li><code>name</code>: 强制使用此名称显示（不再按语言配置显示），可省略</li></ul><p>另外支持二级菜单（下拉菜单），配置写法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;文档&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-books&#x27;</span>,<br>      <span class="hljs-attr">submenu:</span> [<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;主题博客&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;配置指南&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/guide/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;图标用法&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/icon/&#x27;</span> &#125;<br>      ]<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h4><p>所有页面统一字体的字号和字族可以通过<strong>主题配置</strong>中的下列配置项设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">font:</span>  <span class="hljs-comment"># 主题字体配置</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span>        <span class="hljs-comment"># 全局字号</span><br>  <span class="hljs-attr">font_family:</span>           <span class="hljs-comment"># 全局字体族</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span>    <span class="hljs-comment"># 代码的字号</span><br></code></pre></td></tr></table></figure><p>关于字体族（<code>font-family</code>）如果不了解可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">这篇文章</a>先了解一下。</p><p>需要注意：</p><ul><li>最好使用系统自带的字体，否则需要通过<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%87%AA%E5%AE%9A%E4%B9%89-js-css-html">自定义功能</a>额外引入 <code>@font-face</code>，字体一般较大，不建议引入；</li><li>应当至少添加一个通用的字体族名（如 serif，具体见上方链接文章）。</li></ul><p>如果想设置单独的页面，可以直接在 markdown 里通过 style 标签实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">---<br>title: example<br>---<br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-comment">/* 设置整个页面的字体 */</span></span><br><span class="language-css">  <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span>, <span class="hljs-selector-class">.markdown-body</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">font-family</span>: KaiTi,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,Georgia, sans, serif;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-comment">/* 只设置 markdown 字体 */</span></span><br><span class="language-css">  <span class="hljs-selector-class">.markdown-body</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">font-family</span>: KaiTi,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,Georgia, sans, serif;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h4><p>不同语言会影响一些主题自带的文字。</p><p>设置语言是在<strong>站点配置</strong>中，需要对应 <code>fluid/languages/</code> 目录内的配置文件名:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><p>你可以在主题 <a href="https://github.com/fluid-dev/hexo-theme-fluid/tree/master/languages">languages</a>目录里查看支持哪些语言，只要上面的配置的值和文件名相同即可。</p><p>你也可以使用类似于覆盖配置的方式去自定义语言，可按如下操作：</p><ol><li>进入博客目录的 <code>source/_data</code> 目录（如不存在则创建），创建 <code>languages</code> 文件夹；</li><li>在 <code>source/_data/languages</code> 文件夹下创建 <code>xxx.yml</code> 文件（<code>xxx</code> 替换为对应语言的代码，例如 <code>zh-CN</code>）</li><li>将 <a href="https://github.com/fluid-dev/hexo-theme-fluid/tree/master/languages">fluid&#x2F;languages (opens new window)</a>目录下对应语言的配置内容复制到 <code>xxx.yml</code> 中；</li><li>以后配置都在 <code>xxx.yml</code> 中修改，配置会在 <code>hexo g</code> 时自动覆盖。</li></ol><p>当然你可以按这个方法创建一份其他语言的配置。</p><h4 id="暗色模式"><a href="#暗色模式" class="headerlink" title="暗色模式"></a>暗色模式</h4><p>主题暗色模式，开启后菜单中会出现切换按钮</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dark_mode:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">default:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><p><code>default</code> 是暗色默认的模式，可选参数：auto &#x2F; light &#x2F; dark</p><p>选择 auto 时优先遵循 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">prefers-color-scheme</a>，如果不支持则按用户本地时间 18 点到次日 6 点之间进入暗色模式。</p><p>无论选择任何模式，当用户手动切换后会在用户本地保存选项，该用户不再按照默认模式。</p><h4 id="Slogan-打字机"><a href="#Slogan-打字机" class="headerlink" title="Slogan(打字机)"></a>Slogan(打字机)</h4><p>首页大图中的标题文字，可在<strong>主题配置</strong>中设定是否开启：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">这是一条</span> <span class="hljs-string">Slogan</span><br>    <span class="hljs-attr">api:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;GET&quot;</span><br>      <span class="hljs-attr">headers:</span> &#123;&#125;<br>      <span class="hljs-attr">keys:</span> [<span class="hljs-string">&quot;hitokoto&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果 <code>text</code> 为空则按<strong>站点配置</strong>的 <code>subtitle</code> 显示。</p><p>另外支持通过 API 接口获取内容，如果请求失败则按 text 字段显示：</p><p><code>url</code>: API 地址，必须返回的是一个 JSON 格式</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span>`: 请求方法，可选 `GET`、`POST`、`PUT<br></code></pre></td></tr></table></figure><p><code>headers</code>: 请求头，如果接口需要传一些验证的头部信息，在这里设置</p><p><code>keys</code>: 从请求结果获取字符串的取值字段，程序会根据列表中的字段依次取值，最终需要获得到一个字符串</p><p>例如 API 返回的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Fluid&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;An elegant theme&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Test&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Test content&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>设置 <code>keys: [&quot;data&quot;, &quot;content&quot;]</code>，程序会如下执行：</p><ol><li>由于返回体是列表，程序会首先获取第一个元素（不是列表则跳过此步骤）</li><li>通过第一个 key <code>data</code> 获取值，发现不是一个字符串，继续执行</li><li>通过第二个 key <code>content</code> 获取值，发现是一个字符串，返回内容；如果不是字符串则获取失败，使用 text 值</li></ol><h4 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h4><p>开关自动摘要（默认开启）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>若要手动指定摘要，使用 <code>&lt;!-- more --&gt;</code> MD文档里划分，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正文的一部分作为摘要<br>&lt;!-- more --&gt;<br>余下的正文<br></code></pre></td></tr></table></figure><p>或者在 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a> (markdown文件中最上方以 <code>---</code> 分隔的区域，下同)里设置 <code>excerpt</code> 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>TIP</p><p>优先级: 手动摘要 &gt; 自动摘要</p><p>如果关闭自动摘要，并且没有设置手动摘要，摘要区域空白</p><p>无论哪种摘要都最多显示 3 行，当屏幕宽度不足时会隐藏部分摘要。</p><h4 id="文章跳转方式"><a href="#文章跳转方式" class="headerlink" title="文章跳转方式"></a>文章跳转方式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br></code></pre></td></tr></table></figure><p>可选值：</p><ol><li>_blank：新标签页打开</li><li>_self：当前标签页打开</li></ol><h4 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h4><p>可配置隐藏包括发布时间、分类、标签。</p><p>经过测试，如果首页的文章列表中没有略缩图和摘要，标题+文章信息的显示方式会使页面过于拥挤，所以给出此项配置供喜欢首页只显示文章标题的同学使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h4><p>如果想把某些文章隐藏起来，不在首页和其他分类里展示，可以在文章开头 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>中配置 <code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><blockquote><p>隐藏会使文章在分类和标签类里都不显示</p><p>隐藏后依然可以通过文章链接访问</p></blockquote><h4 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h4><p>如果想手动将某些文章固定在首页靠前的位置，可以在安装 <code>hexo-generator-index</code> &gt;&#x3D; 2.0.0 版本的情况下，在文章开头 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>中配置 <code>sticky</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p><code>sticky</code> 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p><p>当文章设置了 <code>sticky</code> 后，主题会默认在首页文章标题前增加一个图标，来标识这是一个置顶文章，你可以通过<strong>主题配置</strong>去关闭或修改这个功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-top&#x27;</span><br></code></pre></td></tr></table></figure><p><code>icon</code> 可以通过<a href="https://hexo.fluid-dev.com/docs/icon/">自定义图标</a>修改为其他图标。</p><h4 id="文章在首页的封面图"><a href="#文章在首页的封面图" class="headerlink" title="文章在首页的封面图"></a>文章在首页的封面图</h4><p>对于单篇文章，在文章开头 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>中配置 <code>index_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>和 Banner 配置相同，<code>/img/example.jpg</code> 对应的是存放在 <code>/source/img/example.jpg</code> 目录下的图片（目录也可自定义，但必须在 source 目录下）。</p><p>也可以使用外链 Url 的绝对路径。</p><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code> 则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></td></tr></table></figure><p>当 <code>default_index_img</code> 和 <code>index_img</code> 都为空时，该文章在首页将不显示图片。</p><h4 id="文章页顶部大图"><a href="#文章页顶部大图" class="headerlink" title="文章页顶部大图"></a>文章页顶部大图</h4><p>默认显示<strong>主题配置</strong>中的 <code>post.banner_img</code>，如需要设置单个文章的 Banner，在 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>中指定 <code>banner_img</code> 属性。</p><p>本地图片存放位置同上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h4 id="日期-字数-阅读时长-阅读数"><a href="#日期-字数-阅读时长-阅读数" class="headerlink" title="日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数"></a>日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</h4><p>显示在文章页大标题下的文章信息，除了作者和阅读次数，其他功能都是默认开启的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br>    <span class="hljs-attr">views:</span>  <span class="hljs-comment"># 阅读次数</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>日期格式必须遵循 ISO-8601 规范，否则无法正常显示；</p><p>其他格式必须包括 <code>&#123;&#125;</code> 符号代替数字，文字可自由设置。</p></blockquote><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">code:</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>copy_btn</code>: 是否开启复制代码的按钮</p><p><code>line_number</code>: 是否开启行号</p><p><code>highlight</code>: 是否开启代码高亮</p><p><code>lib</code>: 选择生成高亮的库，可选项: highlightjs、prismjs，对应下面两组配置，高亮的配置说明具体见<strong>主题配置</strong>中的注释</p><h4 id="关于信息"><a href="#关于信息" class="headerlink" title="关于信息"></a>关于信息</h4><p>在关于页介绍自己的基础信息，可以在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/avatar.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br></code></pre></td></tr></table></figure><h4 id="社交页图标"><a href="#社交页图标" class="headerlink" title="社交页图标"></a>社交页图标</h4><p>在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-github-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://github.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;GitHub&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-douban-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://douban.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;豆瓣&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-wechat-fill&#x27;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 图标的 css class，主题内置图标详见<a href="https://hexo.fluid-dev.com/docs/icon/">这里</a></li><li><code>link</code>: 跳转链接</li><li><code>tip</code>: 鼠标悬浮在图标上显示的提示文字</li><li><code>qrcode</code>: 二维码图片，当使用此字段后，点击不再跳转，而是悬浮二维码</li></ul><h4 id="友情链接页"><a href="#友情链接页" class="headerlink" title="友情链接页"></a>友情链接页</h4><p>友情链接页用于展示好友的博客入口，默认关闭，开启需要先在 <code>navbar</code> 项中将 <code>links</code> 的注释(#号)删掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;links&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/links/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-link-fill&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>然后找到 <code>links</code> 的配置项，对页面内容进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Fluid Docs&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;主题使用指南&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span><br>    &#125;<br>  <span class="hljs-attr">default_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br></code></pre></td></tr></table></figure><ul><li><code>title</code>: 友链站的标题</li><li><code>intro</code>: 站点或博主的简介，可省略</li><li><code>link</code>: 跳转链接</li><li><code>avatar</code>: 头像图片，可省略</li><li><code>default_avatar</code>: 成员的默认头像（仅在指定了头像并且加载失败时生效）</li></ul><p>友链页也可以使用自定义区域和评论，使用方式类似于文章页，具体见配置项与相关注释。</p><h3 id="网页访问统计"><a href="#网页访问统计" class="headerlink" title="网页访问统计"></a>网页访问统计</h3><p>页脚可以展示 PV 与 UV 统计数据，目前支持两种数据来源：<a href="https://www.leancloud.cn/">LeanCloud</a>与 <a href="http://busuanzi.ibruce.info/">不蒜子</a>。</p><p>相关<strong>主题配置</strong>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span>  <span class="hljs-comment"># 可选 leancloud | busuanzi  根据自己需求选择</span><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>不蒜子不需要申请账号，直接开启即可，但有时候会响应缓慢拖慢整个页面加载。</p><p>不蒜子在 localhost 域名下显示的不是真正的数据，因此无需在意。</p><p>LeanCloud 使用前需要申请账号（国内需要身份认证）推荐用国际版（leancloud.app），然后在 <code>web_analytics</code> 配置项中将 <code>leancloud</code> API 相关参数填上才能生效。</p><p>LeanCloud 在 localhost 域名下不会增加数据。</p><p>如果参数填写错误或者接口异常，不会显示数据，请在浏览器控制台排查具体原因。</p></blockquote><p>因为不蒜子只需要直接开启即可，这里介绍一下LeanCloud的配置</p><p>在 【控制台 -&gt; 应用 -&gt; 设置 -&gt; 应用凭证】页面中找到对应的 <strong>AppID</strong>、<strong>AppKey</strong>等信息填入主题配置中，国内版还需要填写<strong>REST API 服务器地址</strong></p><img src="image-20230719150329974.png" alt="image-20230719150329974" style="zoom: 33%;" /><h4 id="展示-PV-与-UV-统计"><a href="#展示-PV-与-UV-统计" class="headerlink" title="展示 PV 与 UV 统计"></a><strong>展示 PV 与 UV 统计</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 可选 leancloud | busuanzi  根据自己需求选择</span><br></code></pre></td></tr></table></figure><p><strong>LeanCloud配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">web_analytics:</span>  <span class="hljs-comment"># 网页访问统计</span><br>  <span class="hljs-attr">leancloud:</span><br>    <span class="hljs-string">app_id:</span> <span class="hljs-comment"># AppID</span><br>    <span class="hljs-string">app_key:</span> <span class="hljs-comment"># AppKey</span><br>    <span class="hljs-comment"># REST API 服务器地址，国际版不填</span><br>    <span class="hljs-comment"># Only the Chinese mainland users need to set</span><br>    <span class="hljs-string">server_url:</span> <span class="hljs-comment"># REST API 服务器地址</span><br><br>    <span class="hljs-comment"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class="hljs-comment"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class="hljs-string">ignore_local:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="展示文章日期-字数-阅读时长-阅读数"><a href="#展示文章日期-字数-阅读时长-阅读数" class="headerlink" title="展示文章日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数"></a><strong>展示文章日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span> <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL a&quot;</span> <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化 See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>    <span class="hljs-attr">wordcount:</span> <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span><br>    <span class="hljs-attr">min2read:</span> <span class="hljs-comment"># 估计阅读全文需要的时长</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">awl:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">wpm:</span> <span class="hljs-number">60</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br>    <span class="hljs-attr">views:</span> <span class="hljs-comment"># 浏览量计数</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><h3 id="文章评论功能"><a href="#文章评论功能" class="headerlink" title="文章评论功能"></a>文章评论功能</h3><p>在上面注册了LeanCloud之后，可以很方便的开启文章评论功能，只需要在主题配置中开启并指定评论插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br><br><span class="hljs-comment"># Valine</span><br><span class="hljs-comment"># 基于 LeanCloud</span><br><span class="hljs-comment"># See: https://valine.js.org/</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-comment"># LeanCloud AppID</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-comment"># LeanCloud AppKey</span><br></code></pre></td></tr></table></figure><p>这里介绍一个valine的进阶版waline</p><p><a href="https://waline.js.org/">Waline</a> 是一款基于 Valine 衍生的简洁、安全的评论系统。</p><table><thead><tr><th>优势</th><th>描述</th></tr></thead><tbody><tr><td>自由评论</td><td>完全的 Markdown 支持，同时包含表情、数学公式、HTML 嵌入</td></tr><tr><td>轻量</td><td>53kb gzip 的完整客户端大小</td></tr><tr><td>强大的安全性</td><td>内容校验、防灌水、保护敏感数据等</td></tr><tr><td>登录支持</td><td>在允许匿名评论的基础上，支持账号注册，保持身份</td></tr><tr><td>完全免费部署</td><td>可免费部署在 Vercel 上</td></tr><tr><td>易于部署</td><td>多种部署部署方式和存储服务支持</td></tr><tr><td>文章反应</td><td>快速表达你对文章的态度</td></tr><tr><td>浏览量统计</td><td>通过 &lt;1kb 代码可靠统计文章浏览量</td></tr></tbody></table><p>首先先注册LeanCloud，可以按照之前的步骤</p><h4 id="Vercel部署"><a href="#Vercel部署" class="headerlink" title="Vercel部署"></a><strong>Vercel部署</strong></h4><p>点击下面按钮跳转到Vercel进行Waline的server端部署</p><p><a href="https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example"><img src="/posts/20774/68747470733a2f2f76657263656c2e636f6d2f627574746f6e.svg" alt="Deploy with Vercel"></a></p><ol><li>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</li><li>输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续:</li></ol><p><img src="/posts/20774/image-20230719152700758.png" alt="image-20230719152700758"></p><ol start="3"><li>此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。</li></ol><p><img src="/posts/20774/image-20230719152750019.png" alt="image-20230719152750019"></p><ol start="4"><li>部署中…</li></ol><p><img src="/posts/20774/image-20230719152805394.png" alt="image-20230719152805394"></p><ol start="5"><li>几十秒钟之后，满屏的烟花会庆祝你部署成功。点击 <code>Go to Dashboard</code> 可以跳转到应用的控制台。</li></ol><p><img src="/posts/20774/image-20230719152854236.png" alt="image-20230719152854236"></p><ol start="6"><li>点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量<code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code></li></ol><p><img src="/posts/20774/image-20230719153036114.png" alt="image-20230719153036114"></p><blockquote><p> <strong>提示</strong>：如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名</p></blockquote><ol start="7"><li>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效</li></ol><p><img src="/posts/20774/image-20230719153108455.png" alt="image-20230719153108455"></p><ol start="8"><li>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。</li></ol><p><img src="/posts/20774/image-20230719153434166.png" alt="image-20230719153434166"></p><p>此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p><p><img src="/posts/20774/image-20230719153452533.png" alt="image-20230719153452533"></p><h4 id="Fluid-主题引入"><a href="#Fluid-主题引入" class="headerlink" title="Fluid 主题引入"></a><strong>Fluid 主题引入</strong></h4><ol><li>设置<strong>主题配置</strong>文件 <code>comments -&gt; type</code> 值为 <code>waline</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>  <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">waline</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置 waline 相关信息</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;path-to-your-server-url&#x27;</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">retro</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>, <span class="hljs-string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/bilibili&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ol start="3"><li>最重要的是填入之前得到的<strong>服务端地址</strong> 到<code>serverURL</code> 中</li></ol><h5 id="示例效果"><a href="#示例效果" class="headerlink" title="示例效果"></a><strong>示例效果</strong></h5><p><img src="/posts/20774/image-20230719154757459.png" alt="image-20230719154757459"></p><p>这边我还使用了表情选项卡功能，可以通过设置 <code>emoji</code> 选项自定义评论输入框的表情，你应该将它设置为包含<em>预设地址</em>或<em>预设配置对象</em>的<strong>数组</strong>。如果你不需要它，只需将它设置为 <code>false</code></p><p>具体的其他功能可以参阅<a href="https://waline.js.org/guide/features/">官方文档</a></p><h4 id="登陆服务端"><a href="#登陆服务端" class="headerlink" title="登陆服务端"></a>登陆服务端</h4><p>由于Waline有服务端，支持评论管理，所以我们还需要注册一个账号作为管理员</p><p>找到评论框，点击登录按钮，会弹出一个窗口。找到用户注册，默认第一个注册的用户为管理员，所以在刚部署之后一定要记得及时注册。登陆id为注册时填写的邮箱</p><img src="image-20230719162341742.png" alt="waline注册" style="zoom:50%;" /><h3 id="发布到GitHub-pages"><a href="#发布到GitHub-pages" class="headerlink" title="发布到GitHub pages"></a>发布到GitHub pages</h3><ol><li>安装 <code>hexo-deployer-git</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<strong>站点配置</strong> <code>_config.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;repository</span> <span class="hljs-string">url&gt;</span><span class="hljs-comment"># https://github.com/&lt;GitHub用户名&gt;/&lt;GitHub用户名&gt;.github.io.git</span><br>  <span class="hljs-attr">branch:</span> [<span class="hljs-string">branch</span>]<span class="hljs-comment"># 一般为main或者master</span><br>  <span class="hljs-attr">token:</span> [<span class="hljs-string">token</span>]<span class="hljs-comment"># 之前在github开发者settings中生成的PAT</span><br></code></pre></td></tr></table></figure><ol start="3"><li>生成站点文件并推送至远程 GitHub 仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>登入 Github，在库设置（Repository Settings）中将默认分支设置为 <code>_config.yml</code> 配置中的branch分支名称</p><p><img src="/posts/20774/image-20230719175733279.png" alt="branch设置"></p><p>只需稍等片刻，个人博客站点就会显示在 Github Pages 中</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
      <category>Fluid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>github pages</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
