

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browser.png">
  <link rel="icon" href="/img/browser.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sugayoiya">
  <meta name="keywords" content="Java 线程（三）">
  
    <meta name="description" content="线程池为什么要使用线程池使用线程池主要有以下三个原因：  创建&#x2F;销毁线程需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理。  线程池的原理Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。 我们先看看ThreadPoolExe">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程（三）">
<meta property="og:url" content="https://sugayoiya.github.io/posts/60838.html">
<meta property="og:site_name" content="東方プロジェクト">
<meta property="og:description" content="线程池为什么要使用线程池使用线程池主要有以下三个原因：  创建&#x2F;销毁线程需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理。  线程池的原理Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。 我们先看看ThreadPoolExe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sugayoiya.github.io/img/post/(87953603)%F0%9F%90%9F_p4.jpg">
<meta property="article:published_time" content="2021-07-02T15:11:05.000Z">
<meta property="article:modified_time" content="2023-08-04T08:40:10.000Z">
<meta property="article:author" content="Sugayoiya">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Thread">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://sugayoiya.github.io/img/post/(87953603)%F0%9F%90%9F_p4.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java 线程（三） - 東方プロジェクト</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sugayoiya.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"vggcI4F6j2ISzL56HSxMZF9V-MdYXbMMI","app_key":"yKtFKhuP8rhbpXecJ4jmPFmq","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sugayoiya</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>妖怪の山</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>紅魔館</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>雾之湖</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>人間の里</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>永遠亭</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post/(87953603)%F0%9F%90%9F_p5.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 线程（三）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-02 23:11" pubdate>
          2021年7月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          95k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          159 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java 线程（三）</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><p>使用线程池主要有以下三个原因：</p>
<ol>
<li>创建&#x2F;销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</li>
<li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>
<li><strong>可以对线程做统一管理</strong>。</li>
</ol>
<h4 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h4><p>Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。</p>
<p>我们先看看<code>ThreadPoolExecutor</code>类。</p>
<h5 id="ThreadPoolExecutor提供的构造方法"><a href="#ThreadPoolExecutor提供的构造方法" class="headerlink" title="ThreadPoolExecutor提供的构造方法"></a>ThreadPoolExecutor提供的构造方法</h5><p>一共有四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 五个参数的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><br><span class="hljs-comment">// 六个参数的构造函数-1</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory)</span><br><br><span class="hljs-comment">// 六个参数的构造函数-2</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br><br><span class="hljs-comment">// 七个参数的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>
<ul>
<li><p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p>
<blockquote>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>
</blockquote>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p>
<blockquote>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
</blockquote>
</li>
<li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p>
<blockquote>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>
</blockquote>
</li>
<li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p>
</li>
</ul>
<p>TimeUnit是一个枚举类型 ，包括以下属性：</p>
<blockquote>
<p>NANOSECONDS ： 1微毫秒 &#x3D; 1微秒 &#x2F; 1000 MICROSECONDS ： 1微秒 &#x3D; 1毫秒 &#x2F; 1000 MILLISECONDS ： 1毫秒 &#x3D; 1秒 &#x2F;1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</p>
</blockquote>
<ul>
<li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p>
<p>常用的几个阻塞队列：</p>
<ol>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p>
</li>
<li><p><strong>SynchronousQueue</strong></p>
<p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p>
</li>
<li><p><strong>DelayQueue</strong></p>
<p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>我们将在下一章中重点介绍各种阻塞队列</p>
</blockquote>
<p>好了，介绍完5个必须的参数之后，还有两个非必须的参数。</p>
<ul>
<li><p><strong>ThreadFactory threadFactory</strong></p>
<p>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-comment">// 省略属性</span><br>    <span class="hljs-comment">// 构造函数</span><br>    DefaultThreadFactory() &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>        Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>            poolNumber.getAndIncrement() +<br>            <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>RejectedExecutionHandler handler</strong></p>
<p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p>
<ol>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li>
</ol>
</li>
</ul>
<h5 id="ThreadPoolExecutor的策略"><a href="#ThreadPoolExecutor的策略" class="headerlink" title="ThreadPoolExecutor的策略"></a>ThreadPoolExecutor的策略</h5><p>线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。</p>
<p>故线程池也有自己的状态。<code>ThreadPoolExecutor</code>类中使用了一些<code>final int</code>常量变量来表示线程池的状态 ，分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>线程池创建后处于<strong>RUNNING</strong>状态。</p>
</li>
<li><p>调用shutdown()方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker,不会等待阻塞队列的任务完成。</p>
</li>
<li><p>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0。</p>
</li>
<li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()函数。</p>
<blockquote>
<p>ThreadPoolExecutor中有一个控制状态的属性叫<code>ctl</code>，它是一个AtomicInteger类型的变量。线程池状态就是通过AtomicInteger类型的成员变量<code>ctl</code>来获取的。</p>
<p>获取的<code>ctl</code>值传入<code>runStateOf</code>方法，与<code>~CAPACITY</code>位与运算(<code>CAPACITY</code>是低29位全1的int变量)。</p>
<p><code>~CAPACITY</code>在这里相当于掩码，用来获取ctl的高3位，表示线程池状态；而另外的低29位用于表示工作线程数</p>
</blockquote>
</li>
<li><p>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</p>
</li>
</ul>
<h5 id="线程池主要的任务处理流程"><a href="#线程池主要的任务处理流程" class="headerlink" title="线程池主要的任务处理流程"></a>线程池主要的任务处理流程</h5><p>处理任务的核心方法是<code>execute</code>，我们看看 JDK 1.8 源码中<code>ThreadPoolExecutor</code>是如何处理线程任务的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 1.8 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();   <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>       <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>           <span class="hljs-keyword">return</span>;<br>       c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>            <span class="hljs-comment">// 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br>    <span class="hljs-comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>         reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p>
<p><strong>为什么要二次检查线程池的状态?</strong></p>
<p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p>
<p><strong>总结一下处理流程</strong></p>
<ol>
<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>
</ol>
<p>整个过程如图所示：</p>
<p><img src="/posts/60838/threadpool.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="ThreadPoolExecutor如何做到线程复用的？"><a href="#ThreadPoolExecutor如何做到线程复用的？" class="headerlink" title="ThreadPoolExecutor如何做到线程复用的？"></a>ThreadPoolExecutor如何做到线程复用的？</h5><p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。<strong>那么，线程池如何做到线程复用呢？</strong></p>
<p>原来，ThreadPoolExecutor在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。话不多说，我们继续看看源码（一定要仔细看，前后有联系）</p>
<p>这里的<code>addWorker</code>方法是在上面提到的<code>execute</code>方法里面调用的，先看看上半部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor.addWorker方法源码上半部分</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程</span><br>                <span class="hljs-comment">// 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数</span><br>                <span class="hljs-comment">// 如果不小于，则返回false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上半部分主要是判断线程数量是否超出阈值，超过了就返回false。我们继续看下半部分:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ThreadPoolExecutor.addWorker方法源码下半部分</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个worker对象</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 2.实例化一个Thread对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 3.线程池全局锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 4.启动这个线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后启动这个线程对象。</p>
<p>我们接着看看<code>Worker</code>类，仅展示部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker类部分源码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">final</span> Thread thread;<br>    Runnable firstTask;<br><br>    Worker(Runnable firstTask) &#123;<br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其余代码略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Worker</code>类实现了<code>Runnable</code>接口，所以<code>Worker</code>也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故<code>addWorker</code>方法调用addWorker方法源码下半部分中的第4步<code>t.start</code>，会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</p>
<p>我们再看看<code>runWorker</code>的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker.runWorker方法源代码</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 1.线程启动之后，通过unlock方法释放锁</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span><br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 2.3执行beforeExecute </span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 2.4执行任务</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 2.5执行afterExecute方法 </span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                <span class="hljs-comment">// 2.6解锁操作</span><br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</p>
<p>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</p>
<p>最后看看<code>getTask</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker.getTask方法源码</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-comment">// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span><br>        <span class="hljs-comment">// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 2.如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span><br>　　　　 <span class="hljs-comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span><br>        <span class="hljs-comment">// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span><br>            <span class="hljs-comment">// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span><br>            <span class="hljs-comment">// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span><br>            <span class="hljs-comment">// 如果timed为false（allowCoreThreadTimeOut为false</span><br>            <span class="hljs-comment">// 且wc &gt; corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span><br>            <span class="hljs-comment">// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong>allowCoreThreadTimeOut</strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</p>
<p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断<strong>compareAndDecrementWorkerCount</strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</p>
<p>源码解析完毕，你理解的源码是否和图中的处理流程一致？如果不一致，那么就多看两遍吧，加油。</p>
<h4 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h4><p><code>Executors</code>类中提供的几个静态方法来创建线程池。大家到了这一步，如果看懂了前面讲的<code>ThreadPoolExecutor</code>构造方法中各种参数的意义，那么一看到<code>Executors</code>类中提供的线程池的源码就应该知道这个线程池是干嘛的。</p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p>
<ol>
<li>提交任务进线程池。</li>
<li>因为<strong>corePoolSize</strong>为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。</li>
<li>尝试将任务添加到<strong>SynchronousQueue</strong>队列。</li>
<li>如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</li>
<li>如果SynchronousQueue已有任务在等待，入列操作将会阻塞。</li>
</ol>
<p>当需要执行很多<strong>短时间</strong>的任务时，CacheThreadPool的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<p><strong>与CachedThreadPool的区别</strong>：</p>
<ul>
<li>因为 corePoolSize &#x3D;&#x3D; maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize&#x3D;0，所以只会创建非核心线程。</li>
<li>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。</li>
<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>
<li>都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>
</ul>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有且仅有一个核心线程（ corePoolSize &#x3D;&#x3D; maximumPoolSize&#x3D;1），使用了LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><br><span class="hljs-comment">//ScheduledThreadPoolExecutor():</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>四种常见的线程池基本够我们使用了，但是《阿里巴巴开发手册》不建议我们直接使用Executors类中的线程池，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>但如果你及团队本身对线程池非常熟悉，又确定业务规模不会大到资源耗尽的程度（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h4><p>我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p>
<p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p>
<p>我们自己coding实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。（这块不明白的同学，可以看最下方结语部分的链接）</p>
<p>这么容易出错的事情，JDK当然帮我们做啦，这就是阻塞队列(BlockingQueue)，<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p>
<blockquote>
<p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p>
</blockquote>
<p>BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>
<h4 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法"></a>BlockingQueue的操作方法</h4><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th align="center">方法\处理方式</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">一直阻塞</th>
<th align="center">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入方法</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center"><strong>put(e)</strong></td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除方法</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center"><strong>take()</strong></td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查方法</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true &#x2F; false。</li>
<li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true &#x2F; false。</li>
</ul>
<p><strong>注意之处</strong></p>
<ul>
<li>不能往阻塞队列中插入null,会抛出空指针异常。</li>
<li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li>
</ul>
<h4 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h5><p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，故具有数组的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span>&#123;<br>    <span class="hljs-comment">//..省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.Delayed</span> 接口。 <br><br>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 <br></code></pre></td></tr></table></figure>

<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是非公平锁。<br></code></pre></td></tr></table></figure>

<blockquote>
<p>网上大部分博客上<strong>PriorityBlockingQueue</strong>为公平锁，其实是不对的，查阅源码（感谢github:<strong>ambition0802</strong>同学的指出）：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                                  Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;<br>         <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">//默认构造方法-非公平锁</span><br>         ...<span class="hljs-comment">//其余代码略</span><br>     &#125;<br></code></pre></td></tr></table></figure>

<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p>
<p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p>
<p>以下方法的返回值，可以帮助理解这个队列：</p>
<ul>
<li>iterator() 永远返回空，因为里面没有东西</li>
<li>peek() 永远返回null</li>
<li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li>
<li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li>
<li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li>
<li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li>
<li>isEmpty() 永远返回true</li>
<li>remove()&amp;removeAll() 永远返回false</li>
</ul>
<p><strong>注意</strong></p>
<p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong>对于使用默认大小的<strong>LinkedBlockingQueue</strong>也是一样的。</p>
<h4 id="阻塞队列的原理"><a href="#阻塞队列的原理" class="headerlink" title="阻塞队列的原理"></a>阻塞队列的原理</h4><p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p>
<p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据元素数组</span><br><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-comment">//下一个待取出元素索引</span><br><span class="hljs-type">int</span> takeIndex;<br><span class="hljs-comment">//下一个待添加元素索引</span><br><span class="hljs-type">int</span> putIndex;<br><span class="hljs-comment">//元素个数</span><br><span class="hljs-type">int</span> count;<br><span class="hljs-comment">//内部锁</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-comment">//消费者监视器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-comment">//生产者监视器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-comment">//..省略其他代码</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>put操作的源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 1.自旋拿锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2.判断队列是否满了</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            <span class="hljs-comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span><br>            <span class="hljs-comment">// 等待notFull的唤醒，唤醒之后继续执行while循环。</span><br>            notFull.await();<br>        <span class="hljs-comment">// 3.如果没有满，则进入队列</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[putIndex] == null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    <span class="hljs-comment">// 4 唤醒一个等待的线程</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结put的流程：</p>
<ol>
<li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</li>
<li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notEmpty（消费者）的线程。</li>
</ol>
<p><strong>take操作的源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p>
<ol>
<li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</li>
<li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notFull（生产者）的线程。</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>put和take操作都需要<strong>先获取锁</strong>，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</li>
<li>就算拿到锁了之后，也<strong>不一定</strong>会顺利进行put&#x2F;take操作，需要判断<strong>队列是否可用</strong>（是否满&#x2F;空），如果不可用，则会被阻塞，<strong>并释放锁</strong>。</li>
<li>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，<strong>依然需要拿到锁</strong>才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。</li>
</ol>
<h4 id="示例和使用场景"><a href="#示例和使用场景" class="headerlink" title="示例和使用场景"></a>示例和使用场景</h4><h5 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(queueSize);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>();<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            consume();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;从队列取走一个元素，队列剩余&quot;</span>+queue.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            produce();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.put(<span class="hljs-number">1</span>);<br>                    System.out.println(<span class="hljs-string">&quot;向队列取中插入一个元素，队列剩余空间：&quot;</span>+(queueSize-queue.size()));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是这个例子的输出片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">从队列取走一个元素，队列剩余0个元素<br>从队列取走一个元素，队列剩余0个元素<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：9<br>向队列取中插入一个元素，队列剩余空间：8<br>向队列取中插入一个元素，队列剩余空间：7<br>向队列取中插入一个元素，队列剩余空间：6<br>向队列取中插入一个元素，队列剩余空间：5<br>向队列取中插入一个元素，队列剩余空间：4<br>向队列取中插入一个元素，队列剩余空间：3<br>向队列取中插入一个元素，队列剩余空间：2<br>向队列取中插入一个元素，队列剩余空间：1<br>向队列取中插入一个元素，队列剩余空间：0<br>从队列取走一个元素，队列剩余1个元素<br>从队列取走一个元素，队列剩余9个元素<br></code></pre></td></tr></table></figure>

<p>注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于<strong>put操作和System.out.println语句这两个操作没有上锁</strong>。考虑到这样的情况：线程1在执行完put&#x2F;take操作后立即失去CPU时间片，然后切换到线程2执行put&#x2F;take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put&#x2F;take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。</p>
<h5 id="线程池中使用阻塞队列"><a href="#线程池中使用阻塞队列" class="headerlink" title="线程池中使用阻塞队列"></a>线程池中使用阻塞队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                           TimeUnit unit,</span><br><span class="hljs-params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>             Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java中的线程池就是使用阻塞队列实现的，我们在了解阻塞队列之后，无论是使用Executors类中已经提供的线程池，还是自己通过ThreadPoolExecutor实现线程池，都会更加得心应手，想要了解线程池的同学，可以看<a target="_blank" rel="noopener" href="http://concurrent.redspider.group/article/03/12.html">第十二章</a>：线程池原理。</p>
<blockquote>
<p>注：上面提到了生产者-消费者模式，大家可以参考<a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=b4babef5d090f87cea8a97632f380c00">生产者-消费者模型</a>，可以更好的理解阻塞队列。</p>
</blockquote>
<h3 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h3><p>前面我们介绍了Java原生的锁——基于对象的锁，它一般是配合synchronized关键字来使用的。实际上，Java在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。</p>
<h4 id="synchronized-的不足之处"><a href="#synchronized-的不足之处" class="headerlink" title="synchronized 的不足之处"></a>synchronized 的不足之处</h4><p>我们先来看看<code>synchronized</code>有什么不足之处。</p>
<ul>
<li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li>
<li>synchronized无法知道线程有没有成功获取到锁</li>
<li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>
</ul>
<p>而这些都是locks包下的锁可以解决的。</p>
<h4 id="锁的几种分类"><a href="#锁的几种分类" class="headerlink" title="锁的几种分类"></a>锁的几种分类</h4><p>锁可以根据以下几种方式来进行分类，下面我们逐一介绍。</p>
<h5 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h5><p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p>
<p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p>
<p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p>
<p><code>ReentrantLock</code>的中文意思就是可重入锁。也是本文后续要介绍的重点类。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p>
<p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p>
<p>ReentrantLock支持非公平锁和公平锁两种。</p>
<h5 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h5><p>我们前面讲到的synchronized用的锁和ReentrantLock，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。</p>
<p>而读写锁可以在同一时刻允许多个读线程访问。Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<blockquote>
<p>注意，即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。</p>
</blockquote>
<p><strong>可见，只是synchronized是远远不能满足多样化的业务对锁的要求的</strong>。接下来我们介绍一下JDK中有关锁的一些接口和类。</p>
<h4 id="JDK中有关锁的一些接口和类"><a href="#JDK中有关锁的一些接口和类" class="headerlink" title="JDK中有关锁的一些接口和类"></a>JDK中有关锁的一些接口和类</h4><p>众所周知，JDK中关于并发的类大多都在<code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包看名字就知道，是提供了一些并发锁的工具类的。前面我们介绍的AQS（AbstractQueuedSynchronizer）就是在这个包下。下面分别介绍一下这个包下的类和接口以及它们之间的关系。</p>
<h5 id="抽象类AQS-AQLS-AOS"><a href="#抽象类AQS-AQLS-AOS" class="headerlink" title="抽象类AQS&#x2F;AQLS&#x2F;AOS"></a>抽象类AQS&#x2F;AQLS&#x2F;AOS</h5><p>这三个抽象类有一定的关系，所以这里放到一起讲。</p>
<p>首先我们看<strong>AQS</strong>（AbstractQueuedSynchronizer），之前专门有章节介绍这个类，它是在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围，所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型。</p>
<p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。从源码类上的注释可以知道，它是用于表示锁与持有者之间的关系（独占模式）。可以看一下它的主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 独占模式，锁的持有者  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;  <br><br><span class="hljs-comment">// 设置锁持有者  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread t)</span> &#123;  <br>    exclusiveOwnerThread = t;  <br>&#125;  <br><br><span class="hljs-comment">// 获取锁的持有线程  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> exclusiveOwnerThread;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="接口Condition-Lock-ReadWriteLock"><a href="#接口Condition-Lock-ReadWriteLock" class="headerlink" title="接口Condition&#x2F;Lock&#x2F;ReadWriteLock"></a>接口Condition&#x2F;Lock&#x2F;ReadWriteLock</h5><p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Lock接口中有一个方法是可以获得一个<code>Condition</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>之前我们提到了每个对象都可以用继承自<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待&#x2F;通知模式。</p>
<p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object监视器</th>
<th>Condition</th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用，比如object.notify()</td>
<td>直接调用，比如condition.await()</td>
</tr>
<tr>
<td>等待队列的个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态，在等待状态中不中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态直到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>Condition和Object的wait&#x2F;notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal&#x2F;signalAll</strong>方法则对应Object的notify&#x2F;notifyAll()。但Condition类似于Object的等待&#x2F;通知机制的加强版。我们来看看主要的方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal&#x2F;signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td>
</tr>
<tr>
<td>awaitUninterruptibly()</td>
<td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td>
</tr>
<tr>
<td>awaitNanos(long)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td>
</tr>
<tr>
<td>awaitUntil(Date)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td>
</tr>
<tr>
<td>signal()</td>
<td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td>
</tr>
<tr>
<td>signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td>
</tr>
</tbody></table>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个”可重入“锁，从源码上看，它内部有一个抽象类<code>Sync</code>，是继承了AQS，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类<code>NonfairSync</code>和<code>FairSync</code>，它们都继承了Sync。从名字上看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着ReentrantLock可以支持”公平锁“和”非公平锁“。</p>
<p>通过看这两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了AOS的<code>setExclusiveOwnerThread</code>方法，所以ReentrantLock的锁是”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p>
<p>在ReentrantLock的构造方法里，可以传入一个<code>boolean</code>类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过<code>isFair()</code>方法来查看。</p>
<h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p>
<p>ReentrantReadWriteLock内部的结构大概是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部结构</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<br><span class="hljs-keyword">final</span> Sync sync;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReadLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>            sync = lock.sync;<br>    &#125;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">WriteLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>            sync = lock.sync;<br>    &#125;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br><br><span class="hljs-comment">// 构造方法，初始化两个锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 获取读锁和写锁的方法</span><br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> writerLock; &#125;<br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> readerLock; &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，它同样是内部维护了两个同步器。且维护了两个Lock的实现类ReadLock和WriteLock。从源码可以发现，这两个内部类用的是外部类的同步器。</p>
<p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”，将在后文的StampedLock类继续讨论这个问题。</p>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p><code>StampedLock</code>类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p>
<p>前面提到了ReentrantReadWriteLock会发生“写饥饿”的现象，但StampedLock不会。它是怎么做到的呢？它的核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p>
<p>这里篇幅有限，就不介绍StampedLock的源码了，只是分析一下官方提供的用法（在JDK源码类声明的上方或Javadoc里可以找到）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>   <span class="hljs-comment">// 写锁的使用</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       x += deltaX;<br>       y += deltaY;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>     &#125;<br>   &#125;<br><br>   <span class="hljs-comment">// 乐观读锁的使用</span><br>   <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead(); <span class="hljs-comment">// 获取乐观读锁</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>     <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123; <span class="hljs-comment">// //检查乐观读锁后是否有其他写锁发生，有则返回false</span><br>        stamp = sl.readLock(); <span class="hljs-comment">// 获取一个悲观读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          currentX = x;<br>          currentY = y;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           sl.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>        &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>   &#125;<br><br>   <span class="hljs-comment">// 悲观读锁以及读锁升级写锁的使用</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveIfAtOrigin</span><span class="hljs-params">(<span class="hljs-type">double</span> newX, <span class="hljs-type">double</span> newY)</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.readLock(); <span class="hljs-comment">// 悲观读锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;<br>         <span class="hljs-comment">// 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用</span><br>         <span class="hljs-type">long</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> sl.tryConvertToWriteLock(stamp); <br><br>         <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0L</span>) &#123; <span class="hljs-comment">// 如果转换成功</span><br>           stamp = ws; <span class="hljs-comment">// 读锁的票据更新为写锁的</span><br>           x = newX;<br>           y = newY;<br>           <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果转换失败</span><br>           sl.unlockRead(stamp); <span class="hljs-comment">// 释放读锁</span><br>           stamp = sl.writeLock(); <span class="hljs-comment">// 强制获取写锁</span><br>         &#125;<br>       &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlock(stamp); <span class="hljs-comment">// 释放所有锁</span><br>     &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>乐观读锁的意思就是先假定在这个锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个悲观读锁，这里的悲观读锁和ReentrantReadWriteLock中的读锁类似，也是个共享锁。</p>
</blockquote>
<p>可以看到，StampedLock获取锁会返回一个<code>long</code>类型的变量，释放锁的时候再把这个变量传进去。简单看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于操作state后获取stamp的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LG_READERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RUNIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;               <span class="hljs-comment">//0000 0000 0001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">WBIT</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> &lt;&lt; LG_READERS; <span class="hljs-comment">//0000 1000 0000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RBITS</span> <span class="hljs-operator">=</span> WBIT - <span class="hljs-number">1L</span>;        <span class="hljs-comment">//0000 0111 1111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RFULL</span> <span class="hljs-operator">=</span> RBITS - <span class="hljs-number">1L</span>;       <span class="hljs-comment">//0000 0111 1110</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ABITS</span> <span class="hljs-operator">=</span> RBITS | WBIT;     <span class="hljs-comment">//0000 1111 1111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SBITS</span> <span class="hljs-operator">=</span> ~RBITS;           <span class="hljs-comment">//1111 1000 0000</span><br><br><span class="hljs-comment">// 初始化时state的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ORIGIN</span> <span class="hljs-operator">=</span> WBIT &lt;&lt; <span class="hljs-number">1</span>;       <span class="hljs-comment">//0001 0000 0000</span><br><br><span class="hljs-comment">// 锁共享变量state</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br><span class="hljs-comment">// 读锁溢出时用来存储多出的读锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> readerOverflow;<br></code></pre></td></tr></table></figure>

<p>StampedLock用这个long类型的变量的前7位（LG_READERS）来表示读锁，每获取一个悲观读锁，就加1（RUNIT），每释放一个悲观读锁，就减1。而悲观读锁最多只能装128个（7位限制），很容易溢出，所以用一个int类型的变量来存储溢出的悲观读锁。</p>
<p>写锁用state变量剩下的位来表示，每次获取一个写锁，就加0000 1000 0000（WBIT）。需要注意的是，<strong>写锁在释放的时候，并不是减WBIT，而是再加WBIT</strong>。这是为了<strong>让每次写锁都留下痕迹</strong>，解决CAS中的ABA问题，也为<strong>乐观锁检查变化</strong>validate方法提供基础。</p>
<p>乐观读锁就比较简单了，并没有真正改变state的值，而是在获取锁的时候记录state的写状态，在操作完成后去检查state的写状态部分是否发生变化，上文提到了，每次写锁都会留下痕迹，也是为了这里乐观锁检查变化提供方便。</p>
<p>总的来说，StampedLock的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用</p>
<h3 id="并发容器集合"><a href="#并发容器集合" class="headerlink" title="并发容器集合"></a>并发容器集合</h3><h4 id="同步容器与并发容器"><a href="#同步容器与并发容器" class="headerlink" title="同步容器与并发容器"></a>同步容器与并发容器</h4><p>我们知道在java.util包下提供了一些容器类，而Vector和Hashtable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p>
<p>而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVector</span> &#123;<br>    <span class="hljs-keyword">private</span> Vector&lt;String&gt; vector;<br><br>    <span class="hljs-comment">//方法一</span><br>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">getLast</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> vector.get(lastIndex);<br>    &#125;<br><br>    <span class="hljs-comment">//方法二</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLast</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>        vector.remove(lastIndex);<br>    &#125;<br><br>    <span class="hljs-comment">//方法三</span><br>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">getLastSysnchronized</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(vector)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> vector.get(lastIndex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//方法四</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLastSysnchronized</span><span class="hljs-params">(Vector vector)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (vector)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> vector.size() - <span class="hljs-number">1</span>;<br>            vector.remove(lastIndex);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果方法一和方法二为一个组合的话。那么当方法一获取到了<code>vector</code>的size之后，方法二已经执行完毕，这样就导致程序的错误。</p>
<p>如果方法三与方法四组合的话。通过锁机制保证了在<code>vector</code>上的操作的原子性。</p>
<p>并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。</p>
<h4 id="并发容器类介绍"><a href="#并发容器类介绍" class="headerlink" title="并发容器类介绍"></a>并发容器类介绍</h4><p>整体架构(列举常用的容器类)<img src="/posts/60838/1.png" srcset="/img/loading.gif" lazyload alt="并发容器"></p>
<p>其中，阻塞队列（BlockingQueue）在<a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a>有介绍，CopyOnWrite容器（CopyOnWritexxx）在<a href="#CopyOnWrite">CopyOnWrite</a>有介绍，这里不做过多介绍。</p>
<p>下面分别介绍一些常用的并发容器类和接口，因篇幅原因，这里只介绍这些类的用途和基本的原理，不做过多的源码解析。</p>
<h4 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h4><h5 id="ConcurrentMap接口"><a href="#ConcurrentMap接口" class="headerlink" title="ConcurrentMap接口"></a>ConcurrentMap接口</h5><p>ConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-comment">//插入元素</span><br>    V <span class="hljs-title function_">putIfAbsent</span><span class="hljs-params">(K key, V value)</span>;<br><br>    <span class="hljs-comment">//移除元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key, Object value)</span>;<br><br>    <span class="hljs-comment">//替换元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span>;<br><br>    <span class="hljs-comment">//替换元素</span><br>    V <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V value)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>putIfAbsent：</strong>与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；</p>
<p><strong>remove：</strong>与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;</p>
<p><strong>replace(K,V,V)：</strong>增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；</p>
<p><strong>replace(K,V)：</strong>与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；</p>
<h5 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h5><p>ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与Hashtable完全不同的加锁策略，提供更高效的并发性和伸缩性。</p>
<p>ConcurrentHashMap在JDK 1.7 和JDK 1.8中有一些区别。这里我们分开介绍一下。</p>
<p><strong>JDK 1.7</strong></p>
<p>ConcurrentHashMap在JDK 1.7中，提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。</p>
<p>提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。</p>
<p>可以这样理解分段锁，就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图：<img src="/posts/60838/2.png" srcset="/img/loading.gif" lazyload alt="分段锁机制"></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><strong>JDK 1.8</strong></p>
<p>而在JDK 1.8中，ConcurrentHashMap主要做了两个优化：</p>
<ul>
<li>同HashMap一样，链表也会在长度达到8的时候转化为红黑树，这样可以提升大量冲突时候的查询效率；</li>
<li>以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合自旋+CAS避免不必要的锁开销，进一步提升并发性能。</li>
</ul>
<p>对ConcurrentHashMap源码感兴趣的朋友可以看看这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yasinshaw.com/articles/27">https://yasinshaw.com/articles/27</a></li>
<li><a target="_blank" rel="noopener" href="https://yasinshaw.com/articles/30">https://yasinshaw.com/articles/30</a></li>
</ul>
<h5 id="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"><a href="#ConcurrentNavigableMap接口与ConcurrentSkipListMap类" class="headerlink" title="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"></a>ConcurrentNavigableMap接口与ConcurrentSkipListMap类</h5><p>ConcurrentNavigableMap接口继承了NavigableMap接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p>
<p>ConcurrentNavigableMap接口的主要实现类是ConcurrentSkipListMap类。从名字上来看，它的底层使用的是跳表（SkipList）的数据结构。关于跳表的数据结构这里不做太多介绍，它是一种”空间换时间“的数据结构，可以使用CAS来保证并发安全性。</p>
<h5 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h5><p>JDK并没有提供线程安全的List类，因为对List来说，<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的List</strong>。因为即使简单的读操作，拿contains() 这样一个操作来说，很难想到搜索的时候如何避免锁住整个list。</p>
<p>所以退一步，JDK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedQueue和ConcurrentLinkedDeque。因为队列相对于List来说，有更多的限制。这两个类是使用CAS来实现线程安全的。</p>
<h5 id="并发Set"><a href="#并发Set" class="headerlink" title="并发Set"></a>并发Set</h5><p>JDK提供了ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</p>
<p>谷歌的guava框架实现了一个线程安全的ConcurrentHashSet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; s = Sets.newConcurrentHashSet();<br></code></pre></td></tr></table></figure>

<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><h4 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h4><p>在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p>
<p>那什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p>
<p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>
<p>这样做的好处在于，我们可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。我们着重给大家介绍一下CopyOnWriteArrayList。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p><strong>优点</strong>： CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。在Java中遍历线程非安全的List(如：ArrayList和 LinkedList)的时候，若中途有别的线程对List容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，则不会抛出异常。</p>
<p><strong>缺点</strong>： 第一个缺点是CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC因为没有使用Full GC）。比如这些对象占用的内存200M左右，那么再写入100M数据进去，内存就会多占用300M。</p>
<p>第二个缺点是CopyOnWriteArrayList由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。</p>
<p>现在我们来看一下CopyOnWriteArrayList的add操作源码，它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br><br>    <span class="hljs-comment">// ReentrantLock加锁，保证线程安全</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 拷贝原容器，长度为原容器长度加一</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 在新副本上执行添加操作</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// 将原容器引用指向新副本</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看一下remove操作的源码，remove的逻辑是将要remove元素之外的其他元素拷贝到新的副本中，然后再将原容器的引用指向新的副本中，因为remove操作也是“写操作”所以也是要加锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><br>        <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object[] elements = getArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(elements, index);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> len - index - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span><br>                setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将要删除元素之外的其他元素拷贝到新副本中，并切换引用</span><br>                Object[] newElements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[len - <span class="hljs-number">1</span>];<br>                System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>                System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                                 numMoved);<br>                setArray(newElements);<br>            &#125;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看看CopyOnWriteArrayList效率最高的读操作的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br> <span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>     <span class="hljs-keyword">return</span> (E) a[index];<br> &#125;<br></code></pre></td></tr></table></figure>

<p>由上可见“读操作”是没有加锁，直接读取。</p>
<h4 id="CopyOnWrite的业务中实现"><a href="#CopyOnWrite的业务中实现" class="headerlink" title="CopyOnWrite的业务中实现"></a>CopyOnWrite的业务中实现</h4><p>接下来，我们结合具体业务场景来实现一个CopyOnWriteMap的并发容器并且使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnWriteMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt;, Cloneable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;K, V&gt; internalMap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteMap</span><span class="hljs-params">()</span> &#123;<br>        internalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            Map&lt;K, V&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;(internalMap);<br>            <span class="hljs-type">V</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> newMap.put(key, value);<br>            internalMap = newMap;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalMap.get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; newData)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            Map&lt;K, V&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt;(internalMap);<br>            newMap.putAll(newData);<br>            internalMap = newMap;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是参考CopyOnWriteArrayList实现的CopyOnWriteMap，我们可以用这个容器来做什么呢？结合我们之前说的CopyOnWrite的复制思想，它最适用于“读多写少”的并发场景。</p>
<p><strong>场景：</strong>假如我们有一个搜索的网站需要屏蔽一些“关键字”，“黑名单”每晚定时更新，每当用户搜索的时候，“黑名单”中的关键字不会出现在搜索结果当中，并且提示用户敏感字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 黑名单服务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListServiceImpl</span> &#123;<br>    <span class="hljs-comment">//　减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteMap</span>&lt;String, Boolean&gt;(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlackList</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> blackListMap.get(id) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBlackList</span><span class="hljs-params">(String id)</span> &#123;<br>        blackListMap.put(id, Boolean.TRUE);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量添加黑名单</span><br><span class="hljs-comment">     * (使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</span><br><span class="hljs-comment">     * 如使用上面代码里的addBlackList方法)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBlackList</span><span class="hljs-params">(Map&lt;String,Boolean&gt; ids)</span> &#123;<br>        blackListMap.putAll(ids);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要各位小伙伴特别特别注意一个问题，此处的场景是每晚凌晨“黑名单”定时更新，原因是CopyOnWrite容器有<strong>数据一致性</strong>的问题，它只能保证<strong>最终数据一致性</strong>。</p>
<p>所以如果我们希望写入的数据马上能准确地读取，请不要使用CopyOnWrite容器</p>
<h3 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h3><p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p>
<p>它们都在java.util.concurrent包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphore</td>
<td>限制线程的数量</td>
</tr>
<tr>
<td>Exchanger</td>
<td>两个线程交换数据</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>线程等待直到计数器减为0时开始工作</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>作用跟CountDownLatch类似，但是可以重复使用</td>
</tr>
<tr>
<td>Phaser</td>
<td>增强的CyclicBarrier</td>
</tr>
</tbody></table>
<p>下面分别介绍这几个类。</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h5 id="Semaphore介绍"><a href="#Semaphore介绍" class="headerlink" title="Semaphore介绍"></a>Semaphore介绍</h5><p>Semaphore翻译过来是信号的意思。顾名思义，这个工具类提供的功能就是多个线程彼此“打信号”。而这个“信号”是一个<code>int</code>类型的数据，也可以看成是一种“资源”。</p>
<p>可以在构造函数中传入初始资源总数，以及是否使用“公平”的同步器。默认情况下，是非公平的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认情况下使用非公平</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。当然，你也可以申请多个acquire(int permits)或者释放多个release(int permits)。</p>
<p>每次acquire，permits就会减少一个或者多个。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p>
<h5 id="Semaphore案例"><a href="#Semaphore案例" class="headerlink" title="Semaphore案例"></a>Semaphore案例</h5><p>Semaphore往往用于资源有限的场景中，去限制线程的数量。举个例子，我想限制同时只能有3个线程在工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">private</span> Semaphore semaphore;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Semaphore semaphore)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.semaphore = semaphore;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire(); <span class="hljs-comment">// 获取permit</span><br>                System.out.println(String.format(<span class="hljs-string">&quot;当前线程是%d, 还剩%d个资源，还有%d个线程在等待&quot;</span>,<br>                        value, semaphore.availablePermits(), semaphore.getQueueLength()));<br>                <span class="hljs-comment">// 睡眠随机时间，打乱释放顺序</span><br>                <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                System.out.println(String.format(<span class="hljs-string">&quot;线程%d释放了资源&quot;</span>, value));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span>&#123;<br>                semaphore.release(); <span class="hljs-comment">// 释放permit</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(i, semaphore)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>当前线程是1, 还剩2个资源，还有0个线程在等待<br>当前线程是0, 还剩1个资源，还有0个线程在等待<br>当前线程是6, 还剩0个资源，还有0个线程在等待<br>线程6释放了资源<br>当前线程是2, 还剩0个资源，还有6个线程在等待<br>线程2释放了资源<br>当前线程是4, 还剩0个资源，还有5个线程在等待<br>线程0释放了资源<br>当前线程是7, 还剩0个资源，还有4个线程在等待<br>线程1释放了资源<br>当前线程是8, 还剩0个资源，还有3个线程在等待<br>线程7释放了资源<br>当前线程是5, 还剩0个资源，还有2个线程在等待<br>线程4释放了资源<br>当前线程是3, 还剩0个资源，还有1个线程在等待<br>线程8释放了资源<br>当前线程是9, 还剩0个资源，还有0个线程在等待<br>线程9释放了资源<br>线程5释放了资源<br>线程3释放了资源</p>
</blockquote>
<p>可以看到，在这次运行中，最开始是1, 0, 6这三个线程获得了资源，而其它线程进入了等待队列。然后当某个线程释放资源后，就会有等待队列中的线程获得资源。</p>
<p>当然，Semaphore默认的acquire方法是会让线程进入等待队列，且会抛出中断异常。但它还有一些方法可以忽略中断或不进入阻塞队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 忽略中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><br><span class="hljs-comment">// 不进入等待队列，底层使用CAS</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> tryAcquire<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>

<h5 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h5><p>Semaphore内部有一个继承了AQS的同步器Sync，重写了<code>tryAcquireShared</code>方法。在这个方法里，会去尝试获取资源。</p>
<p>如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</p>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。先来一个案例看看如何使用，比如两个线程之间想要传送字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是线程A，得到了另一个线程的数据：&quot;</span><br>                        + exchanger.exchange(<span class="hljs-string">&quot;这是来自线程A的数据&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;这个时候线程A是阻塞的，在等待线程B的数据&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是线程B，得到了另一个线程的数据：&quot;</span><br>                        + exchanger.exchange(<span class="hljs-string">&quot;这是来自线程B的数据&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>这个时候线程A是阻塞的，在等待线程B的数据<br>这是线程B，得到了另一个线程的数据：这是来自线程A的数据<br>这是线程A，得到了另一个线程的数据：这是来自线程B的数据</p>
</blockquote>
<p>可以看到，当一个线程调用exchange方法后，它是处于阻塞状态的，只有当另一个线程也调用了exchange方法，它才会继续向下执行。看源码可以发现它是使用park&#x2F;unpark来实现等待状态的切换的，但是在使用park&#x2F;unpark方法之前，使用了CAS检查，估计是为了提高性能。</p>
<p>Exchanger一般用于两个线程之间更方便地在内存中交换数据，因为其支持泛型，所以我们可以传输任何的数据，比如IO流或者IO缓存。根据JDK里面的注释的说法，可以总结为一下特性：</p>
<ul>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ul>
<p>Exchanger类还有一个有超时参数的方法，如果在指定时间内没有另一个线程调用exchange，就会抛出一个超时异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">exchange</span><span class="hljs-params">(V x, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>

<p>那么问题来了，Exchanger只能是两个线程交换数据吗？那三个调用同一个实例的exchange方法会发生什么呢？答案是只有前两个线程会交换数据，第三个线程会进入阻塞状态。</p>
<p>需要注意的是，exchange是可以重复使用的。也就是说。两个线程可以使用Exchanger在内存中不断地再交换数据。</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h5 id="CountDownLatch介绍"><a href="#CountDownLatch介绍" class="headerlink" title="CountDownLatch介绍"></a>CountDownLatch介绍</h5><p>先来解读一下CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p>
<p>CountDownLatch的方法也很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-comment">// 等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-comment">// 超时等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> <span class="hljs-comment">// count - 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前还有多少count</span><br></code></pre></td></tr></table></figure>

<h5 id="CountDownLatch案例"><a href="#CountDownLatch案例" class="headerlink" title="CountDownLatch案例"></a>CountDownLatch案例</h5><p>我们知道，玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。下面我们就来模拟一下这个demo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-comment">// 定义前置任务线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, CountDownLatch countDownLatch)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.countDownLatch = countDownLatch;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                System.out.println(task + <span class="hljs-string">&quot; - 任务完成&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 假设有三个模块需要加载</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 主任务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;等待数据加载...&quot;</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;还有%d个前置任务&quot;</span>, countDownLatch.getCount()));<br>                countDownLatch.await();<br>                System.out.println(<span class="hljs-string">&quot;数据加载完成，正式开始游戏！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 前置任务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, countDownLatch)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>等待数据加载…<br>还有3个前置任务<br>加载人物模型 - 任务完成<br>加载背景音乐 - 任务完成<br>加载地图数据 - 任务完成<br>数据加载完成，正式开始游戏！</p>
</blockquote>
<h5 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h5><p>其实CountDownLatch类的原理挺简单的，内部同样是一个继承了AQS的实现类Sync，且实现起来还很简单，可能是JDK里面AQS的子类中最简单的实现了，有兴趣的读者可以去看看这个内部类的源码。</p>
<p>需要注意的是构造器中的<strong>计数值（count）实际上就是闭锁需要等待的线程数量</strong>。这个值只能被设置一次，而且CountDownLatch<strong>没有提供任何机制去重新设置这个计数值</strong>。</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h5 id="CyclicBarrier介绍"><a href="#CyclicBarrier介绍" class="headerlink" title="CyclicBarrier介绍"></a>CyclicBarrier介绍</h5><p>CyclicBarrirer从名字上来理解是“循环的屏障”的意思。前面提到了CountDownLatch一旦计数值<code>count</code>被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用<code>reset()</code>方法重置屏障。</p>
<h5 id="CyclicBarrier-Barrier被破坏"><a href="#CyclicBarrier-Barrier被破坏" class="headerlink" title="CyclicBarrier Barrier被破坏"></a>CyclicBarrier Barrier被破坏</h5><p>如果参与者（线程）在等待的过程中，Barrier被破坏，就会抛出BrokenBarrierException。可以用<code>isBroken()</code>方法检测Barrier是否被破坏。</p>
<ol>
<li>如果有线程已经处于等待状态，调用reset方法会导致已经在等待的线程出现BrokenBarrierException异常。并且由于出现了BrokenBarrierException，将会导致始终无法等待。</li>
<li>如果在等待的过程中，线程被中断，会抛出InterruptedException异常，并且这个异常会传播到其他所有的线程。</li>
<li>如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，其他线程会抛出BrokenBarrierException，屏障被损坏。</li>
<li>如果超出指定的等待时间，当前线程会抛出 TimeoutException 异常，其他线程会抛出BrokenBarrierException异常。</li>
</ol>
<h5 id="CyclicBarrier案例"><a href="#CyclicBarrier案例" class="headerlink" title="CyclicBarrier案例"></a>CyclicBarrier案例</h5><p>我们同样用玩游戏的例子。如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, CyclicBarrier cyclicBarrier)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 假设总共三个关卡</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                    System.out.println(String.format(<span class="hljs-string">&quot;关卡%d的任务%s完成&quot;</span>, i, task));<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;本关卡所有前置任务完成，开始游戏...&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, cyclicBarrier)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, cyclicBarrier)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, cyclicBarrier)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>关卡1的任务加载地图数据完成<br>关卡1的任务加载背景音乐完成<br>关卡1的任务加载人物模型完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡2的任务加载地图数据完成<br>关卡2的任务加载背景音乐完成<br>关卡2的任务加载人物模型完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡3的任务加载人物模型完成<br>关卡3的任务加载地图数据完成<br>关卡3的任务加载背景音乐完成<br>本关卡所有前置任务完成，开始游戏…</p>
</blockquote>
<p>注意这里跟CountDownLatch的代码有一些不同。CyclicBarrier没有分为<code>await()</code>和<code>countDown()</code>，而是只有单独的一个<code>await()</code>方法。</p>
<p>一旦调用await()方法的线程数量等于构造方法中传入的任务总量（这里是3），就代表达到屏障了。CyclicBarrier允许我们在达到屏障的时候可以执行一个任务，可以在构造方法传入一个Runnable类型的对象。上述案例就是在达到屏障时，输出“本关卡所有前置任务完成，开始游戏…”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="CyclicBarrier原理"><a href="#CyclicBarrier原理" class="headerlink" title="CyclicBarrier原理"></a>CyclicBarrier原理</h5><p>CyclicBarrier虽说功能与CountDownLatch类似，但是实现原理却完全不同，CyclicBarrier内部使用的是Lock + Condition实现的等待&#x2F;通知模式。详情可以查看这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br></code></pre></td></tr></table></figure>

<h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><h5 id="Phaser介绍"><a href="#Phaser介绍" class="headerlink" title="Phaser介绍"></a>Phaser介绍</h5><p>Phaser这个单词是“移相器，相位器”的意思（好吧，笔者并不懂这是什么玩意，下方资料来自百度百科）。这个类是从JDK 1.7 中出现的。</p>
<blockquote>
<p>移相器（Phaser）能够对波的相位进行调整的一种装置。任何传输介质对在其中传导的波动都会引入相移，这是早期模拟移相器的原理；现代电子技术发展后利用A&#x2F;D、D&#x2F;A转换实现了数字移相，顾名思义，它是一种不连续的移相技术，但特点是移相精度高。 移相器在雷达、导弹姿态控制、加速器、通信、仪器仪表甚至于音乐等领域都有着广泛的应用</p>
</blockquote>
<p>Phaser类有点复杂，这里只介绍一些基本的用法和知识点。详情可以查看JDK文档，文档里有这个类非常详尽的介绍。</p>
<p>前面我们介绍了CyclicBarrier，可以发现它在构造方法里传入“任务总量”<code>parties</code>之后，就不能修改这个值了，并且每次调用<code>await()</code>方法也只能消耗一个<code>parties</code>计数。但Phaser可以动态地调整任务总量！</p>
<p>名词解释：</p>
<ul>
<li>party：对应一个线程，数量可以通过register或者构造参数传入;</li>
<li>arrive：对应一个party的状态，初始时是unarrived，当调用<code>arriveAndAwaitAdvance()</code>或者 <code>arriveAndDeregister()</code>进入arrive状态，可以通过<code>getUnarrivedParties()</code>获取当前未到达的数量;</li>
<li>register：注册一个party，每一阶段必须所有注册的party都到达才能进入下一阶段;</li>
<li>deRegister：减少一个party。</li>
<li>phase：阶段，当所有注册的party都arrive之后，将会调用Phaser的<code>onAdvance()</code>方法来判断是否要进入下一阶段。</li>
</ul>
<p>Phaser终止的两种途径，Phaser维护的线程执行完毕或者<code>onAdvance()</code>返回<code>true</code> 此外Phaser还能维护一个树状的层级关系，构造的时候new Phaser(parentPhaser)，对于Task执行时间短的场景（竞争激烈），也就是说有大量的<strong>party</strong>, 那可以把每个Phaser的任务量设置较小，多个Phaser共同继承一个父Phaser。</p>
<blockquote>
<p>Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent. This may greatly increase throughput even though it incurs greater per-operation overhead.</p>
<p>翻译：如果有大量的party，那许多线程可能同步的竞争成本比较高。所以可以拆分成多个子Phaser共享一个共同的父Phaser。这可能会大大增加吞吐量，即使它会带来更多的每次操作开销。</p>
</blockquote>
<h5 id="Phaser案例"><a href="#Phaser案例" class="headerlink" title="Phaser案例"></a>Phaser案例</h5><p>还是游戏的案例。假设我们游戏有三个关卡，但只有第一个关卡有新手教程，需要加载新手教程模块。但后面的第二个关卡和第三个关卡都不需要。我们可以用Phaser来做这个需求。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreTaskThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String task;<br>        <span class="hljs-keyword">private</span> Phaser phaser;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreTaskThread</span><span class="hljs-params">(String task, Phaser phaser)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.phaser = phaser;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 第二次关卡起不加载NPC，跳过</span><br>                    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-string">&quot;加载新手教程&quot;</span>.equals(task)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<br>                    System.out.println(String.format(<span class="hljs-string">&quot;关卡%d，需要加载%d个模块，当前模块【%s】&quot;</span>,<br>                            i, phaser.getRegisteredParties(), task));<br><br>                    <span class="hljs-comment">// 从第二个关卡起，不加载NPC</span><br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">&quot;加载新手教程&quot;</span>.equals(task)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;下次关卡移除加载【新手教程】模块&quot;</span>);<br>                        phaser.arriveAndDeregister(); <span class="hljs-comment">// 移除一个模块</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        phaser.arriveAndAwaitAdvance();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phaser</span> <span class="hljs-variable">phaser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phaser</span>(<span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onAdvance</span><span class="hljs-params">(<span class="hljs-type">int</span> phase, <span class="hljs-type">int</span> registeredParties)</span> &#123;<br>                System.out.println(String.format(<span class="hljs-string">&quot;第%d次关卡准备完成&quot;</span>, phase + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">return</span> phase == <span class="hljs-number">3</span> || registeredParties == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载地图数据&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载人物模型&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载背景音乐&quot;</span>, phaser)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PreTaskThread</span>(<span class="hljs-string">&quot;加载新手教程&quot;</span>, phaser)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>关卡1，需要加载4个模块，当前模块【加载背景音乐】<br>关卡1，需要加载4个模块，当前模块【加载新手教程】<br>下次关卡移除加载【新手教程】模块<br>关卡1，需要加载3个模块，当前模块【加载地图数据】<br>关卡1，需要加载3个模块，当前模块【加载人物模型】<br>第1次关卡准备完成<br>关卡2，需要加载3个模块，当前模块【加载地图数据】<br>关卡2，需要加载3个模块，当前模块【加载背景音乐】<br>关卡2，需要加载3个模块，当前模块【加载人物模型】<br>第2次关卡准备完成<br>关卡3，需要加载3个模块，当前模块【加载人物模型】<br>关卡3，需要加载3个模块，当前模块【加载地图数据】<br>关卡3，需要加载3个模块，当前模块【加载背景音乐】<br>第3次关卡准备完成</p>
</blockquote>
<p>这里要注意关卡1的输出，在“加载新手教程”线程中调用了<code>arriveAndDeregister()</code>减少一个party之后，后面的线程使用<code>getRegisteredParties()</code>得到的是已经被修改后的parties了。但是当前这个阶段(phase)，仍然是需要4个parties都arrive才触发屏障的。从下一个阶段开始，才需要3个parties都arrive就触发屏障。</p>
<p>另外Phaser类用来控制某个阶段的线程数量很有用，但它并在意这个阶段具体有哪些线程arrive，只要达到它当前阶段的parties值，就触发屏障。所以我这里的案例虽然制定了特定的线程（加载新手教程）来更直观地表述Phaser的功能，但是其实Phaser是没有分辨具体是哪个线程的功能的，它在意的只是数量，这一点需要读者注意。</p>
<h5 id="Phaser原理"><a href="#Phaser原理" class="headerlink" title="Phaser原理"></a>Phaser原理</h5><p>Phaser类的原理相比起来要复杂得多。它内部使用了两个基于Fork-Join框架的原子类辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123;<br>    <span class="hljs-comment">// 实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有兴趣的读者可以去看看JDK源代码，这里不做过多叙述。</p>
<p>总的来说，CountDownLatch，CyclicBarrier，Phaser是一个比一个强大，但也一个比一个复杂。根据自己的业务需求合理选择即可</p>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><h4 id="什么是Fork-Join"><a href="#什么是Fork-Join" class="headerlink" title="什么是Fork&#x2F;Join"></a>什么是Fork&#x2F;Join</h4><p>Fork&#x2F;Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p>
<p>与其他ExecutorService相关的实现相同的是，Fork&#x2F;Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork&#x2F;Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p>
<p><strong>fork</strong>在英文里有分叉的意思，<strong>join</strong>在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。</p>
<p>Fork&#x2F;Join的运行流程大致如下所示：</p>
<p><img src="/posts/60838/fork_join.png" srcset="/img/loading.gif" lazyload alt="fork/join流程图"></p>
<p>需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">solve(任务):<br>    if(任务已经划分到足够小):<br>        顺序执行任务<br>    else:<br>        for(划分任务得到子任务)<br>            solve(子任务)<br>        结合所有子任务的结果到上一层循环<br>        return 最终结合的结果<br></code></pre></td></tr></table></figure>

<p>通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现<strong>分而治之(divide and conquer)</strong> 的算法思想。</p>
<h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p>
<p>工作窃取流程如下图所示：</p>
<p><img src="/posts/60838/3.png" srcset="/img/loading.gif" lazyload alt="工作窃取算法流程"></p>
<p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的<strong>头部</strong>拿任务执行，而窃取其他任务的线程从双端队列的<strong>尾部</strong>执行任务。</p>
<p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入<strong>阻塞状态</strong>以等待再次“工作”。</p>
<h4 id="Fork-Join的具体实现"><a href="#Fork-Join的具体实现" class="headerlink" title="Fork&#x2F;Join的具体实现"></a>Fork&#x2F;Join的具体实现</h4><p>前面我们说Fork&#x2F;Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有<strong>任务</strong>。在Fork&#x2F;Join框架里提供了抽象类<code>ForkJoinTask</code>来实现任务。</p>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p>
<p><strong>fork()方法</strong>:使用线程池中的空闲线程异步提交任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本文所有代码都引自Java 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-comment">// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理</span><br>    <span class="hljs-comment">// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>         <span class="hljs-comment">// 如果不是则将线程加入队列</span><br>        <span class="hljs-comment">// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实fork()只做了一件事，那就是<strong>把任务推入当前工作线程的工作队列里</strong>。</p>
<p><strong>join()方法</strong>：等待处理任务的线程处理完毕，获得返回值。</p>
<p>来看下join()的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-comment">// doJoin()方法来获取当前任务的执行状态</span><br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        <span class="hljs-comment">// 任务异常，抛出异常</span><br>        reportException(s);<br>    <span class="hljs-comment">// 任务正常完成，获取返回值</span><br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * doJoin()方法用来返回当前任务的执行状态</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <span class="hljs-comment">// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span><br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>    <span class="hljs-comment">// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span><br>    ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        <span class="hljs-comment">// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span><br>        <span class="hljs-comment">// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span><br>        <span class="hljs-comment">// doExec()方法执行任务</span><br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        <span class="hljs-comment">// 如果是处于顶端并且任务执行完毕，返回结果</span><br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        <span class="hljs-comment">// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span><br>        <span class="hljs-comment">// awaitJoin()：使用自旋使任务执行完成，返回结果</span><br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>    <span class="hljs-comment">// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span><br>    externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在之前介绍过说Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图：<img src="/posts/60838/join.png" srcset="/img/loading.gif" lazyload alt="join流程图"></p>
<p><strong>RecursiveAction和RecursiveTask</strong></p>
<p>通常情况下，在创建任务的时候我们一般不直接继承ForkJoinTask，而是继承它的子类<strong>RecursiveAction</strong>和<strong>RecursiveTask</strong>。</p>
<p>两个都是ForkJoinTask的子类，<strong>RecursiveAction可以看做是无返回值的ForkJoinTask，RecursiveTask是有返回值的ForkJoinTask</strong>。</p>
<p>此外，两个子类都有执行主要计算的方法compute()，当然，RecursiveAction的compute()返回void，RecursiveTask的compute()有具体的返回值。</p>
<h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</p>
<p>ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p>
<p>我们来大致看下ForkJoinPool的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues;   <br><br>    <span class="hljs-comment">// 线程的运行状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> runState;  <br><br>    <span class="hljs-comment">// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;<br><br>    <span class="hljs-comment">// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinPool common;<br><br>    <span class="hljs-comment">// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用</span><br>    <span class="hljs-comment">// 其他构造方法都是源自于此方法</span><br>    <span class="hljs-comment">// parallelism: 并行度，</span><br>    <span class="hljs-comment">// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                         ForkJoinWorkerThreadFactory factory, // 工作线程工厂</span><br><span class="hljs-params">                         UncaughtExceptionHandler handler, // 拒绝任务的handler</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> mode, // 同步模式</span><br><span class="hljs-params">                         String workerNamePrefix)</span> &#123; <span class="hljs-comment">// 线程名prefix</span><br>        <span class="hljs-built_in">this</span>.workerNamePrefix = workerNamePrefix;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.ueh = handler;<br>        <span class="hljs-built_in">this</span>.config = (parallelism &amp; SMASK) | mode;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">np</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(-parallelism); <span class="hljs-comment">// offset ctl counts</span><br>        <span class="hljs-built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>WorkQueue</strong></p>
<p>双端队列，ForkJoinTask存放在这里。</p>
<p>当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</p>
<p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个<strong>工作队列数组</strong>（volatile WorkQueue[] workQueues，ForkJoinPool中的<strong>每个工作线程都维护着一个工作队列</strong>）。</p>
<p><strong>runState</strong></p>
<p>ForkJoinPool的运行状态。<strong>SHUTDOWN</strong>状态用负数表示，其他用2的幂次表示。</p>
<h4 id="Fork-Join的使用"><a href="#Fork-Join的使用" class="headerlink" title="Fork&#x2F;Join的使用"></a>Fork&#x2F;Join的使用</h4><p>上面我们说ForkJoinPool负责管理线程和任务，ForkJoinTask实现fork和join操作，所以要使用Fork&#x2F;Join框架就离不开这两个类了，只是在实际开发中我们常用ForkJoinTask的子类RecursiveTask 和RecursiveAction来替代ForkJoinTask。</p>
<p>下面我们用一个计算斐波那契数列第n项的例子来看一下Fork&#x2F;Join的使用：</p>
<blockquote>
<p>斐波那契数列数列是一个线性递推数列，从第三项开始，每一项的值都等于前两项之和：</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89······</p>
<p>如果设f(n）为该数列的第n项（n∈N*），那么有：f(n) &#x3D; f(n-1) + f(n-2)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTest</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-comment">// 主要的实现逻辑都在compute()里</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 这里先假设 n &gt;= 0</span><br>            <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// f(n-1)</span><br>                <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">1</span>);<br>                f1.fork();<br>                <span class="hljs-comment">// f(n-2)</span><br>                <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>                f2.fork();<br>                <span class="hljs-comment">// f(n) = f(n-1) + f(n-2)</span><br>                <span class="hljs-keyword">return</span> f1.join() + f2.join();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFib</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        System.out.println(<span class="hljs-string">&quot;CPU核数：&quot;</span> + Runtime.getRuntime().availableProcessors());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">fibonacci</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(<span class="hljs-number">40</span>);<br>        Future&lt;Integer&gt; future = forkJoinPool.submit(fibonacci);<br>        System.out.println(future.get());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>, end - start));<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面例子在本机的输出：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">CPU核数：<span class="hljs-number">4</span><br>计算结果：<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">9490</span> millis<br></code></pre></td></tr></table></figure>

<p>需要注意的是，上述计算时间复杂度为<code>O(2^n)</code>，随着n的增长计算效率会越来越低，这也是上面的例子中n不敢取太大的原因。</p>
<p>此外，也并不是所有的任务都适合Fork&#x2F;Join框架，比如上面的例子任务划分过于细小反而体现不出效率，下面我们试试用普通的递归来求f(n)的值，看看是不是要比使用Fork&#x2F;Join快：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通递归，复杂度为O(2^n)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">plainRecursion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> plainRecursion(n -<span class="hljs-number">1</span>) + plainRecursion(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPlain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> plainRecursion(<span class="hljs-number">40</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;计算结果:&quot;</span> + result);<br>    System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>,  end -start));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>普通递归的例子输出：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">计算结果:<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">436</span> millis<br></code></pre></td></tr></table></figure>

<p>通过输出可以很明显的看出来，使用普通递归的效率都要比使用Fork&#x2F;Join框架要高很多。</p>
<p>这里我们再用另一种思路来计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过循环来计算，复杂度为O(n)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeFibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 假设n &gt;= 0</span><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-comment">// 第三个数是前两个数之和</span><br>            third = first + second;<br>            <span class="hljs-comment">// 前两个数右移</span><br>            first = second;<br>            second = third;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testComputeFibonacci</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> computeFibonacci(<span class="hljs-number">40</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;计算结果:&quot;</span> + result);<br>    System.out.println(String.format(<span class="hljs-string">&quot;耗时：%d millis&quot;</span>,  end -start));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面例子在笔者所用电脑的输出为：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">计算结果:<span class="hljs-number">102334155</span><br>耗时：<span class="hljs-number">0</span> millis<br></code></pre></td></tr></table></figure>

<p>这里耗时为0不代表没有耗时，是表明这里计算的耗时几乎可以忽略不计，大家可以在自己的电脑试试，即使是n取大很多量级的数据（注意int溢出的问题）耗时也是很短的，或者可以用System.nanoTime()统计纳秒的时间。</p>
<p>为什么在这里普通的递归或循环效率更快呢？因为Fork&#x2F;Join是使用多个线程协作来计算的，所以会有线程通信和线程切换的开销。</p>
<p>如果要计算的任务比较简单（比如我们案例中的斐波那契数列），那当然是直接使用单线程会更快一些。但如果要计算的东西比较复杂，计算机又是多核的情况下，就可以充分利用多核CPU来提高计算速度。</p>
<p>另外，Java 8 Stream的并行操作底层就是用到了Fork&#x2F;Join框架，下一章我们将从源码及案例两方面介绍Java 8 Stream的并行操作</p>
<h3 id="Stream并行计算原理"><a href="#Stream并行计算原理" class="headerlink" title="Stream并行计算原理"></a>Stream并行计算原理</h3><h4 id="Stream简介"><a href="#Stream简介" class="headerlink" title="Stream简介"></a>Stream简介</h4><p>从Java 8 开始，我们可以使用<code>Stream</code>接口以及<strong>lambda表达式</strong>进行“流式计算”。它可以让我们对集合的操作更加简洁、更加可读、更加高效。</p>
<p>Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p>
<h4 id="Stream单线程串行计算"><a href="#Stream单线程串行计算" class="headerlink" title="Stream单线程串行计算"></a>Stream单线程串行计算</h4><p>Stream接口默认是使用串行的方式，也就是说在一个线程里执行。下面举一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .reduce((a, b) -&gt; &#123;<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s: %d + %d = %d&quot;</span>,<br>                            Thread.currentThread().getName(), a, b, a + b));<br>                    <span class="hljs-keyword">return</span> a + b;<br>                &#125;)<br>                .ifPresent(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来理解一下这个方法。首先我们用整数1~9创建了一个<code>Stream</code>。这里的Stream.of(T… values)方法是Stream接口的一个静态方法，其底层调用的是Arrays.stream(T[] array)方法。</p>
<p>然后我们使用了<code>reduce</code>方法来计算这个集合的累加和。<code>reduce</code>方法这里做的是：从前两个元素开始，进行某种操作（我这里进行的是加法操作）后，返回一个结果，然后再拿这个结果跟第三个元素执行同样的操作，以此类推，直到最后的一个元素。</p>
<p>我们来打印一下当前这个reduce操作的线程以及它们被操作的元素和返回的结果以及最后所有reduce方法的结果，也就代表的是数字1到9的累加和。</p>
<blockquote>
<p>main: 1 + 2 &#x3D; 3<br>main: 3 + 3 &#x3D; 6<br>main: 6 + 4 &#x3D; 10<br>main: 10 + 5 &#x3D; 15<br>main: 15 + 6 &#x3D; 21<br>main: 21 + 7 &#x3D; 28<br>main: 28 + 8 &#x3D; 36<br>main: 36 + 9 &#x3D; 45<br>45</p>
</blockquote>
<p>可以看到，默认情况下，它是在一个单线程运行的，也就是<strong>main</strong>线程。然后每次reduce操作都是串行起来的，首先计算前两个数字的和，然后再往后依次计算。</p>
<h4 id="Stream多线程并行计算"><a href="#Stream多线程并行计算" class="headerlink" title="Stream多线程并行计算"></a>Stream多线程并行计算</h4><p>我们思考上面一个例子，是不是一定要在单线程里进行串行地计算呢？假如我的计算机是一个多核计算机，我们在理论上能否利用多核来进行并行计算，提高计算效率呢？</p>
<p>当然可以，比如我们在计算前两个元素1 + 2 &#x3D; 3的时候，其实我们也可以同时在另一个核计算 3 + 4 &#x3D; 7。然后等它们都计算完成之后，再计算 3 + 7 &#x3D; 10的操作。</p>
<p>是不是很熟悉这样的操作手法？没错，它就是ForkJoin框架的思想。下面小小地修改一下上面的代码，增加一行代码，使Stream使用多线程来并行计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamParallelDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .parallel()<br>                .reduce((a, b) -&gt; &#123;<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s: %d + %d = %d&quot;</span>,<br>                            Thread.currentThread().getName(), a, b, a + b));<br>                    <span class="hljs-keyword">return</span> a + b;<br>                &#125;)<br>                .ifPresent(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，与上一个案例的代码只有一点点区别，就是在reduce方法被调用之前，调用了parallel()方法。下面来看看这个方法的输出：</p>
<blockquote>
<p>ForkJoinPool.commonPool-worker-1: 3 + 4 &#x3D; 7<br>ForkJoinPool.commonPool-worker-4: 8 + 9 &#x3D; 17<br>ForkJoinPool.commonPool-worker-2: 5 + 6 &#x3D; 11<br>ForkJoinPool.commonPool-worker-3: 1 + 2 &#x3D; 3<br>ForkJoinPool.commonPool-worker-4: 7 + 17 &#x3D; 24<br>ForkJoinPool.commonPool-worker-4: 11 + 24 &#x3D; 35<br>ForkJoinPool.commonPool-worker-3: 3 + 7 &#x3D; 10<br>ForkJoinPool.commonPool-worker-3: 10 + 35 &#x3D; 45<br>45</p>
</blockquote>
<p>可以很明显地看到，它使用的线程是<code>ForkJoinPool</code>里面的<code>commonPool</code>里面的<strong>worker</strong>线程。并且它们是并行计算的，并不是串行计算的。但由于Fork&#x2F;Join框架的作用，它最终能很好的协调计算结果，使得计算结果完全正确。</p>
<p>如果我们用Fork&#x2F;Join代码去实现这样一个功能，那无疑是非常复杂的。但Java8提供了并行式的流式计算，大大简化了我们的代码量，使得我们只需要写很少很简单的代码就可以利用计算机底层的多核资源。</p>
<h4 id="从源码看Stream并行计算原理"><a href="#从源码看Stream并行计算原理" class="headerlink" title="从源码看Stream并行计算原理"></a>从源码看Stream并行计算原理</h4><p>上面我们通过在控制台输出线程的名字，看到了Stream的并行计算底层其实是使用的Fork&#x2F;Join框架。那它到底是在哪使用Fork&#x2F;Join的呢？我们从源码上来解析一下上述案例。</p>
<p><code>Stream.of</code>方法就不说了，它只是生成一个简单的Stream。先来看看<code>parallel()</code>方法的源码。这里由于我的数据是<code>int</code>类型的，所以它其实是使用的<code>BaseStream</code>接口的<code>parallel()</code>方法。而<code>BaseStream</code>接口的JDK唯一实现类是一个叫<code>AbstractPipeline</code>的类。下面我们来看看这个类的<code>parallel()</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> S <span class="hljs-title function_">parallel</span><span class="hljs-params">()</span> &#123;<br>    sourceStage.parallel = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> (S) <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法很简单，就是把一个标识<code>sourceStage.parallel</code>设置为<code>true</code>。然后返回实例本身。</p>
<p>接着我们再来看<code>reduce</code>这个方法的内部实现。</p>
<p>Stream.reduce()方法的具体实现是交给了<code>ReferencePipeline</code>这个抽象类，它是继承了<code>AbstractPipeline</code>这个类的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReferencePipeline抽象类的reduce方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Optional&lt;P_OUT&gt; <span class="hljs-title function_">reduce</span><span class="hljs-params">(BinaryOperator&lt;P_OUT&gt; accumulator)</span> &#123;<br>    <span class="hljs-comment">// 调用evaluate方法</span><br>    <span class="hljs-keyword">return</span> evaluate(ReduceOps.makeRef(accumulator));<br>&#125;<br><br><span class="hljs-keyword">final</span> &lt;R&gt; R <span class="hljs-title function_">evaluate</span><span class="hljs-params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">getOutputShape</span><span class="hljs-params">()</span> == terminalOp.inputShape();<br>    <span class="hljs-keyword">if</span> (linkedOrConsumed)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);<br>    linkedOrConsumed = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> isParallel() <span class="hljs-comment">// 调用isParallel()判断是否使用并行模式</span><br>        ? terminalOp.evaluateParallel(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()))<br>        : terminalOp.evaluateSequential(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isParallel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 根据之前在parallel()方法设置的那个flag来判断。</span><br>    <span class="hljs-keyword">return</span> sourceStage.parallel;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从它的源码可以知道，reduce方法调用了evaluate方法，而evaluate方法会先去检查当前的flag，是否使用并行模式，如果是则会调用<code>evaluateParallel</code>方法执行并行计算，否则，会调用<code>evaluateSequential</code>方法执行串行计算。</p>
<p>这里我们再看看<code>TerminalOp</code>（注意这里是字母l O，而不是数字1 0）接口的<code>evaluateParallel</code>方法。<code>TerminalOp</code>接口的实现类有这样几个内部类：</p>
<ul>
<li>java.util.stream.FindOps.FindOp</li>
<li>java.util.stream.ForEachOps.ForEachOp</li>
<li>java.util.stream.MatchOps.MatchOp</li>
<li>java.util.stream.ReduceOps.ReduceOp</li>
</ul>
<p>可以看到，对应的是Stream的几种主要的计算操作。我们这里的示例代码使用的是reduce计算，那我们就看看ReduceOp类的这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.stream.ReduceOps.ReduceOp.evaluateParallel</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;P_IN&gt; R <span class="hljs-title function_">evaluateParallel</span><span class="hljs-params">(PipelineHelper&lt;T&gt; helper,</span><br><span class="hljs-params">                                 Spliterator&lt;P_IN&gt; spliterator)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReduceTask</span>&lt;&gt;(<span class="hljs-built_in">this</span>, helper, spliterator).invoke().get();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>evaluateParallel方法创建了一个新的ReduceTask实例，并且调用了invoke()方法后再调用get()方法，然后返回这个结果。那这个ReduceTask是什么呢？它的invoke方法内部又是什么呢？</p>
<p>追溯源码我们可以发现，ReduceTask类是ReduceOps类的一个内部类，它继承了AbstractTask类，而AbstractTask类又继承了CountedCompleter类，而CountedCompleter类又继承了ForkJoinTask类！</p>
<p>它们的继承关系如下：</p>
<blockquote>
<p>ReduceTask -&gt; AbstractTask -&gt; CountedCompleter -&gt; ForkJoinTask</p>
</blockquote>
<p>这里的ReduceTask的invoke方法，其实是调用的ForkJoinTask的invoke方法，中间三层继承并没有覆盖这个方法的实现。</p>
<p>所以这就从源码层面解释了Stream并行的底层原理是使用了Fork&#x2F;Join框架。</p>
<p>需要注意的是，一个Java进程的Stream并行计算任务默认共享同一个线程池，如果随意的使用并行特性可能会导致方法的吞吐量下降。我们可以通过下面这种方式来让你的某个并行Stream使用自定义的ForkJoin线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">customThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">actualTotal</span> <span class="hljs-operator">=</span> customThreadPool<br>  .submit(() -&gt; roster.parallelStream().reduce(<span class="hljs-number">0</span>, Integer::sum)).get();<br></code></pre></td></tr></table></figure>

<h4 id="Stream并行计算的性能提升"><a href="#Stream并行计算的性能提升" class="headerlink" title="Stream并行计算的性能提升"></a>Stream并行计算的性能提升</h4><p>我们可以在本地测试一下如果在多核情况下，Stream并行计算会给我们的程序带来多大的效率上的提升。用以下示例代码来计算一千万个随机数的和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamParallelDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;本计算机的核数：%d&quot;</span>, Runtime.getRuntime().availableProcessors()));<br><br>        <span class="hljs-comment">// 产生100w个随机数(1 ~ 100)，组成列表</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1000_0000</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000</span>; i++) &#123;<br>            list.add(random.nextInt(<span class="hljs-number">100</span>));<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">prevTime</span> <span class="hljs-operator">=</span> getCurrentTime();<br>        list.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);<br>        System.out.println(String.format(<span class="hljs-string">&quot;单线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));<br><br>        prevTime = getCurrentTime();<br>        list.stream().parallel().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);<br>        System.out.println(String.format(<span class="hljs-string">&quot;多线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCurrentTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>本计算机的核数：8<br>495156156<br>单线程计算耗时：223<br>495156156<br>多线程计算耗时：95</p>
</blockquote>
<p>所以在多核的情况下，使用Stream的并行计算确实比串行计算能带来很大效率上的提升，并且也能保证结果计算完全准确。</p>
<p>本文一直在强调的“多核”的情况。其实可以看到，我的本地电脑有8核，但并行计算耗时并不是单线程计算耗时除以8，因为线程的创建、销毁以及维护线程上下文的切换等等都有一定的开销。所以如果你的服务器并不是多核服务器，那也没必要用Stream的并行计算。因为在单核的情况下，往往Stream的串行计算比并行计算更快，因为它不需要线程切换的开销。</p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>自JDK 1.5 开始，JDK提供了<code>ScheduledThreadPoolExecutor</code>类用于计划任务（又称定时任务），这个类有两个用途：</p>
<ul>
<li>在给定的延迟之后运行任务</li>
<li>周期性重复执行任务</li>
</ul>
<p>在这之前，是使用<code>Timer</code>类来完成定时任务的，但是<code>Timer</code>有缺陷：</p>
<ul>
<li>Timer是<strong>单线程</strong>模式；</li>
<li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li>
<li>Timer的任务调度是基于绝对时间的，对<strong>系统时间</strong>敏感；</li>
<li>Timer不会捕获执行TimerTask时所抛出的<strong>异常</strong>，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>
</ul>
<p>所以JDK 1.5之后，大家就摒弃<code>Timer</code>,使用<code>ScheduledThreadPoolExecutor</code>吧。</p>
<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>假设我有一个需求，指定时间给大家发送消息。那么我们会将消息（包含发送时间）存储在数据库中，然后想用一个定时任务，每隔1秒检查数据库在当前时间有没有需要发送的消息，那这个计划任务怎么写？下面是一个Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>        <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, Executors.defaultThreadFactory());<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">// 新建一个固定延迟时间的计划任务</span><br>        executor.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (haveMsgAtCurrentTime()) &#123;<br>                    System.out.println(df.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>                    System.out.println(<span class="hljs-string">&quot;大家注意了，我要发消息了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">haveMsgAtCurrentTime</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//查询数据库，有没有当前时间需要发送的消息</span><br>        <span class="hljs-comment">//这里省略实现，直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面截取前面的输出（这个demo会一直运行下去）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">48</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">49</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">50</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">51</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">52</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">53</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">54</span><br>大家注意了，我要发消息了<br><span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">55</span><br>大家注意了，我要发消息了<br></code></pre></td></tr></table></figure>

<p>这就是<code>ScheduledThreadPoolExecutor</code>的一个简单运用，想要知道奥秘，接下来的东西需要仔细的看哦。</p>
<h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,ThreadFactory threadFactory)</span> &#123;<br>         <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>    &#125;<br>    <span class="hljs-comment">//……</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，实现了<code>ScheduledExecutorService</code>。 线程池在之前的章节介绍过了，我们先看看<code>ScheduledExecutorService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="hljs-type">long</span> delay, TimeUnit unit);<br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,<span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ScheduledExecutorService</code>实现了<code>ExecutorService</code> ,并增加若干定时相关的接口。 前两个方法用于单次调度执行任务，区别是有没有返回值。</p>
<p>重点理解一下后面两个方法：</p>
<ul>
<li><p>scheduleAtFixedRate</p>
<p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每隔<code>period</code>时长，再次执行任务。注意，period是从<strong>任务开始执行算起</strong>的。开始执行任务后，定时器每隔period时长<strong>检查该任务是否完成</strong>，如果完成则再次启动任务，否则等该任务结束后才再次启动任务。</p>
</li>
<li><p>scheduleWithFixDelay</p>
<p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每当任务执行<strong>完成后</strong>，等待<code>delay</code>时长，再次执行任务。</p>
</li>
</ul>
<h4 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h4><h5 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// delay时长后执行任务command，该任务只执行一次</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 这里的decorateTask方法仅仅返回第二个参数</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<br>                                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay,unit)));<br>    <span class="hljs-comment">// 延时或者周期执行任务的主要方法,稍后统一说明</span><br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先看看里面涉及到的几个类和接口<code>ScheduledFuture</code>、 <code>RunnableScheduledFuture</code>、 <code>ScheduledFutureTask</code>的关系：</p>
<p><img src="/posts/60838/4.jpg" srcset="/img/loading.gif" lazyload alt="类图"></p>
<p>我们先看看这几个接口和类：</p>
<h6 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承Comparable接口，表示该类对象支持排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-comment">// 返回该对象剩余时延</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Delayed</code>接口很简单，继承了<code>Comparable</code>接口，表示对象是可以比较排序的。</p>
<h6 id="ScheduledFuture接口"><a href="#ScheduledFuture接口" class="headerlink" title="ScheduledFuture接口"></a>ScheduledFuture接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仅仅继承了Delayed和Future接口，自己没有任何代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>, Future&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>没有添加其他方法。</p>
<h6 id="RunnableScheduledFuture接口"><a href="#RunnableScheduledFuture接口" class="headerlink" title="RunnableScheduledFuture接口"></a>RunnableScheduledFuture接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;, ScheduledFuture&lt;V&gt; &#123;      <br>    <span class="hljs-comment">// 是否是周期任务，周期任务可被调度运行多次，非周期任务只被运行一次   </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="ScheduledFutureTask类"><a href="#ScheduledFutureTask类" class="headerlink" title="ScheduledFutureTask类"></a>ScheduledFutureTask类</h6><p>回到<code>schecule</code>方法中，它创建了一个<code>ScheduledFutureTask</code>的对象，由上面的关系图可知，<code>ScheduledFutureTask</code>直接或者间接实现了很多接口，一起看看<code>ScheduledFutureTask</code>里面的实现方法吧。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;<br>    <span class="hljs-comment">// 调用父类FutureTask的构造方法</span><br>    <span class="hljs-built_in">super</span>(r, result);<br>    <span class="hljs-comment">// time表示任务下次执行的时间</span><br>    <span class="hljs-built_in">this</span>.time = ns;<br>    <span class="hljs-comment">// 周期任务，正数表示按照固定速率，负数表示按照固定时延,0表示不是周期任务</span><br>    <span class="hljs-built_in">this</span>.period = period;<br>    <span class="hljs-comment">// 任务的编号</span><br>    <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Delayed接口的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Delayed接口的getDelay方法，返回任务开始执行的剩余时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Comparable接口的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparable接口的compareTo方法，比较两个任务的”大小”。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>    <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>      ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br>      <span class="hljs-comment">// 小于0，说明当前任务的执行时间点早于other，要排在延时队列other的前面</span><br>      <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 大于0，说明当前任务的执行时间点晚于other，要排在延时队列other的后面</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 如果两个任务的执行时间点一样，比较两个任务的编号，编号小的排在队列前面，编号大的排在队列后面</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果任务类型不是ScheduledFutureTask，通过getDelay方法比较</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (getDelay(TimeUnit.NANOSECONDS) -<br>              other.getDelay(TimeUnit.NANOSECONDS));<br>    <span class="hljs-keyword">return</span> (d == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : ((d &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>setNextRunTime</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务执行完后，设置下次执行的时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-comment">// p &gt; 0，说明是固定速率运行的任务</span><br>    <span class="hljs-comment">// 在原来任务开始执行时间的基础上加上p即可</span><br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>      time += p;<br>    <span class="hljs-comment">// p &lt; 0，说明是固定时延运行的任务，</span><br>    <span class="hljs-comment">// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span><br>    <span class="hljs-keyword">else</span><br>      time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Runnable接口实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>    <span class="hljs-comment">// 如果当前状态下不能执行任务，则取消任务</span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>      cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 不是周期性任务，执行一次任务即可，调用父类的run方法</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>      ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-comment">// 是周期性任务，调用FutureTask的runAndReset方法，方法执行完成后</span><br>    <span class="hljs-comment">// 重新设置任务下一次执行的时间，并将该任务重新入队，等待再次被调度</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>      setNextRunTime();<br>      reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结一下run方法的执行过程：</p>
<ol>
<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li>
<li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li>
<li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li>
<li>计算下次执行该任务的具体时间；</li>
<li>重复执行任务。</li>
</ol>
<p><code>runAndReset</code>方法是为任务多次执行而设计的。<code>runAndReset</code>方法执行完任务后不会设置任务的执行结果，也不会去更新任务的状态，维持任务的状态为初始状态（<strong>NEW</strong>状态），这也是该方法和<code>FutureTask</code>的<code>run</code>方法的区别。</p>
<h5 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h5><p>我们看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意，固定速率和固定时延，传入的参数都是Runnable，也就是说这种定时任务是没有返回值的</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-comment">// 创建一个有初始延时和固定周期的任务</span><br>    ScheduledFutureTask&lt;Void&gt; sft =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                    <span class="hljs-literal">null</span>,<br>                                    triggerTime(initialDelay, unit),<br>                                    unit.toNanos(period));<br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>    <span class="hljs-comment">// outerTask表示将会重新入队的任务</span><br>    sft.outerTask = t;<br>    <span class="hljs-comment">// 稍后说明</span><br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>scheduleAtFixedRate</code>这个方法和<code>schedule</code>类似，不同点是<code>scheduleAtFixedRate</code>方法内部创建的是<code>ScheduledFutureTask</code>，带有初始延时和固定周期的任务 。</p>
<h5 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h5><p><code>FixedDelay</code>也是通过<code>ScheduledFutureTask</code>体现的，唯一不同的地方在于创建的<code>ScheduledFutureTask</code>不同 。这里不再展示源码。</p>
<h5 id="delayedExecute"><a href="#delayedExecute" class="headerlink" title="delayedExecute"></a>delayedExecute</h5><p>前面讲到的<code>schedule</code>、<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>最后都调用了<code>delayedExecute</code>方法，该方法是定时任务执行的主要方法。 一起来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-comment">// 线程池已经关闭，调用拒绝执行处理器处理</span><br>    <span class="hljs-keyword">if</span> (isShutdown())<br>      reject(task);<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将任务加入到等待队列</span><br>      <span class="hljs-built_in">super</span>.getQueue().add(task);<br>      <span class="hljs-comment">// 线程池已经关闭，且当前状态不能运行该任务，将该任务从等待队列移除并取消该任务</span><br>      <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>          !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>          remove(task))<br>        task.cancel(<span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 增加一个worker，就算corePoolSize=0也要增加一个worker</span><br>        ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>delayedExecute</code>方法的逻辑也很简单，主要就是将任务添加到等待队列，然后调用<code>ensurePrestart</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ensurePrestart</code>方法主要是调用了<code>addWorker</code>，线程池中的工作线程是通过该方法来启动并执行任务的。 具体可以查看前面讲的线程池章节。</p>
<p>对于<code>ScheduledThreadPoolExecutor</code>，<code>worker</code>添加到线程池后会在等待队列上等待获取任务，这点是和<code>ThreadPoolExecutor</code>一致的。<strong>但是worker是怎么从等待队列取定时任务的？</strong></p>
<p>因为<code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务，该等待队列队首应该保存的是最近将要执行的任务，如果队首任务的开始执行时间还未到，<code>worker</code>也应该继续等待。</p>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p><code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务。</p>
<p>该等待队列队首应该保存的是<strong>最近将要执行的任务</strong>，所以<code>worker</code>只关心队首任务即可，如果队首任务的开始执行时间还未到，worker也应该继续等待。</p>
<p>DelayedWorkQueue是一个无界优先队列，使用数组存储，底层是使用堆结构来实现优先队列的功能。我们先看看DelayedWorkQueue的声明和成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;Runnable&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;Runnable&gt; &#123;<br>    <span class="hljs-comment">// 队列初始容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">// 数组用来存储定时任务，通过数组实现堆排序</span><br>    <span class="hljs-keyword">private</span> RunnableScheduledFuture[] queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>[INITIAL_CAPACITY];<br>    <span class="hljs-comment">// 当前在队首等待的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">leader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 锁和监视器，用于leader线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 其他代码，略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当一个线程成为leader，它只要等待队首任务的delay时间即可，其他线程会无条件等待。leader取到任务返回前要通知其他线程，直到有线程成为新的leader。每当队首的定时任务被其他更早需要执行的任务替换时，leader设置为null，其他等待的线程（被当前leader通知）和当前的leader重新竞争成为leader。</p>
<p>同时，定义了锁lock和监视器available用于线程竞争成为leader。</p>
<p>当一个新的任务成为队首，或者需要有新的线程成为leader时，available监视器上的线程将会被通知，然后竞争成为leader线程。 有些类似于生产者-消费者模式。</p>
<p>接下来看看<code>DelayedWorkQueue</code>中几个比较重要的方法</p>
<h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RunnableScheduledFuture <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 取堆顶的任务，堆顶是最近要执行的任务</span><br>        <span class="hljs-type">RunnableScheduledFuture</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> queue[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 堆顶为空，线程要在条件available上等待</span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>          available.await();<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 堆顶任务还要多长时间才能执行</span><br>          <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(TimeUnit.NANOSECONDS);<br>          <span class="hljs-comment">// 堆顶任务已经可以执行了，finishPoll会重新调整堆，使其满足最小堆特性，该方法设置任务在</span><br>          <span class="hljs-comment">// 堆中的index为-1并返回该任务</span><br>          <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> finishPoll(first);<br>          <span class="hljs-comment">// 如果leader不为空，说明已经有线程成为leader并等待堆顶任务</span><br>          <span class="hljs-comment">// 到达执行时间，此时，其他线程都需要在available条件上等待</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>            available.await();<br>          <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// leader为空，当前线程成为新的leader</span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            leader = thisThread;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 当前线程已经成为leader了，只需要等待堆顶任务到达执行时间即可</span><br>              available.awaitNanos(delay);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-comment">// 返回堆顶元素之前将leader设置为空</span><br>              <span class="hljs-keyword">if</span> (leader == thisThread)<br>                leader = <span class="hljs-literal">null</span>;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 通知其他在available条件等待的线程，这些线程可以去竞争成为新的leader</span><br>      <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)<br>        available.signal();<br>      lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>take</code>方法是什么时候调用的呢？在线程池的章节中，介绍了<code>getTask</code>方法，工作线程会循环地从<code>workQueue</code>中取任务。但计划任务却不同，因为如果一旦<code>getTask</code>方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在<code>take</code>方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p>总结一下流程：</p>
<ol>
<li>如果堆顶元素为空，在available条件上等待。</li>
<li>如果堆顶任务的执行时间已到，将堆顶元素替换为堆的最后一个元素并调整堆使其满足<strong>最小堆</strong>特性，同时设置任务在堆中索引为-1，返回该任务。</li>
<li>如果leader不为空，说明已经有线程成为leader了，其他线程都要在available监视器上等待。</li>
<li>如果leader为空，当前线程成为新的leader，并等待直到堆顶任务执行时间到达。</li>
<li>take方法返回之前，将leader设置为空，并通知其他线程。</li>
</ol>
<p>再来说一下leader的作用，这里的leader是<strong>为了减少不必要的定时等待</strong>，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从<code>take()</code>或<code>poll()</code>返回之前signal其它线程，除非其他线程成为了leader。</p>
<p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。但只有一个线程返回队首任务，其他的线程在<code>awaitNanos(delay)</code>之后，继续执行for循环，因为队首任务已经被返回了，所以这个时候的for循环拿到的队首任务是新的，又需要重新判断时间，又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在<code>finally</code>中调用了<code>signal()</code>来唤醒一个线程，而不是<code>signalAll()</code>）。</p>
<h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><p>该方法往队列插入一个值，返回是否成功插入 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">RunnableScheduledFuture</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (RunnableScheduledFuture)x;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>      <span class="hljs-comment">// 队列元素已经大于等于数组的长度，需要扩容，新堆的容量是原来堆容量的1.5倍</span><br>      <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow();<br>      <span class="hljs-comment">// 堆中元素增加1</span><br>      size = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 调整堆</span><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        queue[<span class="hljs-number">0</span>] = e;<br>        setIndex(e, <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 调整堆，使的满足最小堆，比较大小的方式就是上文提到的compareTo方法</span><br>        siftUp(i, e);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;<br>        leader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 通知其他在available条件上等待的线程，这些线程可以竞争成为新的leader</span><br>        available.signal();<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在堆中插入了一个节点，这个时候堆有可能不满足最小堆的定义，<code>siftUp</code>用于将堆调整为最小堆，这属于数据结构的基本内容，本文不做介绍。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内部使用优化的DelayQueue来实现，由于使用队列来实现定时器，有出入队调整堆等操作，所以定时并不是非常非常精确</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h4><h5 id="什么是一致性问题"><a href="#什么是一致性问题" class="headerlink" title="什么是一致性问题"></a>什么是一致性问题</h5><p>多线程充分利用了多核CPU的威力，为我们程序提供了很高的性能。但是有时候，我们需要多个线程互相协作，这里可能就会涉及到数据一致性的问题。 数据一致性指问题的是：发生在<strong>多个主体</strong>对<strong>同一份</strong>数据无法达成<strong>共识</strong>。这里的多个主体，可能是多线程，也可能是多个服务器节点。 当然了，这里的“多个主体”也可以指朋友之间，夫妻之间，所谓“道不同，不相为谋”，说的就是这个理。</p>
<h5 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h5><p>第一种是<strong>排队</strong>，如果两个人对一个问题的看法不一致，那就排成一队，一个人一个人去修改它，这样后面一个人总是能够得到前面一个人修改后的值，数据也就总是一致的了。我们在操作系统中的锁、互斥量、管程、屏障等等概念，都是利用了排队的思想。排队虽然能够很好的确保数据一致性，但性能非常低。</p>
<p>第二种是<strong>投票</strong>，投票的话，多个人可以同时去做一件决策，或者同时去修改数据，但最终谁修改成功，是用投票来决定的。这个方式很高效，但它也会产生很多问题，比如网络中断、欺诈等等。想要通过投票达到一致性非常复杂，往往需要严格的数学理论来证明，还需要中间有一些“信使”不断来来回回传递消息，这中间也会有一些性能的开销。 我们在分布式系统中常见的Paxos和Raft算法，就是使用投票来解决一致性问题的。感兴趣的同学可以看看这两篇关于这两个算法的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yasinshaw.com/articles/33">分布式一致性算法：Raft</a></li>
<li><a target="_blank" rel="noopener" href="https://yasinshaw.com/articles/32">分布式一致性算法：Paxos</a></li>
</ul>
<p>第三种是<strong>避免</strong>。既然保证数据一致性很难，那我能不能通 过一些手段，去避免多个线程之间产生一致性问题呢？我们程序员熟悉的git就是这个实现，大家在本地分布式修改同一个文件，最后通过版本控制和“冲突解决”去解决这个问题。 而我们今天的正题，ThreadLocal，也是使用的“避免”这种方式</p>
<h4 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>ThreadLocal提供了<strong>线程局部变量</strong>，一个线程局部变量在多个线程中，分别有独立的值（副本）。</p>
<h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><p>下图能够比较直观地解释ThreadLocal的线程模型。</p>
<p><img src="/posts/60838/ThreadLocal.png" srcset="/img/loading.gif" lazyload alt="ThreadLocal模型"></p>
<p>对于每一个线程来说，都有自己的独占数据。这些独占数据是进程来分配的，对于Java来说，独占数据很多都是在Thread类里面分配的，而每一个线程里面都有一个 ThreadLocalMap 的对象，它本身是一个哈希表，里面会放一些线程的局部变量（红色长方形）。ThreadLocal 的核心也是这个 ThreadLocalMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread类里的变量：</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// ThreadLocalMap的定义：</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h5><ul>
<li>构造函数 ThreadLocal()</li>
<li>初始化 initialValue()</li>
<li>访问器 get&#x2F;set</li>
<li>回收 remove</li>
</ul>
<p>构造函数是一个泛型的，传入的类型是你要使用的局部变量变量的类型。初始化<code>initialValue()</code> 用于如果你没有调用<code>set()</code>方法的时候，调用 <code>get()</code>方法返回的默认值。如果不重载初始化方法，会返回 <strong>null</strong>。 如果调用了<code>set()</code>方法，再调用<code>get()</code>方法，就不会调用<code>initialValue()</code>方法。 如果调用了<code>set()</code>，再调用<code>remove()</code>，再调用<code>get()</code>，是会调用<code>initialValue()</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;invoke initial value&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default value&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;first thread&quot;</span>);<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;second thread&quot;</span>);<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            THREAD_LOCAL.set(<span class="hljs-string">&quot;third thread&quot;</span>);<br>            THREAD_LOCAL.remove();<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            System.out.println(THREAD_LOCAL.get());<br>        &#125;).start();<br><br>        SECONDS.sleep(<span class="hljs-number">1L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">first thread<br>second thread<br>invoke initial value<br><span class="hljs-keyword">default</span> value<br>invoke initial value<br><span class="hljs-keyword">default</span> value<br></code></pre></td></tr></table></figure>

<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><h6 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h6><p>ThreadLocalMap类 定义：</p>
<blockquote>
<p>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values. No operations are exported outside of the ThreadLocal class. The class is package private to allow declaration of fields &gt;in class Thread.<br>To help deal with very large and long-lived usages, the hash table entries useWeakReferences for keys. However, since &gt;reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p>
</blockquote>
<p>由上得知：</p>
<ol>
<li>ThreadLocalMap只会被 ThreadLocal 维护</li>
<li>Entry的key使用的是弱引用(WeakReferences)</li>
</ol>
<p>Entry 定义：</p>
<blockquote>
<p>The entries in this hash map extend WeakReference, using its main ref field as the key (which is always aThreadLocal object).<br>Note that null keys (i.e. entry.get()&#x3D;&#x3D; null) mean that the key is no longer referenced, so the entry can be expunged from table. Such entries are referred toas “stale entries” in the code that follows.</p>
</blockquote>
<p>由上得知：</p>
<ol>
<li>Entry的key 必须是 ThreadLocal 类型引用，并且是一个弱引用</li>
<li>如果 entry.get()&#x3D;&#x3D; null 意味着某Entry的key不再被引用(指向的对象已经被GC) ,所以此 entry 就可以从table 中回收，这时此 entry 在table 中被称为 stale entries</li>
</ol>
<p>弱引用(WeakReferences) :如果某个对象<strong>仅</strong>剩下弱引用指向它，那么下一次GC的时候该对象就会被回收掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>   <span class="hljs-comment">//ThreadLocalMap真正存数据的是Entry，且Entry的key使用的是弱引用(WeakReferences)</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>       <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>       Object value;<br><br>       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>           <span class="hljs-built_in">super</span>(k);<br>           value = v;<br>       &#125;<br><br><br>       <span class="hljs-comment">// ....省略</span><br>   &#125;<br></code></pre></td></tr></table></figure>

<p>Thread、ThreadLocal、ThreadLocalMap、Entry 的关系 如下图所示：<img src="/posts/60838/ThreadLocal2.png" srcset="/img/loading.gif" lazyload alt="ThreadLocal概念图"></p>
<h6 id="set-方法"><a href="#set-方法" class="headerlink" title="set() 方法"></a>set() 方法</h6><p>set(T value) 方法:<br>先拿到当前的线程，然后通过它去拿到一个Map，如果这个Map存在，就把value塞进去，否则就创建一个新的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#set</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//拿到当前的线程</span><br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);     <span class="hljs-comment">//根据当前的线程拿到ThreadLocalMap</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">//如果map不为空就set value</span><br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            createMap(t, value);            <span class="hljs-comment">//否则创建一个新的ThreadLocalMap，并且set value</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>getMap(Thread t):<br>返回当前线程的 threadLocals参数， 每个线程对应一个自己线程私有的ThreadLocalMap，它被Thread对象持有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#getMap</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-comment">//java.lang.Thread </span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>createMap(Thread t, T firstValue) 方法： 创建一个新的ThreadLocalMap对象，并赋值给当前线程对象。ThreadLocalMap的 key 是当前 ThreadLocal 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.ThreadLocal#createMap      //创建一个新的ThreadLocalMap对象，赋值给当前线程对象</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//由此得知，ThreadLocalMap的 key 是当前 ThreadLocal 对象 value 是 set()方法传入的值</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="get-方法："><a href="#get-方法：" class="headerlink" title="get() 方法："></a>get() 方法：</h6><p>先通过 getMap(Thread t) 方法拿到当前线程对应的Map，然后从里面取出value。如果没有value，就调用ThreadLocal提供的初始化方法，初始化一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#get</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();                     <span class="hljs-comment">//获得当前线程</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);                        <span class="hljs-comment">//获取当前线程的ThreadLocalMap 对象</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                                    <span class="hljs-comment">//当前线程的ThreadLocalMap 对象 不为空</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);     <span class="hljs-comment">//从当前的ThreadLocalMap 对象中取出 key为当前 ThreadLocal 对象的 Entry</span><br>           <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;                        <br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();                            <span class="hljs-comment">//当前线程的ThreadLocalMap 对象 为空返回初始值        </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>setInitialValue() 方法：<br>通过 initialValue() 获得初始值，将初始值赋值给当前线程的ThreadLocalMap 对象，以当前ThreadLocal对象为key ,以初始值为value。 返回该值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#setInitialValue</span><br> <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            createMap(t, value);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h6 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h6><p>remove()方法不得不提。首先我们思考一下，既然已经有了弱引用，按理说，如果线程没有持有某个value的时候，会在GC的时候自动清理掉对应的Entry，为什么会有remove()方法存在？<br>因为我们在开发一个多线程的程序时，往往会使用线程池。而线程池的功能就是线程的复用。那如果线程池和ThreadLocal在一起就可能会造成一个问题：</p>
<ul>
<li>job A和job B共用了同一个线程，</li>
<li>job A使用完ThreadLocal，ThreadLocal里面还有job A保存的值，而这个时候可能还没有清理掉，</li>
<li>job B复用线程进来了，取出来是 job A的值，可能就会造成问题。</li>
</ul>
<p>所以在有必要的时候，可以在使用完ThreadLocal的时候，显式调用一下remove()方法。remove()方法的源码也比较简单，就是调用对应的 entry 的 clear()方法。 同时,remove() 方法也能很好的避免内存泄露问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#remove</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//java.lang.ThreadLocal#remove</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear(); <span class="hljs-comment">//删除entry</span><br>            expungeStaleEntry(i); <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用ThreadLocal的注意事项"><a href="#使用ThreadLocal的注意事项" class="headerlink" title="使用ThreadLocal的注意事项"></a>使用ThreadLocal的注意事项</h4><h5 id="ThreadLocal-内存泄露"><a href="#ThreadLocal-内存泄露" class="headerlink" title="ThreadLocal 内存泄露"></a>ThreadLocal 内存泄露</h5><h6 id="ThreadLocal-为什么会内存泄露"><a href="#ThreadLocal-为什么会内存泄露" class="headerlink" title="ThreadLocal 为什么会内存泄露"></a>ThreadLocal 为什么会内存泄露</h6><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        executorService.execute(() -&gt; &#123;<br>            ThreadLocal&lt;RedSpider&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>            <span class="hljs-type">RedSpider</span> <span class="hljs-variable">redSpider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedSpider</span>();<br>            threadLocal.set(redSpider);<br>            <span class="hljs-comment">//threadLocal=null          //将threadLocal 引用赋值为空</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码逻辑图如下:<img src="/posts/60838/5.png" srcset="/img/loading.gif" lazyload alt="实例代码逻辑图.png"></p>
<p>我们在前面介绍ThreadLocalMap时已知：ThreadLocalMap中，Entry的key为 WeakReference，当我们给 threadLocal&#x3D;null 时，逻辑图中 强引用 ② 会消失，这样 ThreadLocal对象实例只有一个 Entry中的 key 的一个 弱引用③。因为弱引用的性质，在下一次 GC 时就会回收 ThreadLocal对象实例。这时逻辑图中的引用只剩下 强引用① 和 强引用④ 。如果当前线程迟迟不断掉的话就会一直存在一条强引用链：thread(ref)-&gt;Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;redSpider(ref) 。所以ThreadLocal 内存泄露的原因也就找到了：</p>
<ol>
<li>堆中有一个强引用指向 RedSpider对象实例，该实例没法被 GC。</li>
<li>因为 Entry 的 key 为null ,所以没有任何途径能够接触到redSpider(ref)，因此也不能访问到 RedSpider对象实例。</li>
</ol>
<h6 id="ThreadLocal-解决方法"><a href="#ThreadLocal-解决方法" class="headerlink" title="ThreadLocal 解决方法"></a>ThreadLocal 解决方法</h6><p>由上图 源码解析中： <code>remove()</code>方法 中调用了一个<code>expungeStaleEntry()</code> 方法，这个方法是解决问题的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// staleSlot index of slot known to have null key; </span><br><span class="hljs-comment">// java.lang.ThreadLocal.ThreadLocalMap#expungeStaleEntry</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// ...(省略)</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>入参：<code>staleSlot</code> index of slot known to have null key; 该方法的逻辑：</p>
<ul>
<li>将entry里值的强引用(强引用④)置为null(这样值对象就对被GC回收)。</li>
<li>将entry对应引用(弱引用③)置为null(这样Entry就能被GC回收)。</li>
</ul>
<p>这样逻辑图中只剩下<code>强引用①</code> 和<code>强引用③</code> ,这样<code>RedSpider对象实例</code> 和对应的 <code>Entry</code> 实例就可以被回收掉了。<br>因此，只要调用了<code>expungeStaleEntry()</code> 就能将无用 Entry 回收清除掉。<br>ThreadLocalMap 中 <code>get()</code>方法 ，<code>set()</code>方法，间接的调用了该方法。<code>remove()</code>方法直接调用了该方法，以下为expungeStaleEntry() 方法的调用链。</p>
<p><img src="/posts/60838/expungeStaleEntry.png" srcset="/img/loading.gif" lazyload alt="类图"></p>
<p>综上所述：针对ThreadLocal 内存泄露的原因，我们可以从两方面去考虑：</p>
<ol>
<li>删除无用 Entry 对象，断掉指向ThreadLocal实例的弱引用。即 用完ThreadLocal后手动调用remove()方法。</li>
<li>可以让ThreadLocal 的强引用一直存在，保证任何时候都可以通过 ThreadLocal 的弱引用访问到 Entry的 value值。即 将ThreadLocal 变量定义为 private static</li>
</ol>
<h5 id="ThreadLocal-父子线程传值"><a href="#ThreadLocal-父子线程传值" class="headerlink" title="ThreadLocal 父子线程传值"></a>ThreadLocal 父子线程传值</h5><h6 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h6><p>5.5.4章节中我们简单介绍了一下 InheritableThreadLocal。下面来看看 InheritableThreadLocal是如何使用的。 示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            InheritableThreadLocal&lt;String&gt; itl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();  ①<br>            itl.set(<span class="hljs-string">&quot;InheritableThreadLocal&quot;</span>);<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> itl.get();<br>                <span class="hljs-comment">//拿到父线程放进去的“InheritableThreadLocal”，因为tl是InheritableThreadLocal</span><br>                System.out.println(str);<br>            &#125;);<br>            b.start();<br><br>            <span class="hljs-comment">//确保子线程b执行完毕 </span><br>            Thread.sleep(<span class="hljs-number">10</span>);<br><br>            itl.remove();<br>        &#125;);<br>        a.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>InheritableThreadLocal<br><span class="hljs-comment">//如果 ① 处定义的是 ThreadLocal 执行结果则为 </span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>可以看到使用了 InheritableThreadLocal 后，子线程b 获取到了父线程a set 的值。</p>
<p>原理： 首先我们看ThreadLocal 类的 <code>set(T value)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#set      </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);     <span class="hljs-comment">//如果map为空，调用createMap 方法</span><br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocal#createMap  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal 类给当前线程的threadLocals变量赋值</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue); <br>&#125;<br><br><span class="hljs-comment">//java.lang.InheritableThreadLocal#createMap </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">//InheritableThreadLocal的 inheritableThreadLocals 变量赋值</span><br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue); <br>&#125;<br><br><span class="hljs-comment">//与此线程有关的 ThreadLocal 值，由ThreadLocal 类维护</span><br><span class="hljs-comment">//java.lang.Thread</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//与此线程有关的 InheritableThreadLocal 值，由InheritableThreadLocal 类维护</span><br><span class="hljs-comment">//java.lang.Thread</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到 当我们调用 <code>set()</code> 方法时，如果声明的是 InheritableThreadLocal 类时，会给当前线程的 inheritableThreadLocals 变量赋值。<br>在Thread 类中只有两处使用到 <code>inheritableThreadLocals</code> 变量。分别是 <code>init()</code>方法和 <code>exit()</code>方法。<code>exit()</code> 方法是给当前线程的一写变量赋值为null，这里不做过多阐述。<code>init()</code>方法是什么？通过查看调用该方法的地方可以看到，Thread 类的所有构造函数都调用了init() 方法。即当我们新建一个线程时，就会调用<code>init()</code> 方法，并给线程的inheritableThreadLocals 变量赋值。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.Thread#init</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><br><span class="hljs-params">                  <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;<br>       <span class="hljs-comment">//省略 ...</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();             <span class="hljs-comment">//这里的parent指的是调用init()方法的线程，即所谓的父线程</span><br>    <span class="hljs-comment">//省略 ...</span><br>    <span class="hljs-comment">//如果inheritThreadLocals 为ture 并且当前线程的inheritableThreadLocals变量不为空</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);  <span class="hljs-comment">//这里传入的是当前线程的 inheritableThreadLocals 变量</span><br>       <span class="hljs-comment">//省略 ...</span><br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocal#createInheritedMap</span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);<br>&#125;<br><br><span class="hljs-comment">//java.lang.ThreadLocalMap Constructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>        <span class="hljs-comment">//父线程 Entry</span><br>        Entry[] parentTable = parentMap.table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>        setThreshold(len);<br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br>        <span class="hljs-comment">//每个Entry都赋值到子线程的Entry</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>                <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//关键的一行 e.value是父线程Entry中的值,childValue()是一个可重载的方法,</span><br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);<br>                    <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>                        h = nextIndex(h, len);<br>                    table[h] = c;<br>                    size++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//java.lang.ThreadLocal#childValue</span><br>T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-comment">//java.lang.InheritableThreadLocal#childValue 对于 InheritableThreadLocal 来说，返回了传入的值。</span><br> <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>    <span class="hljs-keyword">return</span> parentValue;                  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们再调用 <code>get()</code> 方法获取时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.lang.ThreadLocal#get</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);     <span class="hljs-comment">//InheritableThreadLocal 对象调用getMap()方法时，会返回当前线程的inheritableThreadLocals 变量</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>); <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><span class="hljs-comment">//java.lang.InheritableThreadLocal#getMap</span><br> ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>   <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>综上可得：当我们使用 InheritableThreadLocal 时，当前线程的数据会存储在 inheritableThreadLocals变量赋值，将数据存储在inheritableThreadLocals 指向的 ThreadLocalMap 中。当新建一个子线程时，会将当前线程的 inheritableThreadLocals里的 ThreadLocalMap 赋值给 子线程的 inheritableThreadLocals 变量。然后子线程 通过调用InheritableThreadLocal 对象的 <code>get()</code> 方法可以得到相应的值。</p>
<h6 id="InheritableThreadLocal-无法向线程池中的子线程传递数据"><a href="#InheritableThreadLocal-无法向线程池中的子线程传递数据" class="headerlink" title="InheritableThreadLocal 无法向线程池中的子线程传递数据"></a>InheritableThreadLocal 无法向线程池中的子线程传递数据</h6><p>平常我们开发时很少新建线程来并发编程，一般都是使用线程池。但是 InheritableThreadLocal 无法向线程池中的子线程传递数据 示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        InheritableThreadLocal&lt;String&gt; itl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>        itl.set(<span class="hljs-string">&quot;first&quot;</span>);<br>        executorService.execute(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">firstValue</span> <span class="hljs-operator">=</span> itl.get();<br>            System.out.println(firstValue);<br>        &#125;);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        itl.remove();<br><br>        itl.set(<span class="hljs-string">&quot;second&quot;</span>);<br>        executorService.execute(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">secondValue</span> <span class="hljs-operator">=</span> itl.get();<br>            System.out.println(secondValue);<br>        &#125;);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        itl.remove();<br>    &#125;<br>&#125;<br><br>执行结果：<br>first<br>first<br></code></pre></td></tr></table></figure>

<p>我们预期得到的结果是 first second，然而现在输出的却是 first first。说明我们 InheritableThreadLocal 对象第二次调用 set()方法失效。 在上面原理中讲过，Thread 对象的 inheritableThreadLocals 变量只有在新建线程时会从父线程的inheritableThreadLocals 变量中拷贝过来。所以后续阶段，没有能使 子线程的inheritableThreadLocals变量变化的地方，所以第二次调用 <code>get()</code>方法输出的还是 first。在线程池中，由于线程复用所以我们也不能通过 InheritableThreadLocal 类来传递值。关于线程池线程复用，详见 12.2.4 ThreadPoolExecutor如何做到线程复用的？ alibaba 提供了 <strong>transmittable-thread-local</strong> 框架来解决了 在使用线程池等会池化复用线程的执行组件情况下传递ThreadLocal值问题。</p>
<h6 id="transmittable-thread-local"><a href="#transmittable-thread-local" class="headerlink" title="transmittable-thread-local"></a>transmittable-thread-local</h6><p>对于 <strong>transmittable-thread-local</strong> 我们不做过多阐述，只介绍核心思想。 由上文可知：InheritableThreadLocal 是在创建线程时将父类线程赋值到Thread的 inheritableThreadLocals 变量中，当子线程调用对应的get方法时读取inheritableThreadLocals 变量，这样就完成了父子线程之间变量的传递，但是由于我们使用线程池提交任务的时候并非总是新建一个线程来执行任务，这导致InheritableThreadLocal 的工作原理不适用于 线程池。但我们思考一下，InheritableThreadLocal 是父线程创建子线程的时候将值传递，每创建一下新线程都会在 init()方法中进行操作，而我们使用线程池的时候，有那些操作是这种“新建” 的呢？ 没错，线程池每次提交的任务 Runnable对象 就是一个新的，不会重复的。所以我们新建一个类实现Runnable接口，然后将父线程得知封装在我们新建的类中。</p>
<p>请看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 在父线程中设置</span><br>        context.set(<span class="hljs-string">&quot;first&quot;</span>);<br>        <span class="hljs-comment">//创建runnable 对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">firstRunnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">firstValue</span> <span class="hljs-operator">=</span> context.get();<br>            System.out.println(firstValue);<br>        &#125;;<br>        <span class="hljs-comment">//封装为TtlRunnable对象</span><br>        <span class="hljs-type">TtlRunnable</span> <span class="hljs-variable">firstTtlRunnable</span> <span class="hljs-operator">=</span> TtlRunnable.get(firstRunnable);<br>        <span class="hljs-comment">//提交任务</span><br>        executorService.execute(firstTtlRunnable);<br>        <span class="hljs-comment">//确保线程池任务执行完</span><br>        Thread.sleep(<span class="hljs-number">10</span>);<br><br>        context.set(<span class="hljs-string">&quot;second&quot;</span>);<br>        <span class="hljs-comment">//创建runnable 对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">secondRunnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">secondValue</span> <span class="hljs-operator">=</span> context.get();<br>            System.out.println(secondValue);<br>        &#125;;<br>        <span class="hljs-comment">//封装为TtlRunnable对象</span><br>        <span class="hljs-type">TtlRunnable</span> <span class="hljs-variable">secondTtlRunnable</span> <span class="hljs-operator">=</span> TtlRunnable.get(secondRunnable);<br>        <span class="hljs-comment">//提交任务</span><br>        executorService.execute(secondTtlRunnable);<br><br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        context.remove();<br><br>    &#125;<br>&#125;<br><br><br>输出结果：<br>first<br>second<br></code></pre></td></tr></table></figure>

<p>由此可见，使用TransmittableThreadLocal，将 Runnable 封装成 TtlRunnable 对象完成了线程池中父子线程中值的传递。</p>
<p>首先我们先看看TransmittableThreadLocal 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TtlCopier</span>&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 TransmittableThreadLocal类 继承了 InheritableThreadLocal。 然后我们来看看相关方法：<br>set()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com.alibaba.ttl.TransmittableThreadLocal#set</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!disableIgnoreNullValueSemantics &amp;&amp; <span class="hljs-literal">null</span> == value) &#123;<br>        <span class="hljs-comment">// may set null to remove value</span><br>        remove();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//赋值,将value赋值给Thread的 inheritableThreadLocals 变量</span><br>        <span class="hljs-built_in">super</span>.set(value);<br>        <span class="hljs-comment">//将当前对象塞到 TransmittableThreadLocal类 的holder 变量中</span><br>        addThisToHolder();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//java.lang.ThradLocal#set</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//调用的是InheritableThreadLocal的getMap()方法</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t); <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//调用的是InheritableThreadLocal的createMap()方法</span><br>        createMap(t, value);<br>&#125;<br><span class="hljs-comment">//java.lang.InheritableThreadLocal#getMap</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>   <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br><span class="hljs-comment">////java.lang.InheritableThreadLocal#createMap</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br><br><span class="hljs-comment">//com.alibaba.ttl.TransmittableThreadLocal#addThisToHolder</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThisToHolder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!holder.get().containsKey(<span class="hljs-built_in">this</span>)) &#123;<br>        holder.get().put((TransmittableThreadLocal&lt;Object&gt;) <span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// WeakHashMap supports null value.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由上可知，调用TransmittableThreadLocal 的<code>set(T value)</code>方法会将value 赋值给Thread(调用线程) 的inheritableThreadLocals 变量。然后将当前 TransmittableThreadLocal 对象存了起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Note about the holder:</span><br><span class="hljs-comment">// 1. holder self is a InheritableThreadLocal(a *ThreadLocal*).</span><br><span class="hljs-comment">// 2. The type of value in the holder is WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;.</span><br><span class="hljs-comment">//    2.1 but the WeakHashMap is used as a *Set*:</span><br><span class="hljs-comment">//        the value of WeakHashMap is *always* null, and never used.</span><br><span class="hljs-comment">//    2.2 WeakHashMap support *null* value.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);<br>            &#125;<br>        &#125;;<br></code></pre></td></tr></table></figure>

<h4 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h4><h5 id="资源持有"><a href="#资源持有" class="headerlink" title="资源持有"></a>资源持有</h5><p>比如我们有三个不同的类。在一次Web请求中，会在不同的地方，不同的时候，调用这三个类的实例。但用户是同一个，用户数据可以保存在<strong>一个线程</strong>里。<img src="/posts/60838/6.png" srcset="/img/loading.gif" lazyload alt="线程资源持有">这个时候，我们可以在程序1把用户数据放进ThreadLocalMap里，然后在程序2和程序3里面去用它。 这样做的优势在于：持有线程资源供线程的各个部分使用，全局获取，降低<strong>编程难度</strong>。</p>
<h5 id="线程一致"><a href="#线程一致" class="headerlink" title="线程一致"></a>线程一致</h5><p>这里以JDBC为例。我们经常会用到事务，它是怎么实现的呢？</p>
<p><img src="/posts/60838/7.png" srcset="/img/loading.gif" lazyload alt="线程资源一致性"></p>
<p>原来，我们每次对数据库操作，都会走JDBC getConnection，JDBC保证只要你是同一个线程过来的请求，不管是在哪个part，都返回的是同一个连接。这个就是使用ThreadLocal来做的。 当一个part过来的时候，JDBC会去看ThreadLocal里是不是已经有这个线程的连接了，如果有，就直接返回；如果没有，就从连接池请求分配一个连接，然后放进ThreadLocal里。 这样就可以保证一个事务的所有part都在一个连接里。TheadLocal可以帮助它维护这种一致性，降低<strong>编程难度</strong>。</p>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>假设我们一个线程的调用链路比较长。在中途中出现异常怎么做？我们可以在出错的时候，把错误信息放到ThreadLocal里面，然后在后续的链路去使用这个值。使用TheadLocal可以保证多个线程在处理这个场景的时候保证线程安全。</p>
<p><img src="/posts/60838/8.png" srcset="/img/loading.gif" lazyload alt="线程安全"></p>
<h5 id="并发计算"><a href="#并发计算" class="headerlink" title="并发计算"></a>并发计算</h5><p>如果我们有一个大的任务，可以把它拆分成很多小任务，分别计算，然后最终把结果汇总起来。如果是分布式计算，可能是先存储在自己的节点里。而如果是单机下的多线程计算，可以把每个线程的计算结果放进ThreadLocal里面，最后取出来汇总。</p>
<p><img src="/posts/60838/9.png" srcset="/img/loading.gif" lazyload alt="分布式计算"></p>
<h4 id="ThreadLocal-在一些开源框架中的应用"><a href="#ThreadLocal-在一些开源框架中的应用" class="headerlink" title="ThreadLocal 在一些开源框架中的应用"></a>ThreadLocal 在一些开源框架中的应用</h4><h5 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h5><p>Quartz是一个非常知名的开源任务调度系统。以 <code>2.3.2</code>版本为例 我们要看的源码是Quartz的<strong>SimpleSemaphore</strong>这个类。它是一个信号量的实现，在生产者-消费者模型里，信号量代表的就是队列里有多少item需要处理。 在信号量的模型里面有一个“等待”操作。当消费者消费完后，会轮询等待。<strong>SimpleSemaphore</strong>有一个获取锁的方法<code>**obtainLock()**</code>，我们要看的也是这个方法的内部代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSemaphore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Semaphore</span> &#123;<br>ThreadLocal&lt;HashSet&lt;String&gt;&gt; lockOwners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HashSet&lt;String&gt;&gt;();<br><br>    HashSet&lt;String&gt; locks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><br>     <span class="hljs-keyword">private</span> HashSet&lt;String&gt; <span class="hljs-title function_">getThreadLocks</span><span class="hljs-params">()</span> &#123;<br>        HashSet&lt;String&gt; threadLocks = lockOwners.get();<br>        <span class="hljs-keyword">if</span> (threadLocks == <span class="hljs-literal">null</span>) &#123;<br>            threadLocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>            lockOwners.set(threadLocks);<br>        &#125;<br>        <span class="hljs-keyword">return</span> threadLocks;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Grants a lock on the identified resource to the calling thread (blocking</span><br><span class="hljs-comment">     * until it is available).</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if the lock was obtained.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">obtainLock</span><span class="hljs-params">(Connection conn, String lockName)</span> &#123;<br><br>        lockName = lockName.intern();<br><br>        <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>            log.debug(<br>                <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; is desired by: &quot;</span><br>                        + Thread.currentThread().getName());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!isLockOwner(lockName)) &#123;<br>            <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                log.debug(<br>                    <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; is being obtained: &quot;</span><br>                            + Thread.currentThread().getName());<br>            &#125;<br>            <span class="hljs-keyword">while</span> (locks.contains(lockName)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                    <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                        log.debug(<br>                            <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; was not obtained by: &quot;</span><br>                                    + Thread.currentThread().getName());<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>                log.debug(<br>                    <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; given to: &quot;</span><br>                            + Thread.currentThread().getName());<br>            &#125;<br>            getThreadLocks().add(lockName);<br>            locks.add(lockName);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(log.isDebugEnabled()) &#123;<br>            log.debug(<br>                <span class="hljs-string">&quot;Lock &#x27;&quot;</span> + lockName + <span class="hljs-string">&quot;&#x27; already owned by: &quot;</span><br>                        + Thread.currentThread().getName()<br>                        + <span class="hljs-string">&quot; -- but not owner!&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;stack-trace of wrongful returner&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>36行的while循环就是去进行轮询操作，while里面的locks是一个<strong>HashSet</strong>，为true代表这个lockName对应的锁正在被别的线程持有，所以当前线程需要等待。 我们看到，在while循环的外层30行，有一个判断，其实是用到了ThreadLocal。这个外层的判断起什么作用呢？其实是<strong>判断当前线程是否已经持有了这个锁</strong>。如果持有了，那就直接跳到最后return true了。因为同一个线程，可能有多个程序片段会调用这个获取锁的方法。 可以看到，使用ThreadLocal可以非常高效地判断当前线程的状态，可以快速检测出当前线程是否已经获取了锁，避免了后续锁的检测和争用。</p>
<h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h5><p>Mybatis不用多说，搞Java的应该都听过或者用过。我们今天要介绍的是它的SqlSessionManager。Mybatis是一个持久化框架。持久化框架，必然会面临事务的问题。我们的数据库（比如MySQL）可以保证本地事务，但也要求必须在同一个连接才行。 应用程序使用MyBatis，可能会在多个程序片段去访问数据库，做一些增删改查的操作。它们可能需要在同一个事务里面。举个例子，我们修改完订单状态后，可能还需要修改积分，它们应该在同一个事务里。Mybatis使用SqlSessionManager保证了我们同一个线程取出来的连接总是同一个。它是如何做到的呢？其实很简单，就是内部使用了一个ThreadLocal。然后所有的创建连接、取连接都是通过这个ThreadLocal变量的get&#x2F;set方法进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlSessionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSessionFactory</span>, SqlSession &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">// 创建连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startManagedSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.localSqlSession.set(openSession());<br>    &#125;<br><br>    <span class="hljs-comment">// 取连接</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> localSqlSession.get();<br>        <span class="hljs-keyword">if</span> (sqlSession == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionException</span>(<span class="hljs-string">&quot;Error:  Cannot get connection.  No managed session is started.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSession.getConnection();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ThreadLocal-扩展"><a href="#ThreadLocal-扩展" class="headerlink" title="ThreadLocal 扩展"></a>ThreadLocal 扩展</h4><p><code>Netty</code> 中的<code>FastThreadLocal</code> 和 <code>Dubbo</code> 中的<code>InternalThreadLocal</code> 都对JDK的 <code>ThreadLocal</code> 进行了增强， 本文不做过多阐述</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Thread/" class="category-chain-item">Thread</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/Thread/" class="print-no-link">#Thread</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 线程（三）</div>
      <div>https://sugayoiya.github.io/posts/60838.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sugayoiya</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年7月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/41603.html" title="过滤器 Filter 和拦截器 Interceptor 的异同">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">过滤器 Filter 和拦截器 Interceptor 的异同</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/57823.html" title="Java 线程（二）">
                        <span class="hidden-mobile">Java 线程（二）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"waline-mongo-gamma.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://unpkg.com/@waline/emojis@1.1.0/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
