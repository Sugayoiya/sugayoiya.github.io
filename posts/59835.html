

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browser.png">
  <link rel="icon" href="/img/browser.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sugayoiya">
  <meta name="keywords" content="">
  
    <meta name="description" content="AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过横切关注点（Cross-cutting Concerns）的抽象和模块化，将系统的功能和非功能需求分离，从而提高代码的可维护性、可重用性和灵活性">
<meta property="og:type" content="article">
<meta property="og:title" content="代理 Proxy 反射 Reflect 与 Spring AOP">
<meta property="og:url" content="https://sugayoiya.github.io/posts/59835.html">
<meta property="og:site_name" content="東方プロジェクト">
<meta property="og:description" content="AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过横切关注点（Cross-cutting Concerns）的抽象和模块化，将系统的功能和非功能需求分离，从而提高代码的可维护性、可重用性和灵活性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sugayoiya.github.io/img/post/Fu4UyT-aMAEnBuE.jpeg">
<meta property="article:published_time" content="2021-08-01T13:03:44.000Z">
<meta property="article:modified_time" content="2023-07-25T08:55:47.000Z">
<meta property="article:author" content="Sugayoiya">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="AOP">
<meta property="article:tag" content="Reflect">
<meta property="article:tag" content="Proxy">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://sugayoiya.github.io/img/post/Fu4UyT-aMAEnBuE.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>代理 Proxy 反射 Reflect 与 Spring AOP - 東方プロジェクト</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sugayoiya.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"vggcI4F6j2ISzL56HSxMZF9V-MdYXbMMI","app_key":"yKtFKhuP8rhbpXecJ4jmPFmq","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sugayoiya</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>妖怪の山</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>紅魔館</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>雾之湖</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>人間の里</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>永遠亭</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post/%E5%91%BD%E3%81%AB%E5%AB%8C%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="代理 Proxy 反射 Reflect 与 Spring AOP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-08-01 21:03" pubdate>
          2021年8月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          65k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          109 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">代理 Proxy 反射 Reflect 与 Spring AOP</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>AOP</strong>（<em>Aspect-Oriented Programming</em>，面向切面编程）是一种编程范式，旨在通过横切关注点（<em>Cross-cutting Concerns</em>）的抽象和模块化，将系统的功能和非功能需求分离，从而提高代码的可维护性、可重用性和灵活性</p>
<span id="more"></span>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP的这种模式，底层就是基于代理模式实现</p>
<p><strong>代理模式</strong>（<em>Proxy Pattern</em>）是一种结构型设计模式，也叫<strong>委托模式</strong>，它允许通过一个代理对象来控制对另一个对象的访问。代理对象充当另一个对象的接口，以控制对该对象的访问，并在必要时添加额外的逻辑。代理模式主要用于对目标对象的访问进行控制，可以用于实现懒加载、访问控制、缓存、日志记录等功能</p>
<p>代理模式一般分为以下三个角色：</p>
<ol>
<li><p><strong>抽象主题</strong>（Subject）：定义了目标对象和代理对象的共同接口，这样在任何使用目标对象的地方都可以使用代理对象</p>
</li>
<li><p><strong>真实主题</strong>（Real Subject）：也称为被代理对象或目标对象，它是代理模式中的真正业务逻辑的实现</p>
</li>
<li><p><strong>代理</strong>（Proxy）：代理对象，它持有对真实主题的引用，并实现了抽象主题的接口。代理对象通常在客户端与真实主题之间起到中介的作用，它可以在调用真实主题之前或之后执行一些附加操作</p>
</li>
</ol>
<h5 id="代理模式实现"><a href="#代理模式实现" class="headerlink" title="代理模式实现"></a>代理模式实现</h5><p>下面是一个简单的Java中代理模式的实现示例，使用了静态代理方式：</p>
<ol>
<li>定义抽象主题接口（Subject）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定义真实主题类（RealSubject）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>定义代理类（Proxy）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Proxy.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span> &#123;<br>        realSubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        realSubject.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>客户端代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用代理对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>();<br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Proxy</span></span> is doing something before the RealSubject...<br><span class="hljs-function"><span class="hljs-title">RealSubject</span></span> is doing something...<br><span class="hljs-function"><span class="hljs-title">Proxy</span></span> is doing something after the RealSubject...<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，抽象主题（Subject）定义了一个接口，真实主题（RealSubject）实现了这个接口，代理类（Proxy）也实现了这个接口，并在方法中调用了真实主题对象的方法，同时添加了一些额外的操作。客户端通过代理对象来访问真实主题，而无需直接与真实主题交互。这样，代理对象就控制了对真实主题的访问，并且可以在调用前后添加一些自定义的逻辑</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理与静态代理的区别，首先要了解两个前置知识点：Java程序的执行以及类加载机制</p>
<ul>
<li>Java程序的执行过程<ul>
<li>编写源代码：首先，开发人员使用Java编程语言编写源代码，源代码通常以<code>.java</code>为扩展名</li>
<li>编译源代码：使用Java编译器（javac）对源代码进行编译，将源代码转换为字节码文件。字节码文件以<code>.class</code>为扩展名，并包含Java虚拟机（JVM）可执行的中间代码</li>
<li>执行<code>.class</code> 文件</li>
</ul>
</li>
<li>类加载机制<ul>
<li><strong>加载</strong>（loading）：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的 <code>java.lang.class</code> 对象，作为方法区这个类的各种数据访问入口</li>
<li><strong>连接</strong>（Linking）：<br>   类加载的连接阶段包括三个子阶段：<ul>
<li>验证（Verification）：对加载的类进行验证，确保其符合Java虚拟机规范和安全要求</li>
<li>准备（Preparation）：为类的静态变量分配内存空间，并设置默认初始值</li>
<li>解析（Resolution）：将类的符号引用（常量池中的符号）解析为直接引用，建立对其他类的引用关系</li>
</ul>
</li>
<li><strong>初始化</strong>（Initialization）：<ul>
<li>在初始化阶段，执行类的静态代码块和静态初始化语句，对类的静态变量进行初始化</li>
<li>初始化阶段是类加载的最后一个阶段，在此阶段完成后，Java类对象被完全初始化，可以被使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>动态代理和静态代理是两种不同的代理模式实现方式，它们在代理对象的创建和使用方式上存在一些区别</p>
<ol>
<li><p>创建时机和方式：</p>
<ul>
<li>静态代理：在编译阶段就需要创建代理类，代理类是由开发者手动编写的。对于每一个被代理的类，都需要创建一个相应的代理类</li>
<li>动态代理：在运行时动态生成代理类，无需手动编写代理类。代理类是在程序运行时根据接口或类信息动态创建的</li>
</ul>
</li>
<li><p>代理对象与目标对象的关系：</p>
<ul>
<li>静态代理：代理对象和目标对象之间的关系是静态的，即在编译时就已经确定了。每个代理类只能代理一个目标类，代理类与目标类是一一对应的关系</li>
<li>动态代理：代理对象和目标对象之间的关系是动态的，即在程序运行时根据需要动态生成代理类。一个动态代理类可以代理多个目标类，代理对象的关联是在运行时决定的</li>
</ul>
</li>
<li><p>实现方式：</p>
<ul>
<li>静态代理：通过手动编写代理类来实现，需要为每一个目标类创建一个代理类</li>
<li>动态代理：使用Java的反射机制，在运行时动态生成代理类。Java提供了两种动态代理的方式：基于接口的代理（JDK动态代理）和基于类的代理（CGLIB动态代理）</li>
</ul>
</li>
<li><p>灵活性：</p>
<ul>
<li>静态代理：代理类的创建和目标类的绑定是在编译时确定的，因此在程序运行时无法动态改变代理关系。</li>
<li>动态代理：由于代理类是在运行时生成的，因此可以根据需要动态地改变代理关系，更加灵活。</li>
</ul>
</li>
</ol>
<p>总体而言，静态代理需要手动编写代理类，对于少量目标类的代理是可行的，但当目标类数量较多时会产生大量重复代码。而动态代理通过在运行时动态生成代理类，避免了手动编写代理类的繁琐过程，适用于代理对象较多、代理关系动态变化的情况</p>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JDK动态代理是Java中实现动态代理的一种机制，它是Java标准库（<code>java.lang.reflect</code>包）提供的一种代理方式。JDK动态代理基于接口的代理方式，通过在运行时动态生成代理类来实现代理功能。JDK动态代理使用了Java的反射机制来实现，可以在运行时创建代理对象，无需手动编写代理类</p>
<p>JDK动态代理的核心类是<code>java.lang.reflect.Proxy</code>，它提供了静态方法<code>newProxyInstance()</code>来创建代理对象。<code>newProxyInstance()</code>方法接收三个参数：</p>
<ol>
<li><code>ClassLoader</code>：用于加载动态生成的代理类的类加载器。</li>
<li><code>Class[] interfaces</code>：代理类要实现的接口数组，代理对象将实现这些接口。</li>
<li><code>InvocationHandler</code>：代理对象的调用处理程序，它定义了代理对象在执行方法时的行为。</li>
</ol>
<p>以下是一个使用JDK动态代理的简单示例：</p>
<ol>
<li>定义抽象主题接口（Subject）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定义真实主题类（RealSubject）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>定义代理处理程序（MyInvocationHandler）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyInvocationHandler.java</span><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object realSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.realSubject = realSubject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(realSubject, args);<br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>客户端代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建真实主题对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br><br>        <span class="hljs-comment">// 创建代理处理程序</span><br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(realSubject);<br>        <span class="hljs-comment">// 获取对应的 ClassLoader</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> realSubject.getClass().getClassLoader();<br>        <span class="hljs-comment">// 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService</span><br>        Class[] interfaces = realSubject.getClass().getInterfaces()<br><br>        <span class="hljs-comment">// 创建代理对象</span><br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(<br>                classLoader,<br>                interfaces,<br>                handler);<br><br>        <span class="hljs-comment">// 使用代理对象</span><br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy is doing something before the RealSubject...<br>RealSubject is doing something...<br>Proxy is doing something after the RealSubject...<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过 <code>Proxy.newProxyInstance()</code> 方法创建了一个代理对象，该代理对象实现了<code>Subject</code>接口，并在调用方法时通过 <code>MyInvocationHandler</code> 中定义的逻辑来进行增强操作。这样，我们就实现了一个基于JDK动态代理的简单代理功能</p>
<h5 id="JDK动态代理分析"><a href="#JDK动态代理分析" class="headerlink" title="JDK动态代理分析"></a>JDK动态代理分析</h5><p><code> Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span> &#123;<br>    Objects.requireNonNull(h);<br><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br>    <span class="hljs-comment">// 查询（在缓存中已经有）或生成指定的代理类的class对象。</span><br>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>        &#125;<br>        <span class="hljs-comment">// 返回对应参数的公共构造函数</span><br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;<br>        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    cons.setAccessible(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 生成代理对象</span><br>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);<br>    &#125;   <br>    ... <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后来到 <code>ProxyClassFactory</code> 的 <code>apply()</code> 方法，代理类就是在这里生成的</p>
<h5 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h5><p>CGLib动态代理是另一种实现动态代理的方式，它与JDK动态代理不同，不基于接口，而是对类进行代理。CGLib是一个强大的代码生成库，它能够在运行时扩展Java类和实现代理功能。CGLib动态代理的原理是通过生成目标类的子类来实现代理，因此被代理的类不能是final类，且代理的方法不能是final或static的。两者的区别有以下几点：</p>
<ol>
<li>Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类。</li>
<li>Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB 使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效。</li>
</ol>
<p>CGLib动态代理的核心类是 <code>net.sf.cglib.proxy.Enhancer</code>，它是CGLib库中的代理增强类，用于生成代理类的实例。使用CGLib动态代理需要依赖CGLib库。</p>
<p>以下是一个使用CGLib动态代理的简单示例：</p>
<ol>
<li>定义目标类（<code>RealSubject</code>）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RealSubject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject is doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定义代理处理程序（<code>MyMethodInterceptor</code>）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyMethodInterceptor.java</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// before</span><br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something before the RealSubject...&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        <span class="hljs-comment">// after</span><br>        System.out.println(<span class="hljs-string">&quot;Proxy is doing something after the RealSubject...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>intercept</code>方法四个参数的含义如下： <code>obj</code>: 代理类对象。 <code>method</code>: 被代理的类中的方法。 <code>args</code>: 调用方法需要的参数。 <code>proxy</code>: 生成的代理类对方法的<strong>代理引用</strong></p>
<p>用户需要实现<code>MethodInterceptor</code>接口，实现对方法的拦截。这一点与JDK动态代理中用户需要实现<code>InvocationHandler</code>接口类似</p>
<ol start="3">
<li>客户端代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client.java</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建代理处理程序</span><br>        <span class="hljs-type">MyMethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>();<br><br>        <span class="hljs-comment">// 使用Enhancer创建代理对象</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置继承被代理类</span><br>        enhancer.setSuperclass(RealSubject.class);<br>        <span class="hljs-comment">// 设置回调</span><br>        enhancer.setCallback(interceptor);<br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (RealSubject) enhancer.create();<br><br>        <span class="hljs-comment">// 使用代理对象</span><br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy is doing something before the RealSubject...<br>RealSubject is doing something...<br>Proxy is doing something after the RealSubject...<br></code></pre></td></tr></table></figure>

<p>在上面的示例中使用CGLib的 <code>Enhancer</code> 类来创建了一个代理对象，该代理对象继承了 <code>RealSubject</code> 类，并在调用方法时通过 <code>MyMethodInterceptor</code> 中定义的逻辑来进行增强操作。这样就实现了一个基于CGLib动态代理的简单代理功能</p>
<p>需要注意的是，CGLib动态代理相比于JDK动态代理的优点在于它可以代理没有实现接口的类，而且在一些场景下由于继承的方式，可以更高效地执行代理。然而，CGLib动态代理也有一些限制，例如无法代理 <code>final</code> 类和 <code>final</code> 方法</p>
<h5 id="CGLib动态代理分析"><a href="#CGLib动态代理分析" class="headerlink" title="CGLib动态代理分析"></a>CGLib动态代理分析</h5><p><strong>生成指定类Class对象字节数组</strong>，CGLib动态代理会选择目标类（被代理类）作为父类，然后生成代理类的字节码——首先创建<code>Enhancer</code>对象，设置<code>SuperClass</code>父类（被代理类），然后调用<code>Enhancer</code>对象的<code>create()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.classOnly = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.argumentTypes = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.createHelper();<br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createHelper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1.进行有效性验证</span><br>  <span class="hljs-comment">//1.1 callBack不能为空，也就是说至少要有一个callBack(callBack与代理类紧密相关)</span><br>  <span class="hljs-comment">//1.2 有多个callBack时必须有callBackFilter</span><br>    <span class="hljs-built_in">this</span>.preValidate();<br>    <span class="hljs-comment">//2.先根据KEY_FACTORY 以当前代理类的配置信息 生成一个组合Key，再利用这个组合Key，进行create</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEY_FACTORY.newInstance(<span class="hljs-built_in">this</span>.superclass != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.superclass.getName() : <span class="hljs-literal">null</span>, <br>                 ReflectUtils.getNames(<span class="hljs-built_in">this</span>.interfaces), <br>                 <span class="hljs-built_in">this</span>.filter == ALL_ZERO ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakCacheKey</span>(<span class="hljs-built_in">this</span>.filter),                  <br>                 <span class="hljs-built_in">this</span>.callbackTypes, <br>                 <span class="hljs-built_in">this</span>.useFactory, <br>                 <span class="hljs-built_in">this</span>.interceptDuringConstruction, <br>                 <span class="hljs-built_in">this</span>.serialVersionUID);<br>    <span class="hljs-built_in">this</span>.currentKey = key;<br>    <span class="hljs-comment">//根据生成的key创建代理对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.create(key);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后到了 Enhance 继承的 AbstractClassGenerator 类中的 create() 方法，这一步就是为了得到动态类的Class对象，之后通过<strong>反射</strong>生成具体的类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//1.获取当前类加载器，应用类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClassLoader();<br>        <span class="hljs-comment">//2.缓存，一级缓存的key是类加载器,value是ClassLoaderData</span><br>     <span class="hljs-comment">//2.1 cache中有则直接获取</span><br>        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;<br>        <span class="hljs-type">ClassLoaderData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (ClassLoaderData)cache.get(loader);<br>        <span class="hljs-comment">//2.2 cache中没有则生成，双重检查🔒</span><br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> AbstractClassGenerator.class;<br>            <span class="hljs-keyword">synchronized</span>(AbstractClassGenerator.class) &#123;<br>                cache = CACHE;<br>                data = (ClassLoaderData)cache.get(loader);<br>                <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span>) &#123;<br>                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>(cache);<br>                    data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderData</span>(loader);<br>                    newCache.put(loader, data);<br>                    CACHE = newCache;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-comment">//3.调用 get方法获取字节码，如果没有字节码，则会创建字节码（Class对象）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> data.get(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>.getUseCache());<br>        <span class="hljs-comment">//4.生成动态代理类</span><br>        <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> Class ? <span class="hljs-built_in">this</span>.firstInstance((Class)obj) : <span class="hljs-built_in">this</span>.nextInstance(obj);<br>    &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var9) &#123;<br>        <span class="hljs-keyword">throw</span> var9;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var10) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeGenerationException</span>(var10);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ClassLoaderData.get() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-type">boolean</span> useCache)</span> &#123;<br>    <span class="hljs-comment">//判断是否开启缓存，可直接设置：enhancer.setUseCache(false); 默认为true</span><br>    <span class="hljs-keyword">if</span> (!useCache) &#123;<br>        <span class="hljs-keyword">return</span> gen.generate(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cachedValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.generatedClasses.get(gen);<br>        <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进到 AbstractClassGenerator 的 generate() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class <span class="hljs-title function_">generate</span><span class="hljs-params">(ClassLoaderData data)</span> &#123;<br>		Class gen;<br>		<span class="hljs-type">Object</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> CURRENT.get();<br>		CURRENT.set(<span class="hljs-built_in">this</span>);<br>		<span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 1.判断有无classLoader</span><br>			<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> data.getClassLoader();<br>			<span class="hljs-keyword">if</span> (classLoader == <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ClassLoader is null while trying to define class &quot;</span> +<br>						getClassName() + <span class="hljs-string">&quot;. It seems that the loader has been expired from a weak reference somehow. &quot;</span> +<br>						<span class="hljs-string">&quot;Please file an issue at cglib&#x27;s issue tracker.&quot;</span>);<br>			&#125;<br>      <span class="hljs-comment">// 2.生成动态代理的类名</span><br>			<span class="hljs-keyword">synchronized</span> (classLoader) &#123;<br>        <span class="hljs-comment">// 生成代理类名称</span><br>				<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> generateClassName(data.getUniqueNamePredicate());<br>				data.reserveName(name);<br>				<span class="hljs-built_in">this</span>.setClassName(name);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (attemptLoad) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					gen = classLoader.loadClass(getClassName());<br>					<span class="hljs-keyword">return</span> gen;<br>				&#125;<br>				<span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>					<span class="hljs-comment">// ignore</span><br>				&#125;<br>			&#125;<br>      <span class="hljs-comment">// 3.生成动态代理类的字节码</span><br>			<span class="hljs-type">byte</span>[] b = strategy.generate(<span class="hljs-built_in">this</span>);<br>			<span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> ClassNameReader.getClassName(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(b));<br>			<span class="hljs-type">ProtectionDomain</span> <span class="hljs-variable">protectionDomain</span> <span class="hljs-operator">=</span> getProtectionDomain();<br>      <span class="hljs-comment">// 4.生成class文件</span><br>			<span class="hljs-keyword">synchronized</span> (classLoader) &#123; <span class="hljs-comment">// just in case</span><br>				<span class="hljs-comment">// SPRING PATCH BEGIN</span><br>				gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain, contextClass);<br>				<span class="hljs-comment">// SPRING PATCH END</span><br>			&#125;<br>			<span class="hljs-keyword">return</span> gen;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (RuntimeException | Error ex) &#123;<br>			<span class="hljs-keyword">throw</span> ex;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeGenerationException</span>(ex);<br>		&#125;<br>		<span class="hljs-keyword">finally</span> &#123;<br>			CURRENT.set(save);<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>这里第三步的 strategy.generate() 方法是 DefaultGeneratorStrategy 中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultGeneratorStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeneratorStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DefaultGeneratorStrategy</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultGeneratorStrategy</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultGeneratorStrategy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] generate(ClassGenerator cg) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DebuggingClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClassVisitor();<br>        <span class="hljs-built_in">this</span>.transform(cg).generateClass(cw);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.transform(cw.toByteArray());<br>    &#125;<br>    ...<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>getClassVistor</code> 调用了asm的接口，生成了一个 <code>DebuggingClassWriter</code> 对象，这里的cg就是之前的 <code>Enhancer</code> 实例，点进 <code>generateClass()</code> 方法，又回到 <code>Enhance</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateClass</span><span class="hljs-params">(ClassVisitor v)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-type">Class</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (superclass == <span class="hljs-literal">null</span>) ? Object.class : superclass;<br><br>		<span class="hljs-keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot subclass final class &quot;</span> + sc.getName());<br>		<span class="hljs-type">List</span> <span class="hljs-variable">constructors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(Arrays.asList(sc.getDeclaredConstructors()));<br>		filterConstructors(sc, constructors);<br><br>		<span class="hljs-comment">// Order is very important: must add superclass, then</span><br>		<span class="hljs-comment">// its superclass chain, then each interface and</span><br>		<span class="hljs-comment">// its superinterfaces.</span><br>		<span class="hljs-type">List</span> <span class="hljs-variable">actualMethods</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>		<span class="hljs-type">List</span> <span class="hljs-variable">interfaceMethods</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>		<span class="hljs-keyword">final</span> <span class="hljs-type">Set</span> <span class="hljs-variable">forcePublic</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>    <span class="hljs-comment">// 1.得到所有的方法，包括基类、接口</span><br>		getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);<br><br>		<span class="hljs-type">List</span> <span class="hljs-variable">methods</span> <span class="hljs-operator">=</span> CollectionUtils.transform(actualMethods, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>() &#123;<br>			<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object value)</span> &#123;<br>				<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> (Method) value;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Constants.ACC_FINAL<br>						| (method.getModifiers()<br>						&amp; ~Constants.ACC_ABSTRACT<br>						&amp; ~Constants.ACC_NATIVE<br>						&amp; ~Constants.ACC_SYNCHRONIZED);<br>				<span class="hljs-keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;<br>					modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;<br>				&#125;<br>				<span class="hljs-keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);<br>			&#125;<br>		&#125;);<br>    <span class="hljs-comment">// 2.生成字节码，参数还是之前的classWriter</span><br>		<span class="hljs-comment">// 2.1 这里的className就是之前生成的className</span><br>		<span class="hljs-type">ClassEmitter</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassEmitter</span>(v);<br>		<span class="hljs-keyword">if</span> (currentData == <span class="hljs-literal">null</span>) &#123;<br>			e.begin_class(Constants.V1_8,<br>					Constants.ACC_PUBLIC,<br>					getClassName(),<br>					Type.getType(sc),<br>					(useFactory ?<br>							TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :<br>							TypeUtils.getTypes(interfaces)),<br>					Constants.SOURCE_FILE);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			e.begin_class(Constants.V1_8,<br>					Constants.ACC_PUBLIC,<br>					getClassName(),<br>					<span class="hljs-literal">null</span>,<br>					<span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123;FACTORY&#125;,<br>					Constants.SOURCE_FILE);<br>		&#125;<br>		<span class="hljs-type">List</span> <span class="hljs-variable">constructorInfo</span> <span class="hljs-operator">=</span> CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());<br>    <span class="hljs-comment">// 2.2 这些都是字段，之后我们会在生成的文件中看到</span><br>		e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-literal">null</span>);<br>		e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="hljs-literal">null</span>);<br>		<span class="hljs-keyword">if</span> (!interceptDuringConstruction) &#123;<br>			e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-literal">null</span>);<br>		&#125;<br>		e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-literal">null</span>);<br>		e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="hljs-literal">null</span>);<br>		<span class="hljs-keyword">if</span> (serialVersionUID != <span class="hljs-literal">null</span>) &#123;<br>			e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);<br>		&#125;<br>    <span class="hljs-comment">// 2.3 这里就是生成的callback，命名就是CGLIB&amp;CALLBACK_在数组中的序号</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; callbackTypes.length; i++) &#123;<br>			e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="hljs-literal">null</span>);<br>		&#125;<br>		<span class="hljs-comment">// This is declared private to avoid &quot;public field&quot; pollution</span><br>		e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="hljs-literal">null</span>);<br><br>		<span class="hljs-keyword">if</span> (currentData == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 2.5 filter在这里发生作用</span><br>			emitMethods(e, methods, actualMethods);<br>			emitConstructors(e, constructorInfo);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			emitDefaultConstructor(e);<br>		&#125;<br>		emitSetThreadCallbacks(e);<br>		emitSetStaticCallbacks(e);<br>		emitBindCallbacks(e);<br><br>		<span class="hljs-keyword">if</span> (useFactory || currentData != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-type">int</span>[] keys = getCallbackKeys();<br>			emitNewInstanceCallbacks(e);<br>			emitNewInstanceCallback(e);<br>			emitNewInstanceMultiarg(e, constructorInfo);<br>			emitGetCallback(e, keys);<br>			emitSetCallback(e, keys);<br>			emitGetCallbacks(e);<br>			emitSetCallbacks(e);<br>		&#125;<br><br>		e.end_class();<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>回到前面 <code>AbstractClassGenerator#create</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) &#123;<br>    <span class="hljs-keyword">return</span> firstInstance((Class) obj);<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<p>点进 <code>firstInstance()</code> 方法里，来到 <code>Enhancer#firstInstance</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">firstInstance</span><span class="hljs-params">(Class type)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-keyword">if</span> (classOnly) &#123;<br>			<span class="hljs-keyword">return</span> type;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> createUsingReflection(type);<br>		&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createUsingReflection</span><span class="hljs-params">(Class type)</span> &#123;<br>		setThreadCallbacks(type, callbacks);<br>		<span class="hljs-keyword">try</span> &#123;<br><br>			<span class="hljs-keyword">if</span> (argumentTypes != <span class="hljs-literal">null</span>) &#123;<br><br>				<span class="hljs-keyword">return</span> ReflectUtils.newInstance(type, argumentTypes, arguments);<br><br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br><br>				<span class="hljs-keyword">return</span> ReflectUtils.newInstance(type);<br><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-comment">// clear thread callbacks to allow them to be gc&#x27;d</span><br>			setThreadCallbacks(type, <span class="hljs-literal">null</span>);<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里使用了 <code>ReflectUtils</code> 反射工具类中的方法，完成了动态代理对象的生成</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>动态代理里讲到了反射，在Java中，动态代理主要通过Java反射机制实现，可以在程序运行时动态创建代理对象，无需手动编写代理类</p>
<p><strong>反射</strong>是Java语言中的一种机制，允许程序在运行时动态地获取、检查和操作类的信息以及对象的属性和方法。Java反射API位于<code>java.lang.reflect</code>包中，它提供了一组类和接口，用于实现反射功能。反射机制为开发者提供了在编译时无法确定的类结构信息，从而实现一些灵活、动态的操作</p>
<p>反射的基础知识包括以下几个关键概念：</p>
<ol>
<li><p><strong>Class类</strong>：<code>java.lang.Class</code> 是Java反射机制的核心类，它代表一个Java类的运行时信息。通过Class类，可以获取类的结构信息，如字段、方法、构造函数、父类、实现的接口等。</p>
</li>
<li><p><strong>获取Class对象</strong>：可以通过三种方式来获取一个类的Class对象：</p>
<ul>
<li>使用<code>Class.forName(String className)</code>：根据类的全限定名获取Class对象。需要处理<code>ClassNotFoundException</code>异常。</li>
<li>使用<code>.class</code>语法：例如，<code>String.class</code>获取String类的Class对象。</li>
<li>使用<code>Object.getClass()</code>方法：通过对象的<code>getClass()</code>方法获取对象所属类的Class对象。</li>
</ul>
</li>
<li><p><strong>获取类的信息</strong>：通过Class对象的方法，可以获取类的结构信息，例如：</p>
<ul>
<li><code>getFields()</code>：获取类的公共字段。</li>
<li><code>getMethods()</code>：获取类的公共方法。</li>
<li><code>getConstructors()</code>：获取类的公共构造函数。</li>
<li><code>getDeclaredFields()</code>：获取类的所有字段（包括私有字段）。</li>
<li><code>getDeclaredMethods()</code>：获取类的所有方法（包括私有方法）。</li>
</ul>
</li>
<li><p><strong>创建对象</strong>：通过Class对象的<code>newInstance()</code>方法，可以创建类的实例。</p>
</li>
<li><p><strong>访问字段和方法</strong>：通过反射可以动态地访问和修改类的字段值和调用类的方法。</p>
</li>
</ol>
<p>反射机制的优点在于它提供了动态性和灵活性，使得开发者能够在运行时动态地获取和操作类的信息，避免了在编译时固定的限制。然而，由于反射涉及到动态生成代码和动态检查类型，其性能可能较低，不宜频繁地使用，最好在需要时再使用</p>
<h5 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h5><p>反射（<em>Reflection</em>）和类加载（<em>Class Loading</em>）是Java中两个重要的概念，它们之间有一定的关系。反射是Java语言提供的一种机制，允许在<strong>运行时动态地获取、检查和操作类的信息</strong>，而<strong>类加载</strong>是<strong>Java虚拟机在将类字节码加载到内存并生成类对象的过程</strong></p>
<p><strong>类加载是反射的基础</strong>，反射的操作都是基于类加载完成的。在使用反射之前，需要先将类加载到内存中，然后通过类的Class对象来进行反射操作，java类的执行需要经历以下过程：</p>
<p><strong>编译</strong>：java文件编译后生成 <code>.class</code> 字节码文件 </p>
<p><strong>类加载</strong>：</p>
<p><img src="/posts/59835/16139181881678.png" srcset="/img/loading.gif" lazyload alt="Java 类加载机制- 类加载的时机和过程"></p>
<ul>
<li><p><strong>加载</strong>：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 <code>java.lang.Class</code> 对象实例 </p>
</li>
<li><p><strong>连接</strong>：</p>
<ul>
<li><p>验证：格式（class文件规范） 语义（final类是否有子类） 操作</p>
</li>
<li><p>准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。</p>
</li>
<li><p>解析：符号引用转化为直接引用，分配地址</p>
</li>
</ul>
</li>
<li><p><strong>初始化</strong>：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。</p>
</li>
</ul>
<p>Java的反射就是利用上面第二步加载到jvm中的 <code>.class</code> 文件来进行操作。具体来说，在Java虚拟机对类进行加载和连接的过程中，<strong>反射主要在解析阶段进行</strong>，其中<strong>解析的主要目标是将类、字段、方法的符号引用转换为直接引用，建立类之间的关联关系</strong></p>
<p>以下是一个使用反射调用方法的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Class对象</span><br>        Class&lt;?&gt; clazz = MyClass.class;<br><br>        <span class="hljs-comment">// 获取无参方法的Method对象并调用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">sayHelloMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);<br>        sayHelloMethod.invoke(clazz.newInstance());<br><br>        <span class="hljs-comment">// 获取有参方法的Method对象并调用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">addMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) addMethod.invoke(clazz.newInstance(), <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hello</span>, World!<br><span class="hljs-attribute">Result</span>: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，在使用反射调用方法时，要确保方法的名称、参数类型和调用的方法是一致的，否则会抛出 <code>NoSuchMethodException </code>或 <code>IllegalArgumentException</code> 异常</p>
<p>接下来主要解析一下获取 <code>Method</code> 对象和 <code>Method.invoke()</code> 方法</p>
<h5 id="获取-Method-对象"><a href="#获取-Method-对象" class="headerlink" title="获取 Method 对象"></a>获取 Method 对象</h5><p>在Java的反射机制中，可以通过<code>Class</code>对象获取<code>Method</code>对象，<code>Method</code>对象代表了类中的方法。通过<code>Method</code>对象可以在运行时动态地调用类的方法。Java反射中获取<code>Method</code>对象的方法主要有以下两个：</p>
<ol>
<li><p><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</p>
<ul>
<li>用于获取类的公共方法（包括从父类继承的公共方法）。</li>
<li>参数<code>name</code>是要获取的方法的名称。</li>
<li>参数<code>parameterTypes</code>是方法的参数类型数组，用于指定方法的参数类型。如果方法有参数，需要将参数类型以Class对象的形式传递进去。如果方法没有参数，可以不传递该参数。</li>
<li>返回值是一个Method对象，表示与指定名称和参数类型匹配的公共方法。如果未找到对应的方法，则抛出<code>NoSuchMethodException</code>异常。</li>
</ul>
</li>
<li><p><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</p>
<ul>
<li>用于获取类自身声明的方法（包括私有方法）。</li>
<li>参数<code>name</code>是要获取的方法的名称。</li>
<li>参数<code>parameterTypes</code>是方法的参数类型数组，用于指定方法的参数类型。如果方法有参数，需要将参数类型以Class对象的形式传递进去。如果方法没有参数，可以不传递该参数。</li>
<li>返回值是一个Method对象，表示与指定名称和参数类型匹配的类自身声明的方法。如果未找到对应的方法，则抛出<code>NoSuchMethodException</code>异常。</li>
</ul>
</li>
</ol>
<blockquote>
<p>上述两个方法都有获取复数个的方法，区别就是方法名后有 “<strong>s</strong>” 后缀</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>当获取私有方法时，使用<code>getDeclaredMethod()</code>方法；当获取公共方法时，使用<code>getMethod()</code>方法。</li>
<li>如果获取的方法是私有方法，需要通过<code>setAccessible(true)</code>方法将其设置为可访问，以允许访问私有方法。</li>
</ul>
</blockquote>
<p>其实不管是<code>getMethod</code>还是<code>getDeclaredMethod</code>，底层都调用了同一个方法：<code>privateGetDeclaredMethods</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">privateGetMethodRecursive</span><span class="hljs-params">(String name,</span><br><span class="hljs-params">            Class&lt;?&gt;[] parameterTypes,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> includeStaticMethods,</span><br><span class="hljs-params">            MethodArray allInterfaceCandidates)</span> &#123;<br><br>        <span class="hljs-comment">// Must _not_ return root methods</span><br>        Method res;<br>        <span class="hljs-comment">// Search declared public methods 搜索本来中声明的公共方法</span><br>        <span class="hljs-keyword">if</span> ((res = searchMethods(privateGetDeclaredMethods(<span class="hljs-literal">true</span>),<br>                                 name,<br>                                 parameterTypes)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))<br>                <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 如果res为空，继续向父类搜索</span><br>        <span class="hljs-comment">// Search superclass&#x27;s methods</span><br>        <span class="hljs-keyword">if</span> (!isInterface()) &#123;<br>            Class&lt;? <span class="hljs-built_in">super</span> T&gt; c = getSuperclass();<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 递归调用getMethod0，获取父类的方法实现</span><br>                <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">true</span>)) != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// res仍然为空，继续向接口搜索</span><br>        <span class="hljs-comment">// Search superinterfaces&#x27; methods</span><br>        Class&lt;?&gt;[] interfaces = getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : interfaces)<br>            <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">false</span>)) != <span class="hljs-literal">null</span>)<br>                allInterfaceCandidates.add(res);<br>        <span class="hljs-comment">// Not found</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>然后在看看 <code>searchMethods()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">searchMethods</span><span class="hljs-params">(Method[] methods,</span><br><span class="hljs-params">                                    String name,</span><br><span class="hljs-params">                                    Class&lt;?&gt;[] parameterTypes)</span><br>    &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">internedName</span> <span class="hljs-operator">=</span> name.intern();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> methods[i];<br>            <span class="hljs-keyword">if</span> (m.getName() == internedName<br>                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())<br>                &amp;&amp; (res == <span class="hljs-literal">null</span><br>                    || res.getReturnType().isAssignableFrom(m.getReturnType())))<br>                res = m;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (res == <span class="hljs-literal">null</span> ? res : getReflectionFactory().copyMethod(res));<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>其中循环了 Method[] methods 这个数组，而这个参数是由 privateGetDeclaredMethods(boolean <em>publicOnly</em>) 获得的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method[] privateGetDeclaredMethods(<span class="hljs-type">boolean</span> publicOnly) &#123;<br>    checkInitted();<br>    Method[] res;<br>    <span class="hljs-comment">// 1.ReflectionData 存储反射数据的缓存结构</span><br>    ReflectionData&lt;T&gt; rd = reflectionData();<br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 2.先从缓存中获取methods</span><br>        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// No cached value available; request value from VM</span><br>    <span class="hljs-comment">// 3.没有缓存，通过 JVM 获取，native方法</span><br>    res = Reflection.filterMethods(<span class="hljs-built_in">this</span>, getDeclaredMethods0(publicOnly));<br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>            rd.declaredPublicMethods = res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rd.declaredMethods = res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中的 <code>ReflectionData&lt;T&gt;</code>是类<code>Class</code>的静态内部类，<code>&lt;T&gt;</code>表示泛型，为具体的类对象。该缓存数据结构中存储了类的所有信息。<code>redefinedCount</code>是类的重定义次数，可以理解为缓存的版本号，每一个类对象理论上都会有（被垃圾回收或从来没被加载过就没没有）一个<code>ReflectionData&lt;T&gt;</code>的缓存，通过 <code>reflectionData()</code> 获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lazily create and cache ReflectionData</span><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">reflectionData</span><span class="hljs-params">()</span> &#123;<br>    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="hljs-built_in">this</span>.reflectionData;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">classRedefinedCount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.classRedefinedCount;<br>    ReflectionData&lt;T&gt; rd;<br>    <span class="hljs-keyword">if</span> (useCaches &amp;&amp;<br>        reflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>        (rd = reflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>        rd.redefinedCount == classRedefinedCount) &#123;<br>        <span class="hljs-keyword">return</span> rd;<br>    &#125;<br>    <span class="hljs-comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span><br>    <span class="hljs-comment">// -&gt; create and replace new instance</span><br>    <span class="hljs-keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);<br>&#125;<br><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">newReflectionData</span><span class="hljs-params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData, <span class="hljs-type">int</span> classRedefinedCount)</span> &#123;<br>    <span class="hljs-comment">// 不使用缓存则直接返回null</span><br>    <span class="hljs-keyword">if</span> (!useCaches) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 使用while+CAS方式更新数据，创建一个新的ReflectionData，如果更新成功直接返回</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ReflectionData&lt;T&gt; rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionData</span>&lt;&gt;(classRedefinedCount);<br>        <span class="hljs-comment">// try to CAS it...</span><br>        <span class="hljs-keyword">if</span> (Atomic.casReflectionData(<span class="hljs-built_in">this</span>, oldReflectionData, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(rd))) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>        <span class="hljs-comment">// else retry</span><br>        <span class="hljs-comment">// 获取到旧的reflectionData和classRedefinedCount的值，如果旧的值不为null, 并且缓存未失效，说明其他线程更新成功了，直接返回</span><br>        oldReflectionData = <span class="hljs-built_in">this</span>.reflectionData;<br>        classRedefinedCount = <span class="hljs-built_in">this</span>.classRedefinedCount;<br>        <span class="hljs-keyword">if</span> (oldReflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>            (rd = oldReflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Method-invoke"><a href="#Method-invoke" class="headerlink" title="Method.invoke()"></a>Method.invoke()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span><br>    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,<br>       InvocationTargetException<br>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-comment">// 1.检查权限，如果 override == true，就跳过检查</span><br>        <span class="hljs-comment">// 通常在 Method#invoke 之前，会调用 Method#setAccessible(true)，就是设置 override 值为 true</span><br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取 MethodAccessor</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">ma</span> <span class="hljs-operator">=</span> methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 2.1为空时创建MethodAccessor</span><br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-comment">// 3.调用 MethodAccessor.invoke</span><br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里会获取 <code>MethodAccessor</code> ，这个在之前 <code>searchMethods()</code> 最后会调用 <code>Method#copy</code> 会给 <code>Method</code> 的 <code>methodAccessor</code> 赋值，如果为空则去创建 <code>MethodAccessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MethodAccessor <span class="hljs-title function_">acquireMethodAccessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// First check to see if one has been created yet, and take it</span><br>    <span class="hljs-comment">// if so</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) tmp = root.getMethodAccessor();<br>    <span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">null</span>) &#123;<br>        methodAccessor = tmp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Otherwise fabricate one and propagate it up to the root</span><br>        tmp = reflectionFactory.newMethodAccessor(<span class="hljs-built_in">this</span>);<br>        setMethodAccessor(tmp);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-keyword">public</span> MethodAccessor <span class="hljs-title function_">newMethodAccessor</span><span class="hljs-params">(Method var1)</span> &#123;<br>    checkInitted();<br>    <span class="hljs-keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">NativeMethodAccessorImpl</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span>(var1);<br>        <span class="hljs-type">DelegatingMethodAccessorImpl</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingMethodAccessorImpl</span>(var2);<br>        var2.setParent(var3);<br>        <span class="hljs-keyword">return</span> var3;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里会先查找 <em>root</em> 的 <code>MethodAccessor</code>，这里的 <em>root</em> 在上面 <code>Method#copy</code> 中设置过。如果还是没有找到，就去创建 <code>MethodAccessor</code></p>
<p>在 <code>newMethodAccessor()</code> 方法里可以看到一共有三种 <code>MethodAccessor</code>：</p>
<ul>
<li><code>MethodAccessorImpl</code></li>
<li><code>NativeMethodAccessorImpl</code></li>
<li><code>DelegatingMethodAccessorImpl</code></li>
</ul>
<p>采用哪种 <code>MethodAccessor</code> 根据 <code>noInflation</code> 进行判断，<code>noInflation</code> 默认值为 <code>false</code>，只有指定了 <code>sun.reflect.noInflation</code> 属性为 <code>true</code>，才会采用 <code>MethodAccessorImpl</code> ，所以默认会调用 <code>NativeMethodAccessorImpl</code></p>
<p><code>MethodAccessorImpl</code> 是通过动态生成字节码来进行方法调用的，是 Java 版本的 <code>MethodAccessor</code></p>
<p><code>DelegatingMethodAccessorImpl</code> 就是单纯的代理，真正的实现还是 <code>NativeMethodAccessorImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> MethodAccessorImpl delegate;<br> <br>    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;<br>        setDelegate(delegate);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException<br>    &#123;<br>        <span class="hljs-keyword">return</span> delegate.invoke(obj, args);<br>    &#125;<br> <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDelegate</span><span class="hljs-params">(MethodAccessorImpl delegate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NativeMethodAccessorImpl</code> 是 <em>Native</em> 版本的 <code>MethodAccessor</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException<br>    &#123;<br>        <span class="hljs-comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span><br>        <span class="hljs-comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span><br>        <span class="hljs-comment">// found from the generated bytecode.</span><br>        <span class="hljs-keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()<br>                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// Java 版本的 MethodAccessor</span><br>            <span class="hljs-type">MethodAccessorImpl</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> (MethodAccessorImpl)<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>().<br>                    generateMethod(method.getDeclaringClass(),<br>                                   method.getName(),<br>                                   method.getParameterTypes(),<br>                                   method.getReturnType(),<br>                                   method.getExceptionTypes(),<br>                                   method.getModifiers());<br>            parent.setDelegate(acc);<br>        &#125;<br>        <span class="hljs-comment">// Native 版本调用</span><br>        <span class="hljs-keyword">return</span> invoke0(method, obj, args);<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">invoke0</span><span class="hljs-params">(Method m, Object obj, Object[] args)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>NativeMethodAccessorImpl</code> 的实现中，我们可以看到，有一个 <code>numInvocations</code> 阀值控制，<code>numInvocations</code> 表示调用次数。如果 <code>numInvocations</code> 大于 15（默认阀值是 15），那么就使用 Java 版本的 <code>MethodAccessorImpl</code>。 为什么采用这个策略呢，可以 JDK 中的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &quot;Inflation&quot; mechanism. Loading bytecodes to implement</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Method.invoke() and Constructor.newInstance() currently costs</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3-4x more than an invocation via native code for the first</span><br><span class="hljs-comment">// invocation (though subsequent invocations have been benchmarked</span><br><span class="hljs-comment">// to be over 20x faster). Unfortunately this cost increases</span><br><span class="hljs-comment">// startup time for certain applications that use reflection</span><br><span class="hljs-comment">// intensively (but only once per class) to bootstrap themselves.</span><br><span class="hljs-comment">// To avoid this penalty we reuse the existing JVM entry points</span><br><span class="hljs-comment">// for the first few invocations of Methods and Constructors and</span><br><span class="hljs-comment">// then switch to the bytecode-based implementations.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Package-private to be accessible to NativeMethodAccessorImpl</span><br><span class="hljs-comment">// and NativeConstructorAccessorImpl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">noInflation</span>        <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<p>比起通过本地代码进行的首次调用，方法和构造函数的首次调用要快3-4倍（虽然后续的调用已经经过基准测试，速度可以达到原来的20倍以上）。然而，这个过程会增加某些密集使用反射（但每个类仅一次）来引导自身的应用程序的启动时间。为了避免这种性能损耗，我们在方法和构造函数的前几次调用中重用现有的JVM入口点，然后切换到基于字节码的实现</p>
<p><code>Method.invoke()</code> 的最后，调用 <code>MethodAccessor#invoke</code> 实现方法的调用</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>说完了前置知识，终于可以开始正题了</p>
<p>在传统的面向对象编程中，系统的功能通常以对象的形式组织，但某些功能可能会散布在整个应用程序中，而不局限于单个对象或类。这些功能被称为横切关注点，如日志记录、安全性、事务处理等。AOP的目标就是通过把这些横切关注点从核心业务逻辑中分离出来，形成独立的模块，并通过特定的方式将其织入到应用程序中。通俗一点表达就是：<strong>AOP 要实现的是在我们原来写的代码的基础上，进行一定的包装，如在方法执行前、方法返回后、方法抛出异常后等地方进行一定的拦截处理或者叫增强处理</strong></p>
<p>作为 Java 开发者都很熟悉 <strong>AspectJ</strong> 这个词，甚至于在提到 AOP 的时候，想到的往往就是 AspectJ。这里简单的将 AspectJ 和 Spring AOP 做个对比：</p>
<h5 id="Spring-AOP："><a href="#Spring-AOP：" class="headerlink" title="Spring AOP："></a><strong>Spring AOP：</strong></h5><ul>
<li>它基于动态代理来实现。默认来说，如果使用接口，它会采用 JDK 提供的动态代理实现，如果没有接口，则会使用 CGLib 实现</li>
<li>Spring 3.2 以后，spring-core 直接就把 CGLIB 和 ASM 的源码包括进来了，所以平时开发时不需要显式引入这两个依赖</li>
<li>如果你是 web 开发者，有些时候可能需要的是一个 Filter 或一个 Interceptor，而不一定是 AOP</li>
<li>Spring AOP 只能作用于 Spring 容器中的 Bean，它是使用纯粹的 Java 代码实现的，只能作用于 bean 的方法</li>
<li>Spring 提供了 AspectJ 的支持，但一般来说只用 Spring AOP 就够</li>
<li>很多人会对比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好</li>
</ul>
<h5 id="AspectJ："><a href="#AspectJ：" class="headerlink" title="AspectJ："></a><strong>AspectJ：</strong></h5><ul>
<li><p>AspectJ 出身也是名门，来自于 Eclipse 基金会，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">https://www.eclipse.org/aspectj</a></p>
</li>
<li><p>属于静态织入，它是通过修改代码来实现的，它的织入时机可以是：</p>
<ul>
<li><em><strong>Compile-time weaving</strong></em>：编译期织入，如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</li>
<li><em><strong>Post-compile weaving</strong></em>：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</li>
<li><em><strong>Load-time weaving</strong></em>：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法。1、自定义类加载器来干这个，这个应该是最容易想到的办法，在被织入类加载到 JVM 前去对它进行加载，这样就可以在加载的时候定义行为了。2、在 JVM 启动的时候指定 AspectJ 提供的 agent：<code>-javaagent:xxx/xxx/aspectjweaver.jar</code>。</li>
</ul>
</li>
<li><p>AspectJ 能干很多 Spring AOP 干不了的事情，它是 <strong>AOP 编程的完全解决方案</strong>。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p>
</li>
<li><p>因为 AspectJ 在实际代码运行前完成了织入，所以大家会说它生成的类是没有额外运行时开销的</p>
</li>
</ul>
<h5 id="AOP的关键概念："><a href="#AOP的关键概念：" class="headerlink" title="AOP的关键概念："></a><strong>AOP的关键概念：</strong></h5><ol>
<li><p>切面（Aspect）：切面是横切关注点的抽象表示，它包含了与某个横切关注点相关的一组通用功能。比如，日志记录是一个切面，它可以包含日志输出的功能</p>
</li>
<li><p>连接点（Join Point）：连接点是应用程序中可能被切面影响的点。在Java中，连接点通常表示为方法的执行或异常的抛出</p>
</li>
<li><p>通知（Advice）：通知是切面在特定连接点上执行的具体动作。通知包括前置通知（Before）、后置通知（After）、返回通知（After Returning）、异常通知（After Throwing）和环绕通知（Around）等</p>
</li>
<li><p>切点（Pointcut）：切点是一组连接点的集合，它定义了切面在哪些连接点上起作用。切点使用表达式来匹配连接点，从而确定在哪些连接点上应用通知</p>
</li>
<li><p>引入（Introduction）：引入允许在不修改代码的情况下向现有类添加新的方法和属性</p>
</li>
<li><p>织入（Weaving）：织入是将切面应用到目标对象并创建新的代理对象的过程。织入可以在编译时、类加载时或运行时进行</p>
</li>
</ol>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>这里介绍的 Spring AOP 是纯的 Spring 代码，和 AspectJ 没什么关系，但是 Spring 延用了 AspectJ 中的概念，包括使用了 AspectJ 提供的 jar 包中的注解，但是不依赖于其实现功能</p>
<blockquote>
<p>后面介绍的如 @Aspect、@Pointcut、@Before、@After 等注解都是来自于 AspectJ，但是功能的实现是纯 Spring AOP 自己实现的</p>
</blockquote>
<p>在 Spring 的容器中，我们面向的对象是一个个的 bean 实例。我们可以简单理解 bean 是 BeanDefinition 的实例，Spring 会根据 BeanDefinition 中的信息为我们生产合适的 bean 实例出来</p>
<p>当我们需要使用 bean 的时候，通过 IOC 容器的 <code>getBean()</code> 方法从容器中获取 bean 实例，只不过大部分的场景下，我们都用了依赖注入，所以很少手动调用 <code>getBean()</code> 方法</p>
<p>Spring AOP 的原理很简单，就是<strong>动态代理</strong>，它和 AspectJ 不一样，AspectJ 是直接修改掉你的字节码</p>
<p>代理模式很简单，<strong>接口 + 真实实现类 + 代理类</strong>，其中 <strong>真实实现类</strong> 和 <strong>代理类</strong> 都要实现接口，实例化的时候要使用代理类。所以，<strong>Spring AOP 需要做的是生成这么一个代理类</strong>，然后<strong>替换掉</strong>真实实现类来对外提供服务</p>
<p><strong>替换</strong>这个操作在 Spring IOC 容器中非常容易实现，就是在 <code>getBean()</code> 的时候返回的实际上是代理类的实例，而这个代理类我们自己没写代码，<strong>它是 Spring 采用 JDK Proxy 或 CGLIB 动态生成的</strong></p>
<h4 id="Spring-2-0-AspectJ-配置"><a href="#Spring-2-0-AspectJ-配置" class="headerlink" title="Spring 2.0 @AspectJ 配置"></a>Spring 2.0 @AspectJ 配置</h4><p>在 Spring 2.0 之后引入了 <code>@AspectJ</code> 和 <code>Schema-based</code> 的两种配置方式，这里<strong>仅介绍</strong> <code>AspectJ</code> 注解的方式。首先，我们需要依赖 <code>aspectjweaver.jar</code> 这个包，这个包来自于 <code>AspectJ</code>：</p>
<blockquote>
<p>并不是说基于 AspectJ 实现的，而仅仅是使用了 AspectJ 中的概念，包括使用的注解也是直接来自于 AspectJ 的包</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果是使用 Spring Boot 的话，添加以下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>首先，我们需要<strong>开启</strong> <code>@AspectJ</code> 的注解配置方式：</p>
<ul>
<li>使用 <code>@EnableAspectJAutoProxy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>一旦开启了上面的配置，那么所有使用 @Aspect 注解的 <strong>bean</strong> 都会被 Spring 当做<strong>用来实现 AOP 的配置类</strong>，我们称之为一个 <strong>Aspect</strong></p>
<blockquote>
<p>注意，<code>@Aspect</code> 注解要作用在 bean 上面，不管是使用 <code>@Component</code> 等注解方式，还是在 xml 中配置 bean，首先它需要是一个 bean</p>
<p><strong>有些时候并不需要</strong>加这个注解就能使AOP生效，原因是依赖中直接或者间接的引入了 <code>spring-boot-autoconfigure</code>，这是自动装配的依赖，也就是会读取其下的 <code>spring.factories</code> 文件，在该文件中有下面的配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><br><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.aop.**AopAutoConfiguration**</span><br></code></pre></td></tr></table></figure>

<p>则会加载 <code>AopAutoConfiguration</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Auto-configuration for Spring&#x27;s AOP support. Equivalent to enabling @EnableAspectJAutoProxy in your configuration.</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopAutoConfiguration</span> &#123;<br>​    ....<span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>默认等同于 <code>@EnableAspectJAutoProxy</code></p>
</blockquote>
<ol>
<li>创建一个接口和实现类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(String username)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-comment">// 模拟添加用户的操作</span><br>        System.out.println(<span class="hljs-string">&quot;User added: &quot;</span> + username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个切面类，用于添加横切逻辑，并定义<strong>Pointcut</strong>表达式：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-comment">// 定义Pointcut表达式，选择com.example.UserService接口的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.UserService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userServiceMethods</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到，<code>@Pointcut</code> 中使用了 <strong>execution</strong> 来正则匹配方法签名，这也是最常用的，除了 execution，我们再看看其他的几个比较常用的匹配方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任意公共方法的执行：</span><br>execution（<span class="hljs-keyword">public</span> * *（..））<br><br><span class="hljs-comment">// 任何一个名字以“set”开始的方法的执行：</span><br>execution（* set*（..））<br><br><span class="hljs-comment">// AccountService接口定义的任意方法的执行：</span><br>execution（* com.xyz.service.AccountService.*（..））<br><br><span class="hljs-comment">// 在service包中定义的任意方法的执行：</span><br>execution（* com.xyz.service.*.*（..））<br><br><span class="hljs-comment">// 在service包或其子包中定义的任意方法的执行：</span><br>execution（* com.xyz.service..*.*（..））<br><br><span class="hljs-comment">// 在service包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service.*）<br><br><span class="hljs-comment">// 在service包或其子包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service..*）<br><br><span class="hljs-comment">// 实现了AccountService接口的代理对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-built_in">this</span>（com.xyz.service.AccountService）<span class="hljs-comment">// &#x27;this&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 实现AccountService接口的目标对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br>target（com.xyz.service.AccountService） <span class="hljs-comment">// &#x27;target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点（在Spring AOP中只是方法执行）</span><br>args（java.io.Serializable） <span class="hljs-comment">// &#x27;args&#x27;在绑定表单中更加常用; 请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args版本只有在动态运行时候传入参数是Serializable时才匹配，而execution版本在方法签名中声明只有一个 Serializable类型的参数时候匹配。</span><br><br><span class="hljs-comment">// 目标对象中有一个 @Transactional 注解的任意连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@target</span>（org.springframework.transaction.annotation.Transactional）<span class="hljs-comment">// &#x27;@target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-meta">@within</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@within&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个执行的方法有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@annotation</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@annotation&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点（在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@args</span>（com.xyz.security.Classified） <span class="hljs-comment">// &#x27;@args&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个在名为&#x27;tradeService&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（tradeService）<br><br><span class="hljs-comment">// 任何一个在名字匹配通配符表达式&#x27;*Service&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（*Service）<br></code></pre></td></tr></table></figure>

<p>此外Spring 支持如下三个逻辑运算符来组合切入点表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;：要求连接点同时匹配两个切入点表达式<br>||：要求连接点匹配任意个切入点表达式<br>!:：要求连接点不匹配指定的切入点表达式<br></code></pre></td></tr></table></figure>

<p>Spring AOP 用户可能会经常使用 execution 切入点指示符。执行表达式的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern） <span class="hljs-keyword">throws</span>-pattern?）<br></code></pre></td></tr></table></figure>

<ul>
<li>ret-type-pattern 返回类型模式, name-pattern名字模式和param-pattern参数模式是必选的， 其它部分都是可选的。返回类型模式决定了方法的返回类型必须依次匹配一个连接点。 你会使用的最频繁的返回类型模式是<code>*</code>，<strong>它代表了匹配任意的返回类型</strong>。</li>
<li>declaring-type-pattern, 一个全限定的类型名将只会匹配返回给定类型的方法。</li>
<li>name-pattern 名字模式匹配的是方法名。 你可以使用<code>*</code>通配符作为所有或者部分命名模式。</li>
<li>param-pattern 参数模式稍微有点复杂：()匹配了一个不接受任何参数的方法， 而(..)匹配了一个接受任意数量参数的方法（零或者更多）。 模式(<em>)匹配了一个接受一个任何类型的参数的方法。 模式(</em>,String)匹配了一个接受两个参数的方法，第一个可以是任意类型， 第二个则必须是String类型</li>
</ul>
<p>上面匹配中，通常 “.” 代表一个包名，”..” 代表包及其子包，方法参数任意匹配使用两个点 “..”</p>
<ol start="3">
<li><strong>配置 Advice</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdviceExample</span> &#123;<br><br>    <span class="hljs-comment">// 使用定义的Pointcut，在所有方法执行后添加额外逻辑</span><br>    <span class="hljs-meta">@After(&quot;com.javadoop.aop.LoggingAspect.userServiceMethods()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterExecution</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method execution completed.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>创建一个简单的Main类来测试：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br><br>        userService.addUser(<span class="hljs-string">&quot;John Doe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在运行Main类时，你将看到类似以下输出：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">User added: John Doe<br><span class="hljs-keyword">Method</span> <span class="hljs-title function_">execution</span> <span class="hljs-title function_">completed</span>.<br></code></pre></td></tr></table></figure>

<p>这表明 <code>addUser</code> 方法执行后，切面中定义的 <code>logAfterExecution</code> 方法被调用。使用 <code>Pointcut</code>，你可以更细粒度地控制切入点，而不是直接在特定方法上定义切面逻辑</p>
<p>如果 <code>Advice</code> 方法需要获取入参，Spring 提供了非常简单的获取入参的方法，使用 <code>org.aspectj.lang.JoinPoint</code> 作为 <code>Advice</code> 的第一个参数即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.javadoop.aop.LoggingAspect.userServiceMethods()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logArgs</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法执行前，打印入参：&quot;</span> + Arrays.toString(joinPoint.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意 <code>org.aspectj.lang.JoinPoint</code> 的使用方法：</p>
<ul>
<li>必须放置在第一个参数上</li>
<li>如果是 @Around，我们通常会使用其子类 <code>ProceedingJoinPoint</code>，因为它有 <code>procceed()</code>&#x2F; <code>procceed(args[])</code> 方法。</li>
</ul>
</blockquote>
<h4 id="AOP的原理"><a href="#AOP的原理" class="headerlink" title="AOP的原理"></a>AOP的原理</h4><p>所以理解Spring AOP的初始化必须要先理解Spring IOC的初始化</p>
<h5 id="基于注解的切面代理创建"><a href="#基于注解的切面代理创建" class="headerlink" title="基于注解的切面代理创建"></a>基于注解的切面代理创建</h5><p>这里直接从之前说到的 <code>@EnableAspectJAutoProxy</code> 切入，它 @import 了 <code>AspectJAutoProxyRegistrar.class</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="hljs-comment">	 * of the @&#123;<span class="hljs-doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span><br><span class="hljs-comment">	 * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(</span><br><span class="hljs-params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br><br>    <span class="hljs-comment">// 注册 AspectJAnnotationAutoProxyCreator，如果需要的话</span><br>		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br>    ... <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry)</code> 这个方法点进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>	<span class="hljs-keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(</span><br><span class="hljs-params">		BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br>   <span class="hljs-comment">// 注册 AnnotationAwareAspectJAutoProxyCreator.class</span><br>	<span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerOrEscalateApcAsRequired</span><span class="hljs-params">(</span><br><span class="hljs-params">		Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br>	Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br><br>   <span class="hljs-comment">// 如果名为 org.springframework.aop.config.internalAutoProxyCreator 的 bean 已经在册</span><br>	<span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>		<span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">apcDefinition</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>     <span class="hljs-comment">// 已经在册的 ProxyCreator 与当前期望的类型不一致，则依据优先级进行选择</span><br>		<span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">currentPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(apcDefinition.getBeanClassName());<br>			<span class="hljs-type">int</span> <span class="hljs-variable">requiredPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(cls);<br>       <span class="hljs-comment">// 选择优先级高的 ProxyCreator 更新注册</span><br>			<span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) &#123;<br>				apcDefinition.setBeanClassName(cls.getName());<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br><br>   <span class="hljs-comment">// 没有对应在册的 ProxyCreator，注册一个新的</span><br>	<span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(cls);<br>	beanDefinition.setSource(source);<br>	beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);<br>	beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>	registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>	<span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结下来就是注册了一个名为 <code>org.springframework.aop.config.internalAutoProxyCreator</code> 的 <code>BeanDefinition</code>，我们称之为代理创建器（<em>ProxyCreator</em>）。这里使用的默认实现为 <code>AnnotationAwareAspectJAutoProxyCreator.class</code> 类，如果存在多个候选实现，则选择优先级最高的进行注册</p>
<p>然后是 <code>AspectJAutoProxyRegistrar#registerBeanDefinitions</code> 后面省略的部分是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>			&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里配置的 <code>proxy-target-class</code> 和 <code>expose-proxy</code> 属性添加到对应 BeanDefinition 的属性列表中</p>
<p>这是 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的继承关系图：</p>
<p><img src="/posts/59835/image-20230721185238617.png" srcset="/img/loading.gif" lazyload alt="image-20230721185238617"></p>
<p>看得出它实现了两类接口：<code>BeanPostProcessor</code> 和 <code>Aware</code></p>
<p><code>BeanPostProcessor</code> 接口我们知道在容器启动过程中会在初始化 bean 实例的前后分别调用 <code>BeanPostProcessor</code> 中定义的 <code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 两个方法。针对这两个方法的实现主要位于继承链的 <code>AbstractAutoProxyCreator</code> 类中，并且<strong>主要是</strong>实现了 <code>BeanPostProcessor#postProcessAfterInitialization</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a proxy with the configured interceptors if the bean is</span><br><span class="hljs-comment"> * identified as one to proxy by the subclass.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getAdvicesAndAdvisorsForBean</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> &#123;<br>	<span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-comment">// 如果 beanName 不为空则直接使用 beanName（FactoryBean 则使用 &amp;&#123;beanName&#125;），否则使用 bean 的 className</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>       <span class="hljs-comment">// 尝试对 bean 进行增强，创建返回增强后的代理对象</span><br>			<span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法的核心在于调用 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法，尝试基于 AOP 配置对当前 bean 进行增强，并返回增强后的代理对象。方法 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> &#123;<br>	<span class="hljs-comment">// 已经处理过，直接返回</span><br>   <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br>   <span class="hljs-comment">// 不需要进行增强的 bean 实例，直接跳过</span><br>	<span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-built_in">this</span>.advisedBeans.get(cacheKey))) &#123;<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br>   <span class="hljs-comment">// 对于 AOP 的基础支撑类，或者指定不需要被代理的类，设置为不进行代理</span><br>	<span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br>		<span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br><br>	<span class="hljs-comment">// Create proxy if we have advice.</span><br>   <span class="hljs-comment">// 获取适用于当前 bean 的 Advisor</span><br>	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-literal">null</span>);<br>   <span class="hljs-comment">// 基于获取到的 Advisor 为当前 bean 创建代理对象</span><br>	<span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>		<span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>     <span class="hljs-comment">// 创建代理对象</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(<br>				bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(bean));<br>		<span class="hljs-built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>		<span class="hljs-keyword">return</span> proxy;<br>	&#125;<br><br>	<span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>	<span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述方法主要的工作是对 bean 实例进行筛选，过滤掉那些已经增强过的、支持 AOP 基础运行的，以及指定不需要被代理的 bean 实例。对于剩下的 bean 实例来说，首先会调用 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法获取适用于当前 bean 的增强器（<em>Advisor</em>），并基于这些增强器调用 <code>AbstractAutoProxyCreator#createProxy</code> 方法为当前 bean 创建增强后的代理对象</p>
<h5 id="筛选适用于-bean-的增强器"><a href="#筛选适用于-bean-的增强器" class="headerlink" title="筛选适用于 bean 的增强器"></a>筛选适用于 bean 的增强器</h5><p>首先来看一下筛选适用于当前 bean 的合格增强器的过程，实现位于 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>        Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;<br>    <span class="hljs-comment">// 获取适用于当前 bean 的 Advisor</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">this</span>.findEligibleAdvisors(beanClass, beanName);<br>    <span class="hljs-comment">// 没有合格的 Advisor，不进行代理</span><br>    <span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> DO_NOT_PROXY; <span class="hljs-comment">// null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors.toArray();<br>&#125;<br><br><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    <span class="hljs-comment">// 获取所有候选的 Advisor（包括注解的、XML 中配置的）</span><br>    List&lt;Advisor&gt; candidateAdvisors = <span class="hljs-built_in">this</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// 从所有 Advisor 中寻找适用于当前 bean 的 Advisor</span><br>    List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-built_in">this</span>.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>    <span class="hljs-comment">// 如果 Advisor 不为空，则在最前面追加一个 ExposeInvocationInterceptor</span><br>    <span class="hljs-built_in">this</span>.extendAdvisors(eligibleAdvisors);<br>    <span class="hljs-comment">// 对 Advisor 进行排序</span><br>    <span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;<br>        eligibleAdvisors = <span class="hljs-built_in">this</span>.sortAdvisors(eligibleAdvisors);<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整个方法的执行流程很简单，获取所有的候选增强器，并从中找出适用于当前 bean 的增强器。首先来看获取所有候选增强器的过程，实现位于 <code>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findCandidateAdvisors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用父类的 findCandidateAdvisors 方法，兼容父类查找 Advisor 的规则</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// 获取所有注解定义的 Advisor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder != <span class="hljs-literal">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法首先调用了父类的实现，这主要是为了兼容父类查找候选增强器的规则，例如我们的示例中使用的是注解方式定义的增强，但是父类却是基于 XML 配置的方式查找增强器，这里的兼容能够让我们在以注解方式编程时兼容其它以 XML 配置的方式定义的增强。下面还是将主要精力放在解析注解式增强定义上，该过程位于 <code>BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</code> 方法中。不过该方法实现比较冗长，但是逻辑却很清晰，所以这里主要概括一下其执行流程：</p>
<ol>
<li>获取所有类型 bean 实例对应的 beanName 集合；</li>
<li>过滤不是切面类型的 bean 对应的 beanName，即没有被 <code>@Aspect</code> 注解，或包含以 <code>ajc$</code> 开头的字段，同时支持覆盖 <code>BeanFactoryAspectJAdvisorsBuilder#isEligibleBean</code> 方法扩展过滤规则；</li>
<li>对于切面 bean 类型，获取 bean 中定义的所有切点，并为每个切点生成对应的增强器；</li>
<li>缓存解析得到的增强器，避免重复解析。</li>
</ol>
<p>上述流程中我们重点看一下过程 3，实现位于 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title function_">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> &#123;<br>    <span class="hljs-comment">// 获取切面 aspect 对应的 class 和 beanName</span><br>    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">aspectName</span> <span class="hljs-operator">=</span> aspectInstanceFactory.getAspectMetadata().getAspectName();<br>    <span class="hljs-comment">// 校验切面定义的合法性</span><br>    <span class="hljs-built_in">this</span>.validate(aspectClass);<br><br>    <span class="hljs-comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br>    <span class="hljs-comment">// so that it will only instantiate once.</span><br>    <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">lazySingletonAspectInstanceFactory</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingletonAspectInstanceFactoryDecorator</span>(aspectInstanceFactory);<br><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 1. 遍历处理切面中除被 @Pointcut 注解以外的方法</span><br>    <span class="hljs-keyword">for</span> (Method method : <span class="hljs-built_in">this</span>.getAdvisorMethods(aspectClass)) &#123;<br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 如果增强器不为空，同时又配置了增强延迟初始化，则需要追加实例化增强器 SyntheticInstantiationAdvisor</span><br>    <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;<br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">instantiationAdvisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticInstantiationAdvisor</span>(lazySingletonAspectInstanceFactory);<br>        advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 获取所有引介增强定义</span><br>    <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>        <span class="hljs-comment">// 创建引介增强器 DeclareParentsAdvisor</span><br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getDeclareParentsAdvisor(field);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述实现的整体执行流程如代码注释。拿到一个切面定义，Spring 首先会遍历获取切面中的增强方法，即被 <code>@Around</code>、<code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>，以及 <code>@AfterThrowing</code> 注解的方法，并调用 <code>ReflectiveAspectJAdvisorFactory#getAdvisor</code> 方法为每一个增强方法生成对应的增强器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod,</span><br><span class="hljs-params">                          MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> declarationOrderInAspect,</span><br><span class="hljs-params">                          String aspectName)</span> &#123;<br><br>    <span class="hljs-comment">// 校验切面类定义的合法性</span><br>    <span class="hljs-built_in">this</span>.validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br><br>    <span class="hljs-comment">// 获取注解配置的切点信息，封装成 AspectJExpressionPointcut 对象</span><br>    <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">expressionPointcut</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPointcut(<br>            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>    <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 依据切点信息生成对应的增强器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(<br>            expressionPointcut, candidateAdviceMethod, <span class="hljs-built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述实现首先对当前切面定义执行合法性校验，如果切面配置合法则获取目标方法上的切点注解定义，并封装成 AspectJExpressionPointcut 对象。该过程位于 <code>ReflectiveAspectJAdvisorFactory#getPointcut</code> 方法中，实现比较简单。</p>
<p>拿到切点注解定义之后，方法会依据切点的配置信息使用 InstantiationModelAwarePointcutAdvisorImpl 实现类创建对应的增强器。类 InstantiationModelAwarePointcutAdvisorImpl 的实例化过程除了初始化了一些基本属性之外，主要是调用了 <code>InstantiationModelAwarePointcutAdvisorImpl#instantiateAdvice</code> 方法，依据增强类型对增强器实施相应的初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Advice <span class="hljs-title function_">instantiateAdvice</span><span class="hljs-params">(AspectJExpressionPointcut pointcut)</span> &#123;<br>    <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aspectJAdvisorFactory.getAdvice(<br>            <span class="hljs-built_in">this</span>.aspectJAdviceMethod, pointcut, <span class="hljs-built_in">this</span>.aspectInstanceFactory, <span class="hljs-built_in">this</span>.declarationOrder, <span class="hljs-built_in">this</span>.aspectName);<br>    <span class="hljs-keyword">return</span> (advice != <span class="hljs-literal">null</span> ? advice : EMPTY_ADVICE);<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvice</span><br><span class="hljs-keyword">public</span> Advice <span class="hljs-title function_">getAdvice</span><span class="hljs-params">(Method candidateAdviceMethod,</span><br><span class="hljs-params">                        AspectJExpressionPointcut expressionPointcut,</span><br><span class="hljs-params">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> declarationOrder,</span><br><span class="hljs-params">                        String aspectName)</span> &#123;<br><br>    <span class="hljs-comment">// 获取切面 class 对象，并校验切面定义</span><br>    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    <span class="hljs-built_in">this</span>.validate(candidateAspectClass);<br><br>    <span class="hljs-comment">// 获取方法的切点注解定义</span><br>    AspectJAnnotation&lt;?&gt; aspectJAnnotation =<br>            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// If we get here, we know we have an AspectJ method.</span><br>    <span class="hljs-comment">// Check that it&#x27;s an AspectJ-annotated class</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isAspect(candidateAspectClass)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Advice must be declared inside an aspect type: &quot;</span> +<br>                <span class="hljs-string">&quot;Offending method &#x27;&quot;</span> + candidateAdviceMethod + <span class="hljs-string">&quot;&#x27; in class [&quot;</span> + candidateAspectClass.getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br><br>    AbstractAspectJAdvice springAdvice;<br><br>    <span class="hljs-comment">// 依据切点注解类型使用对应的增强类进行封装</span><br>    <span class="hljs-keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;<br>        <span class="hljs-comment">// @Pointcut</span><br>        <span class="hljs-keyword">case</span> AtPointcut:<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Processing pointcut &#x27;&quot;</span> + candidateAdviceMethod.getName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// @Around</span><br>        <span class="hljs-keyword">case</span> AtAround:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAroundAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @Before</span><br>        <span class="hljs-keyword">case</span> AtBefore:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJMethodBeforeAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @After</span><br>        <span class="hljs-keyword">case</span> AtAfter:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @AfterReturning</span><br>        <span class="hljs-keyword">case</span> AtAfterReturning:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterReturningAdvice</span>(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-type">AfterReturning</span> <span class="hljs-variable">afterReturningAnnotation</span> <span class="hljs-operator">=</span> (AfterReturning) aspectJAnnotation.getAnnotation();<br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;<br>                springAdvice.setReturningName(afterReturningAnnotation.returning());<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// @AfterThrowing</span><br>        <span class="hljs-keyword">case</span> AtAfterThrowing:<br>            springAdvice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterThrowingAdvice</span>(<br>                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>            <span class="hljs-type">AfterThrowing</span> <span class="hljs-variable">afterThrowingAnnotation</span> <span class="hljs-operator">=</span> (AfterThrowing) aspectJAnnotation.getAnnotation();<br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;<br>                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Unsupported advice type on method: &quot;</span> + candidateAdviceMethod);<br>    &#125;<br><br>    <span class="hljs-comment">// Now to configure the advice...</span><br>    springAdvice.setAspectName(aspectName);<br>    springAdvice.setDeclarationOrder(declarationOrder);<br>    String[] argNames = <span class="hljs-built_in">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (argNames != <span class="hljs-literal">null</span>) &#123;<br>        springAdvice.setArgumentNamesFromStringArray(argNames);<br>    &#125;<br>    springAdvice.calculateArgumentBindings();<br><br>    <span class="hljs-keyword">return</span> springAdvice;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法的整体执行流程如代码注释，逻辑比较清晰，Spring 会依据具体的增强注解类型，选择相应的增强类对切点定义进行封装。这里我们以 <code>@Before</code> 为例说明一下增强的执行流程，AspectJMethodBeforeAdvice 增强类关联注册的处理器是 MethodBeforeAdviceInterceptor，当我们调用一个被前置增强的目标方法时，<code>MethodBeforeAdviceInterceptor#invoke</code> 方法会被触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 执行增强方法</span><br>    <span class="hljs-built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());<br>    <span class="hljs-comment">// 执行目标方法</span><br>    <span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里执行的增强方法就对应着 <code>AspectJMethodBeforeAdvice#before</code> 方法，该方法会依据切点配置将相应的参数绑定传递给我们自定义的增强方法，并最终通过反射调用触发执行。</p>
<p>上面分析了普通方法级别增强的处理过程，对于另外一类增强（引介增强），方法 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 则使用专门的 DeclareParentsAdvisor 类创建对应的增强器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3. 获取所有引介增强定义</span><br><span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>    <span class="hljs-comment">// 创建引介增强器</span><br>    <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getDeclareParentsAdvisor(field);<br>    <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>        advisors.add(advisor);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Advisor <span class="hljs-title function_">getDeclareParentsAdvisor</span><span class="hljs-params">(Field introductionField)</span> &#123;<br>    <span class="hljs-comment">// 获取 @DeclareParents 注解定义</span><br>    <span class="hljs-type">DeclareParents</span> <span class="hljs-variable">declareParents</span> <span class="hljs-operator">=</span> introductionField.getAnnotation(DeclareParents.class);<br>    <span class="hljs-keyword">if</span> (declareParents == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有指定默认的接口实现类</span><br>    <span class="hljs-keyword">if</span> (DeclareParents.class == declareParents.defaultImpl()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;&#x27;defaultImpl&#x27; attribute must be set on DeclareParents&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 DeclareParentsAdvisor 类型创建对应的引介增强器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeclareParentsAdvisor</span>(<br>            introductionField.getType(), declareParents.value(), declareParents.defaultImpl());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于引介增强来说，Spring 会注入 DelegatePerTargetObjectIntroductionInterceptor 处理器对其进行专门的处理，思想上与前面分析前置增强大同小异，这里不再展开。</p>
<p>继续回到 <code>AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</code> 方法，上面的过程我们分析了获取所有类型增强器的过程，但是这些增强器不一定都适用于当前 bean 实例，我们需要依据切点配置信息对其进行筛选。这一过程位于 <code>AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorsThatCanApply</span><span class="hljs-params">(</span><br><span class="hljs-params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    ProxyCreationContext.setCurrentProxiedBeanName(beanName);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ProxyCreationContext.setCurrentProxiedBeanName(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorsThatCanApply</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-comment">// 没有候选的增强器，直接返回</span><br>    <span class="hljs-keyword">if</span> (candidateAdvisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> candidateAdvisors;<br>    &#125;<br>    List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 1. 筛选引介增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 表示是否含有引介增强</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasIntroductions</span> <span class="hljs-operator">=</span> !eligibleAdvisors.isEmpty();<br><br>    <span class="hljs-comment">// 2. 筛选其它类型的增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-comment">// 引介增强已经处理过，这里直接跳过</span><br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>            <span class="hljs-comment">// already processed</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 筛选其它类型的增强器</span><br>        <span class="hljs-keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法首先会使用类过滤器（ClassFilter）筛选引介增强器，除了我们手动注册的类过滤器外，这里默认还会使用 TypePatternClassFilter 类过滤器执行过滤操作。然后，方法会过滤筛选其它类型的增强器，这里除了使用类过滤器外，考虑方法级别增强的定义形式，还会使用方法匹配器（MethodMatcher）进行筛选。如果增强器适用于当前 bean 类型，则将其加入到集合中用于下一步为当前 bean 创建增强代理对象。如果没有任何一个增强器适用于当前 bean 类型，则方法 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 最终会返回值为 null 的 <code>DO_NOT_PROXY</code> 数组对象，表示当前 bean 不需要被增强。</p>
<h5 id="为-bean-创建增强代理对象"><a href="#为-bean-创建增强代理对象" class="headerlink" title="为 bean 创建增强代理对象"></a>为 bean 创建增强代理对象</h5><p>完成了对于当前 bean 增强器的筛选，接下来我们继续回到 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法，看一下基于前面筛选出的增强器为当前 bean 创建增强代理对象的过程，实现位于 <code>AbstractAutoProxyCreator#createProxy</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass,</span><br><span class="hljs-params">                             <span class="hljs-meta">@Nullable</span> String beanName,</span><br><span class="hljs-params">                             <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors,</span><br><span class="hljs-params">                             TargetSource targetSource)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-built_in">this</span>.beanFactory, beanName, beanClass);<br>    &#125;<br><br>    <span class="hljs-comment">// ProxyFactory 用于为目标 bean 实例创建代理对象</span><br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>    proxyFactory.copyFrom(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// proxy-target-class = false，表示使用 JDK 原生动态代理</span><br>    <span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>        <span class="hljs-comment">// 检测当前 bean 是否应该基于类而非接口生成代理对象，即包含 preserveTargetClass=true 属性</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.shouldProxyTargetClass(beanClass, beanName)) &#123;<br>            proxyFactory.setProxyTargetClass(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果是基于接口生成代理，则添加需要代理的接口到 ProxyFactory 中（除内置 callback 接口、语言内在接口，以及标记接口）</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.evaluateProxyInterfaces(beanClass, proxyFactory);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将拦截器封装成 Advisor 对象</span><br>    Advisor[] advisors = <span class="hljs-built_in">this</span>.buildAdvisors(beanName, specificInterceptors);<br>    proxyFactory.addAdvisors(advisors);<br>    proxyFactory.setTargetSource(targetSource);<br>    <span class="hljs-comment">// 模板方法，定制代理工厂</span><br>    <span class="hljs-built_in">this</span>.customizeProxyFactory(proxyFactory);<br><br>    <span class="hljs-comment">// 设置代理工厂被配置之后是否还允许修改，默认为 false，表示不允许修改</span><br>    proxyFactory.setFrozen(<span class="hljs-built_in">this</span>.freezeProxy);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisorsPreFiltered()) &#123;<br>        proxyFactory.setPreFiltered(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 基于 ProxyFactory 创建代理类</span><br>    <span class="hljs-keyword">return</span> proxyFactory.getProxy(<span class="hljs-built_in">this</span>.getProxyClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法的执行流程如代码注释。下面我们主要分析将拦截器封装成 Advisor 对象的过程，以及基于 ProxyFactory 创建增强代理对象的过程。</p>
<p>Spring 定义了非常多的拦截器、增强器，以及增强方法等，这里通过 <code>AbstractAutoProxyCreator#buildAdvisors</code> 方法统一将他们封装成 Advisor 对象，从而简化代理的创建过程。封装的核心步骤由 <code>DefaultAdvisorAdapterRegistry#wrap</code> 方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException &#123;<br>    <span class="hljs-comment">// 已经是 Advisor，则无需多做处理</span><br>    <span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) &#123;<br>        <span class="hljs-keyword">return</span> (Advisor) adviceObject;<br>    &#125;<br>    <span class="hljs-comment">// 要求必须是 Advice 类型</span><br>    <span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAdviceTypeException</span>(adviceObject);<br>    &#125;<br>    <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> (Advice) adviceObject;<br>    <span class="hljs-comment">// 如果是 MethodInterceptor，则直接使用 DefaultPointcutAdvisor 进行包装</span><br>    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br>        <span class="hljs-comment">// So well-known it doesn&#x27;t even need an adapter.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(advice);<br>    &#125;<br>    <span class="hljs-comment">// 否则遍历注册的适配器，如果存在关联的适配器则使用 DefaultPointcutAdvisor 进行包装</span><br>    <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-built_in">this</span>.adapters) &#123;<br>        <span class="hljs-comment">// Check that it is supported.</span><br>        <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(advice);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAdviceTypeException</span>(advice);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们重点分析一下通过代理工厂 ProxyFactory 创建增强代理对象的过程，实现位于 <code>ProxyFactory#getProxy</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.createAopProxy() <span class="hljs-comment">// 1. 创建 AOP 代理</span><br>            .getProxy(classLoader); <span class="hljs-comment">// 2. 基于 AOP 代理创建目标类的增强代理对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法的执行过程可以拆分成两个步骤：</p>
<ol>
<li>创建 AOP 代理，Spring 默认提供了两种 AOP 代理实现，即 java 原生代理和 CGLib 代理；</li>
<li>基于 AOP 代理创建目标类的增强代理对象。</li>
</ol>
<p>我们首先来看一下步骤 1 的实现，位于 <code>ProxyCreatorSupport#createAopProxy</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.active) &#123;<br>        <span class="hljs-built_in">this</span>.activate();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAopProxyFactory().createAopProxy(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</span><br><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    <span class="hljs-keyword">if</span> (config.isOptimize() <span class="hljs-comment">// 需要对代理策略进行优化</span><br>            || config.isProxyTargetClass() <span class="hljs-comment">// // 指定使用 CGLib 生成代理对象</span><br>            || <span class="hljs-built_in">this</span>.hasNoUserSuppliedProxyInterfaces(config)) <span class="hljs-comment">// 当前类没有接口定义，不得不使用 CGLib</span><br>    &#123;<br>        Class&lt;?&gt; targetClass = config.getTargetClass();<br>        <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                    <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 目标类是接口或代理类，使用 JDK 原生代理</span><br>        <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>        &#125;<br>        <span class="hljs-comment">// 使用 CGLib 动态代理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjenesisCglibAopProxy</span>(config);<br>    &#125;<br>    <span class="hljs-comment">// 使用 JDK 原生动态代理</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这部分代码清晰说明了 Spring 在生成代理对象时如何在 java 原生代理和 CGLib 代理之间进行选择，可以概括如下：</p>
<ol>
<li>如果目标类实现了接口，则 Spring 默认会使用 java 原生代理。</li>
<li>如果目标类未实现接口，则 Spring 会使用 CGLib 生成代理。</li>
<li>如果目标类实现了接口，但是在配置时指定了 <code>proxy-target-class=true</code>，则使用 CGLib 生成代理。</li>
</ol>
<p>下面分别对基于 java 原生代理和 CGLib 代理生成增强代理对象的过程进行分析。</p>
<h5 id="基于-Java-原生代理创建增强代理对象"><a href="#基于-Java-原生代理创建增强代理对象" class="headerlink" title="基于 Java 原生代理创建增强代理对象"></a>基于 Java 原生代理创建增强代理对象</h5><p>首先来看一下基于 Java 原生代理生成增强代理对象的过程，位于 <code>JdkDynamicAopProxy</code> 类中。Java 原生代理要求代理类实现 <code>InvocationHandler</code> 接口，并在 <code>InvocationHandler#invoke</code> 方法中实现代理增强逻辑。<code>JdkDynamicAopProxy</code> 正好实现了该接口，对应的 <code>JdkDynamicAopProxy#invoke</code> 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.targetSource;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当前是 equals 方法，但是被代理类接口中未定义 equals 方法</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.equals(args[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 当前是 hashCode 方法，但是被代理类接口中未定义 hashCode 方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hashCode();<br>        &#125;<br>        <span class="hljs-comment">// 如果是 DecoratingProxy 中定义的方法（即 DecoratingProxy#getDecoratedClass），直接返回目标类对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;<br>            <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-built_in">this</span>.advised);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.advised.opaque <span class="hljs-comment">// 允许被转换成 Advised 类型</span><br>                &amp;&amp; method.getDeclaringClass().isInterface() <span class="hljs-comment">// 接口类型</span><br>                &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) <span class="hljs-comment">// 方法所在类是 Advised 类及其父类</span><br>        &#123;<br>            <span class="hljs-comment">// 直接反射调用该方法</span><br>            <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-built_in">this</span>.advised, method, args);<br>        &#125;<br><br>        <span class="hljs-comment">// 结果值</span><br>        Object retVal;<br><br>        <span class="hljs-comment">// 指定内部间调用也需要代理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>            <span class="hljs-comment">// Make invocation available if necessary.</span><br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool.</span><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 获取当前方法的拦截器链</span><br>        List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br><br>        <span class="hljs-comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br>        <span class="hljs-comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br>        <span class="hljs-comment">// 拦截器链为空，则直接反射调用增强方法</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly</span><br>            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br>            <span class="hljs-comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>        &#125;<br>        <span class="hljs-comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">MethodInvocation</span> <span class="hljs-variable">invocation</span> <span class="hljs-operator">=</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);<br>            <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span><br>            retVal = invocation.proceed();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理返回值</span><br>        Class&lt;?&gt; returnType = method.getReturnType();<br>        <span class="hljs-keyword">if</span> (retVal != <span class="hljs-literal">null</span> &amp;&amp; retVal == target &amp;&amp;<br>                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;<br>                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// Special case: it returned &quot;this&quot; and the return type of the method is type-compatible.</span><br>            <span class="hljs-comment">// Note that we can&#x27;t help if the target sets a reference to itself in another returned object.</span><br>            retVal = proxy;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<br>                    <span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>        &#125;<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>            <span class="hljs-comment">// Must have come from TargetSource.</span><br>            targetSource.releaseTarget(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>            <span class="hljs-comment">// Restore old proxy.</span><br>            AopContext.setCurrentProxy(oldProxy);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由上述方法实现，我们可以概括出整个增强代理的执行过程，如下：</p>
<ol>
<li>特殊处理 <code>Object#equals</code>、<code>Object#hashCode</code>、<code>DecoratingProxy#getDecoratedClass</code>，以及 Advised 类及其父类中定义的方法；</li>
<li>如果配置了 expose-proxy 属性，则记录当前代理对象，以备在内部间调用时实施增强；</li>
<li>获取当前方法的拦截器链；</li>
<li>如果没有拦截器定义，则直接反射调用增强方法，否则先逐一执行拦截器方法，最后再应用增强方法；</li>
<li>处理返回值。</li>
</ol>
<p>重点来看一下步骤 4 中应用拦截器方法的实现，位于 <code>ReflectiveMethodInvocation#proceed</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 如果所有的增强都执行完成，则执行增强方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentInterceptorIndex == <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.invokeJoinpoint();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取下一个需要执行的拦截器</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">interceptorOrInterceptionAdvice</span> <span class="hljs-operator">=</span><br>            <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-built_in">this</span>.currentInterceptorIndex);<br>    <span class="hljs-comment">// 动态拦截器，执行动态方法匹配</span><br>    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;<br>        <span class="hljs-comment">// Evaluate dynamic method matcher here: static part will already have been evaluated and found to match.</span><br>        <span class="hljs-type">InterceptorAndDynamicMethodMatcher</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span><br>                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;<br>        Class&lt;?&gt; targetClass = (<span class="hljs-built_in">this</span>.targetClass != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.targetClass : <span class="hljs-built_in">this</span>.method.getDeclaringClass());<br>        <span class="hljs-comment">// 动态匹配成功，执行对应的拦截方法</span><br>        <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-built_in">this</span>.method, targetClass, <span class="hljs-built_in">this</span>.arguments)) &#123;<br>            <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-comment">// 动态匹配失败，忽略当前拦截器方法，继续执行下一个拦截器</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.proceed();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 静态拦截器，直接应用拦截方法</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>拦截器方法的执行流程如上述代码注释，是一个递归调用的过程，并在最后应用增强方法。</p>
<p>完成了对于 AOP 代理对象 <code>JdkDynamicAopProxy</code> 的创建，最后来看一下获取该对象的过程，实现位于 <code>JdkDynamicAopProxy#getProxy</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-comment">// 获取需要被代理的接口集合</span><br>    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-built_in">this</span>.advised, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 检测是否在被代理接口中声明了 equals 和 hashCode 方法</span><br>    <span class="hljs-built_in">this</span>.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>    <span class="hljs-comment">// 基于 Java 原生代理生成代理对象</span><br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的逻辑也就是 Java 原生代理的模板代码，如果对 Java 代理比较熟悉的话，应该不难理解</p>
<h5 id="基于-CGLib-代理创建增强代理对象"><a href="#基于-CGLib-代理创建增强代理对象" class="headerlink" title="基于 CGLib 代理创建增强代理对象"></a>基于 CGLib 代理创建增强代理对象</h5><p>基于 CGLib 代理生成增强代理对象的过程位于 <code>ObjenesisCglibAopProxy</code> 类中，该类继承自 <code>CglibAopProxy</code> 类。获取 CGLib 代理类对象的方法定义在 <code>CglibAopProxy</code> 中，即 <code>CglibAopProxy#getProxy</code> 方法。该方法基于 CGLib 的 <code>Enhancer</code> 类创建代理对象，属于 CGLib 的标准使用模式，因为有多个 <code>callback</code> 实现，所以这里使用了 <code>CallbackFilter</code> 模式，依据场景选择并应用对应的 <code>callback</code> 拦截器。</p>
<p>我们重点关注 <code>callback</code> 的实现，位于 <code>CglibAopProxy#getCallbacks</code> 方法中。受制于 CGLib 在执行时一次只允许应用一个 <code>callback</code> 的约束，所以该方法依据参数配置实现了一组 <code>callback</code>，以覆盖不同的场景。核心的 AOP callback 实现是 <code>DynamicAdvisedInterceptor</code> 类，它实现了 <code>MethodInterceptor</code> 接口，对应的 <code>DynamicAdvisedInterceptor#intercept</code> 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.getTargetSource();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 指定内部间调用也需要代理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>            <span class="hljs-comment">// Make invocation available if necessary.</span><br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 获取当前方法的拦截器链</span><br>        List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>        <span class="hljs-comment">// 结果值</span><br>        Object retVal;<br>        <span class="hljs-comment">// Check whether we only have one InvokerInterceptor:</span><br>        <span class="hljs-comment">// that is, no real advice, but just reflective invocation of the target.</span><br>        <span class="hljs-comment">// 拦截器链为空，则直接反射调用增强方法</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;<br>            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span><br>            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span><br>            <span class="hljs-comment">// it does nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = methodProxy.invoke(target, argsToUse);<br>        &#125;<br>        <span class="hljs-comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            retVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();<br>        &#125;<br>        <span class="hljs-comment">// 处理返回值</span><br>        retVal = processReturnType(proxy, target, method, retVal);<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>            targetSource.releaseTarget(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>            <span class="hljs-comment">// Restore old proxy.</span><br>            AopContext.setCurrentProxy(oldProxy);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出上述方法在实现流程上与前面介绍的 <code>JdkDynamicAopProxy#invoke</code> 方法是一致的，只是这里是基于 CGLib 实现</p>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://my.oschina.net/wangzhenchao/blog/4279608">https://my.oschina.net/wangzhenchao/blog/4279608</a></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><code>@EnableAspectJAutoProxy</code> 开启AOP功能 </li>
<li><code>@EnableAspectJAutoProxy</code> 会给容器中注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code> </li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code> 是一个 <code>InstantiationAwareBeanPostProcessor</code> 类型后置处理器，功能可以概括为：<ol>
<li>从容器中获取所有的切面定义</li>
<li>筛选适用于当前 bean 的增强器集合</li>
<li>依据增强器集合基于动态代理机制生成相应的增强代理对象</li>
</ol>
</li>
</ol>
<p>Spring AOP 的实现本质上是一个动态代理的过程，Spring 引入了 Java 原生代理和 CGLib 代理，并依据场景选择基于哪种代理机制对目标对象进行增强。Spring 容器在完成对 bean 对象的创建之后会执行初始化操作，而 AOP 初始化的过程就发生在 bean 的后置初始化阶段</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/AOP/" class="print-no-link">#AOP</a>
      
        <a href="/tags/Reflect/" class="print-no-link">#Reflect</a>
      
        <a href="/tags/Proxy/" class="print-no-link">#Proxy</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>代理 Proxy 反射 Reflect 与 Spring AOP</div>
      <div>https://sugayoiya.github.io/posts/59835.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sugayoiya</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年8月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/11853.html" title="Spring 解决循环依赖原理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring 解决循环依赖原理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/34792.html" title="Spring Bean 的生命周期">
                        <span class="hidden-mobile">Spring Bean 的生命周期</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"waline-mongo-gamma.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://unpkg.com/@waline/emojis@1.1.0/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
