

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browser.png">
  <link rel="icon" href="/img/browser.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sugayoiya">
  <meta name="keywords" content="Java 集合">
  
    <meta name="description" content="Java 集合（Java Collections）是 Java 编程语言中用于存储、处理和操作一组对象的框架。它提供了一组接口和类，用于在不同的数据结构上执行各种操作。Java集合框架提供了多种集合类型，包括列表（List）、集（Set）、映射（Map）等">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合">
<meta property="og:url" content="https://sugayoiya.github.io/posts/55978.html">
<meta property="og:site_name" content="東方プロジェクト">
<meta property="og:description" content="Java 集合（Java Collections）是 Java 编程语言中用于存储、处理和操作一组对象的框架。它提供了一组接口和类，用于在不同的数据结构上执行各种操作。Java集合框架提供了多种集合类型，包括列表（List）、集（Set）、映射（Map）等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sugayoiya.github.io/img/post/(105369093)%E2%9D%80.jpg">
<meta property="article:published_time" content="2021-06-15T15:56:12.000Z">
<meta property="article:modified_time" content="2023-07-27T16:02:42.000Z">
<meta property="article:author" content="Sugayoiya">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Collection">
<meta property="article:tag" content="List">
<meta property="article:tag" content="Set">
<meta property="article:tag" content="Queue">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://sugayoiya.github.io/img/post/(105369093)%E2%9D%80.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java 集合 - 東方プロジェクト</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sugayoiya.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"vggcI4F6j2ISzL56HSxMZF9V-MdYXbMMI","app_key":"yKtFKhuP8rhbpXecJ4jmPFmq","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sugayoiya</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>妖怪の山</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>紅魔館</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>雾之湖</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>人間の里</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>永遠亭</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post/(109072817)day30%20%E5%91%BD%E3%81%AB%E5%AB%8C%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 集合"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-06-15 23:56" pubdate>
          2021年6月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          49 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java 集合</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>Java</strong> 集合（<strong>Java Collections</strong>）是 Java 编程语言中用于存储、处理和操作一组对象的框架。它提供了一组接口和类，用于在不同的数据结构上执行各种操作。Java集合框架提供了多种集合类型，包括列表（<strong>List</strong>）、集（<strong>Set</strong>）、映射（<strong>Map</strong>）等</p>
<span id="more"></span>

<p><img src="/posts/55978/Collection-framework-hierarchy.png" srcset="/img/loading.gif" lazyload alt="FrameworkHierarchy - Java Collections - Edureka"></p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的 <code>java.util</code> 包提供了集合类：<code>Collection</code>，它是除 <code>Map</code> 外所有其他集合类的根接口。Collection 是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection 接口是 Set，Queue，List的父接口</p>
<ul>
<li><strong>List 是一个有序的队列</strong>，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList，ArrayList，Vector，Stack</li>
<li><strong>Set 是一个不允许有重复元素的集合</strong>。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的</li>
<li><strong>Queue 也就是队列</strong>，是一种遵循<strong>先进先出</strong>（<code>FIFO: First In, First Out</code>）原则的数据集合，数据在Queue中的流动是单向的，从队尾流向队首。Queue 的实现类有 LinkedList，ArrayDeque，PriorityQueue</li>
</ul>
<p>Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作</p>
<ul>
<li><p><code>int size()</code>：返回集合中的元素个数</p>
</li>
<li><p><code>boolean isEmpty()</code>：检查集合是否为空，如果集合中没有元素，则返回true，否则返回false</p>
</li>
<li><p><code>boolean contains(Object o)</code>：检查集合中是否包含指定的元素o，如果包含则返回true，否则返回false</p>
</li>
<li><p><code>boolean add(E e)</code>：将元素e添加到集合中，如果添加成功，则返回true。对于某些集合，可能会限制添加重复元素</p>
</li>
<li><p><code>boolean remove(Object o)</code>：从集合中移除指定的元素o，如果元素存在并成功移除，则返回true，否则返回false</p>
</li>
<li><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将给定集合c中的所有元素添加到当前集合中，如果集合发生变化，则返回true</p>
</li>
<li><p><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从当前集合中移除与给定集合c中相同的所有元素，如果集合发生变化，则返回true</p>
</li>
<li><p><code>boolean retainAll(Collection&lt;?&gt; c)</code>：保留当前集合和给定集合c中共有的元素，移除其他元素，如果集合发生变化，则返回true</p>
</li>
<li><p><code>void clear()</code>：清空集合中的所有元素</p>
</li>
<li><p><code>boolean containsAll(Collection&lt;?&gt; c)</code>：检查当前集合是否包含给定集合c中的所有元素，如果是，则返回true</p>
</li>
<li><p><code>Object[] toArray()</code>：将集合转换为Object类型的数组</p>
</li>
<li><p><code>&lt;T&gt; T[] toArray(T[] a)</code>：将集合转换为指定类型的数组</p>
</li>
</ul>
<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><blockquote>
<p>在 Java 集合框架中，<code>List</code> 接口是一个有序的集合，允许包含重复元素。它扩展自 <code>Collection</code> 接口，因此继承了 <code>Collection</code> 中定义的一些通用方法，并且定义了一些特定于列表的方法。<code>List</code>接口中的元素可以根据插入的顺序访问，并且可以通过索引来访问和操作列表中的元素</p>
</blockquote>
<p><strong>List 集合特点</strong></p>
<ul>
<li>集合中的元素允许重复</li>
<li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序</li>
<li>集合中的元素可以通过索引来访问或者设置</li>
</ul>
<p>List 接口为 Collection 直接接口。List 所代表的是有序的 Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>、<code>Stack</code></p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以<strong>如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率</strong></p>
<p><code>size、isEmpty、get、set、iterator</code>和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）</p>
<p><strong>ArrayList擅长于随机访问。同时ArrayList是非同步的</strong></p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>同样实现List接口的LinkedList与ArrayList不同，<strong>ArrayList是一个动态数组，而LinkedList是一个双向链表</strong>。所以它除了有ArrayList的基本操作方法外还额外提供了<code>get，remove，insert</code>方法在LinkedList的首部或尾部</p>
<p>由于实现的方式不同，<strong>LinkedList不能随机访问</strong>，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作</p>
<p>与ArrayList一样，<strong>LinkedList也是非同步的</strong>。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(...));<br></code></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>与ArrayList相似，但是Vector是同步的。所以说<strong>Vector是线程安全的动态数组</strong>。它的操作与ArrayList几乎一样</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈</p>
<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>Set 是一种<strong>不包括重复元素的 Collection</strong>。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许 <code>null</code> 的存在但是仅有一个。由于Set接口的特殊性，<strong>所有传入Set集合中的元素都必须不同</strong>，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致 <code>e1.equals(e2)==true</code>，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集 <code>HashSet</code>、链式散列集 <code>LinkedHashSet</code> 和树形集 <code>TreeSet</code></p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 是 set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的。当想 HashSet 集合中添加元素时，首先会调用 <code>hashcode</code> 方法来确定元素的存储位置，然后再调用元素对象的 <code>equals()</code>方法来确保该位置没有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        hashSet.add(<span class="hljs-string">&quot;Jack&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Rose&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Eve&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;Rose&quot;</span>);<br>        hashSet.forEach(obj-&gt; System.out.println(obj));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出结果为</span><br>    Eve<br>    Rose<br>    Jack<br></code></pre></td></tr></table></figure>

<p>向集合中存入元素时，为了保证 HashSet 正常工作，要求在存入对象是，需要重写 Object 类中的 <code>hashCode()</code>和 <code>equals()</code>方法。上个例子将字符串存入 HashSet 时，String 类已经默认重写了 hashCode 的方法，但是有时候传入自定义类型的对象存入 HashSet，需要重写方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;zhang&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;row&quot;</span>));<br>        hashSet.forEach();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String id;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id+<span class="hljs-string">&quot; &quot;</span>+name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id.hashCode();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == object)&#123;        <span class="hljs-comment">//判断是否是同一个对象</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">//如果是，返回true</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(!(object <span class="hljs-keyword">instanceof</span> Student))&#123;        <span class="hljs-comment">//判断对象是为Student类型</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//如果不是，返回false</span><br>        &#125;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) object;            <span class="hljs-comment">//将对象强转为Student类型</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.id.equals(student.id);        <span class="hljs-comment">//判断id值是否相同</span><br>        <span class="hljs-keyword">return</span> b;                                    <span class="hljs-comment">//返回判断结果</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br>[<span class="hljs-number">2</span> zhang, <span class="hljs-number">4</span> jack, <span class="hljs-number">6</span> row, <span class="hljs-number">8</span> name]<br></code></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 是一个有序集合，其底层是基于 TreeMap 实现的，非线程安全。TreeSet 可以确保集合元素处于排序状态。<strong>TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</strong>当我们构造 TreeSet 时，若使用不带参数的构造函数，则 TreeSet 的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数</p>
<blockquote>
<p>注意：TreeSet集合不是通过 hashcode 和 equals 函数来比较元素的。它是通过 compare 或者 comparaeTo 函数来判断元素是否相等。compare 函数通过判断两个对象的 id，相同的 id 判断为重复元素，不会被加入到集合中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自然排序</span><br><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">18</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">19</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">19</span>));<br>        treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">19</span>));<br>        System.out.println(treeSet);<br><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    定义Teacher类实现Comparable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;:&quot;</span>+age;<br>    &#125;<br><span class="hljs-comment">//    重写Comparable接口的compareTo()的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> (Teacher) obj;<br><span class="hljs-comment">//     定义比较方式，先比较年龄，再比较名称name</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.age- teacher.age&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.age- teacher.age==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(teacher.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br>[jack:<span class="hljs-number">18</span>, rose:<span class="hljs-number">19</span>, tom:<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure>

<p>Teacher类实现了 Comparable 接口，并重写 compareTo() 方法。在 compareTo() 方法中，首先针对 age 值进行修改，根据比较结果返回-1和1，当 age 相同时，再对 name 进行比较。教师 Teacher 对象首先按照年龄升序排序，年龄相同时会按照姓名进行升序排序，并且 TreeSet 集合会将重复的元素去掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定制排序</span><br><span class="hljs-keyword">package</span> Demo01;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.创建集合时，传入Comparator接口实现定制排序规则</span><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>());<br>        treeSet.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(treeSet);<br>        <span class="hljs-comment">// 2.创建集合时，使用Lambda表达式定制排序规则</span><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>((obj1,obj2)-&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (String) obj1;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (String) obj2;<br>            <span class="hljs-keyword">return</span> s1.length() - s2.length();<br>        &#125;);<br>        treeSet1.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(treeSet1);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object obj1, Object obj2)</span>&#123; <span class="hljs-comment">//定制排序方式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> (String) obj1;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> (String) obj2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> str1.length()-str2.length();<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet 继承自 HashSet，其底层是<strong>基于LinkedHashMap来实现的</strong>，有序，非同步。LinkedHashSet 集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，<strong>LinkedHashSet将会以元素的添加顺序访问集合的元素</strong></p>
<h3 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p>在 Java 集合框架中，<code>Queue </code>接口是一种特殊的集合，用于存储元素按照先进先出（<em>FIFO，First-In-First-Out</em>）的顺序进行排列。这意味着首先添加到队列的元素将首先被移除。<code>Queue</code> 继承自 <code>Collection</code>接口，并在其基础上定义了一些特定于队列的方法</p>
<p><code>Queue</code> 接口中定义了以下一些常用的方法：</p>
<ul>
<li><code>boolean add(E e)</code>：将元素<strong>e</strong>添加到队列的尾部。如果队列容量有限且已满，该方法将抛出一个 <code>IllegalStateException</code>异常</li>
<li><code>boolean offer(E e)</code>：将元素<strong>e</strong>添加到队列的尾部。如果队列容量有限且已满，该方法将返回false，否则返回true</li>
<li><code>E remove()</code>：移除并返回队列头部的元素。如果队列为空，该方法将抛出一个 <code>NoSuchElementException</code> 异常</li>
<li><code>E poll()</code>：移除并返回队列头部的元素。如果队列为空，该方法将返回null</li>
<li><code>E element()</code>：返回队列头部的元素，但不移除它。如果队列为空，该方法将抛出一个<code>NoSuchElementException</code>异常</li>
<li><code>E peek()</code>：返回队列头部的元素，但不移除它。如果队列为空，该方法将返回 null</li>
</ul>
<p>除了上述常用方法，<code>Queue</code>接口还继承自<code>Collection</code>接口中的一些其他方法，比如<code>size()</code>、<code>isEmpty()</code>、<code>contains(Object o)</code>等。</p>
<p><code>Queue </code> 接口的实现类通常有：</p>
<ul>
<li><code>LinkedList</code>：<code>LinkedList</code> 可以用作队列的实现，因为它同时支持链表的特性和队列的特性</li>
<li><code>ArrayDeque</code>：<code>ArrayDeque</code> 是一个基于数组的双端队列，可以用作队列和栈的实现</li>
<li><code>PriorityQueue</code>：<code>PriorityQueue</code> 是一个优先级队列，可以根据元素的优先级进行排序。默认情况下，按照自然顺序排序，或者也可以通过自定义比较器指定排序规则</li>
</ul>
<p><code>Queue</code> 接口在Java中非常有用，特别是在多线程和异步编程中。可以帮助我们实现任务队列、消息队列等常见的场景</p>
<h3 id="ArrayList-的实现"><a href="#ArrayList-的实现" class="headerlink" title="ArrayList 的实现"></a>ArrayList 的实现</h3><p>ArrayList 可以理解为动态数组，就是 Array 的复杂版本。与 Java 中的数组相比，它的容量能动态增长ArrayList 是 List 接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的）</p>
<p>每个 ArrayList 实例都有一个<strong>容量</strong>，该容量是指<strong>用来存储列表元素的数组的大小</strong>。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造 ArrayList 时指定其容量。在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量</p>
<p>注意，此实现<strong>不是同步</strong>的。如果多个线程同时访问一个 ArrayList 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）</p>
<h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p><strong>私有属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure>

<p><code>elementData</code> 存储 <code>ArrayList</code> 内的元素，<code>size</code> 表示它包含的元素的数量</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为<strong>10</strong>的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 默认容量 10</span><br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 创建一个包含collection的ArrayList    </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储"></a>元素存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;  <br>   RangeCheck(index);  <br><br>   <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) elementData[index];  <br>   elementData[index] = element;  <br>   <span class="hljs-keyword">return</span> oldValue;  <br>&#125;    <br><br><span class="hljs-comment">// 将指定的元素添加到此列表的尾部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;  <br>   ensureCapacity(size + <span class="hljs-number">1</span>);   <br>   elementData[size++] = e;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;    <br><br><span class="hljs-comment">// 将指定的元素插入此列表中的指定位置。</span><br><span class="hljs-comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)  <br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size);  <br><span class="hljs-comment">// 如果数组长度不足，将进行扩容。</span><br>   ensureCapacity(size+<span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>   <span class="hljs-comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span><br><span class="hljs-comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。</span><br><span class="hljs-comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。</span><br>   System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);  <br>   elementData[index] = element;  <br>   size++;  <br>&#125;    <br><br><span class="hljs-comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;  <br>   Object[] a = c.toArray();  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;  <br>   ensureCapacity(size + numNew);  <span class="hljs-comment">// Increments modCount  </span><br>   System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);  <br>   size += numNew;  <br>   <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;  <br>&#125;    <br><br><span class="hljs-comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)  <br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(  <br>           <span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);  <br><br>   Object[] a = c.toArray();  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;  <br>   ensureCapacity(size + numNew);  <span class="hljs-comment">// Increments modCount  </span><br><br>   <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;  <br>   <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)  <br>       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  <br><br>   System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);  <br>   size += numNew;  <br>   <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;  <br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取"></a>元素读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回此列表中指定位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>   RangeCheck(index);  <br> <br>   <span class="hljs-keyword">return</span> (E) elementData[index];  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p><code>ArrayList</code> 提供了根据下标或者指定对象两种方式的删除功能。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 移除此列表中指定位置上的元素。</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    RangeCheck(index);  <br>  <br>    modCount++;  <br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) elementData[index];  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)  <br>       System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);  <br>    elementData[--size] = <span class="hljs-literal">null</span>; <br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当移除成功后返回 true，否则返回 false。<code>remove(Object o)</code> 中通过遍历 element 寻找是否存在传入对象，一旦找到就调用 <code>fastRemove</code> 移除对象。因为 <code>fastRemove</code> 跳过了判断边界的处理，因为找到元素就相当于确定了 index 不会超过边界，而且 <code>fastRemove</code> 并不返回被移除的元素。下面是 <code>fastRemove</code> 的代码，基本和 <code>remove(index)</code> 一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来实现。在实际添加大量元素前，我也可以使用 <code>ensureCapacity</code> 来手动增加 <code>ArrayList</code> 实例的容量，以减少递增式再分配的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &gt; <span class="hljs-number">0</span>)<br>        ensureCapacityInternal(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上述代码中可以看出，<strong>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中</strong>，每次数组容量的增长大约是其原容量的 1.5 倍（从 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code> 这行代码得出）。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量</p>
<h4 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h4><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p>
<h3 id="LinkedList-的实现"><a href="#LinkedList-的实现" class="headerlink" title="LinkedList 的实现"></a>LinkedList 的实现</h3><p>Java 中的 LinkedList 类实现了 List 接口和 Deque 接口，是一种链表类型的数据结构，支持高效的插入和删除操作，同时也实现了Deque接口，使得 LinkedList 类也具有队列的特性。LinkedList 类的底层实现的数据结构是一个双端的链表</p>
<h4 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>LinkedList 底层<strong>通过双向链表实现</strong>。双向链表的每个节点用内部类 <em>Node</em> 表示。LinkedList 通过 <code>first</code> 和 <code>last</code> 引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候 <code>first</code> 和 <code>last</code> 都指向 <code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure>

<p>LinkedList 类中有一个内部私有类 Node，这个类就代表双端链表的节点 Node。在 <code>Node&lt;E&gt;</code> 中，成员变量 <code>item</code> 用来存储具体的元素值，另外两个 <code>Node&lt;E&gt;</code> 类型的变量 <code>next</code> 和 <code>prev</code> 分别表示该节点的<strong>后一个节点</strong>和<strong>上一个节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意这个节点的初始化方法，给定三个参数，分别前驱节点，本节点的值，后继结点。这个方法将在LinkedList的实现中多次调用</p>
</blockquote>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    <span class="hljs-comment">// 添加所有元素</span><br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LinkedList 主要就两个构造方法，一个无参的构造，什么也没做，另一个接受集合的构造，该方法初始化了 LinkedList 对象并添加了所有集合c的元素</p>
<p>LinkedList 因为基于链表，所以<strong>不需要提前申请内存大小</strong>，也就不存在初始化指定容量大小，因而LinkedList 是没有初始化指定 size 的构造方法的</p>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="尾部添加"><a href="#尾部添加" class="headerlink" title="尾部添加"></a>尾部添加</h5><p>LinkedList 的添加方法有很多，首先最简单也是最常用的尾部添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要逻辑就是 <code>linkLast(E e)</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 构造新的节点，上一节点指向原来的last</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    <span class="hljs-comment">// 操作数自增</span><br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>尾部添加，就是构造新的节点 <code>newNode</code>，并将改节点的上一节点 <code>prev</code> 指向原来的 <code>last</code>，同时改节点为新的last节点。<code>l == null</code> 判断是否当前是第一次添加，如果 <code>l</code> 为 <code>null</code>，则 <code>newNode</code> 同时也是头结点，当前集合中仅有 <code>newNode</code> 一个元素，不为 <code>null</code> 时，因为双向链表，所有 <code>l</code> 的下一个节点 <code>next</code> 指向了<code>newNode</code></p>
<p>最后就是大小 size 自增与操作计数 modCount 的自增，尾部添加元素就完成了</p>
<p>尾部操作除了 add，还有个 <code>addLast(E e)</code> 方法，两者除了返回值不一样没有任何差别，都是调用的 linkLast 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="中间添加"><a href="#中间添加" class="headerlink" title="中间添加"></a>中间添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkPositionIndex(index);<br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于中间添加，需要首先进行范围检查，即保证插入位置 <code>index</code> 在 <code>[0, size]</code> 之间，否则抛出数组越界异常 <code>IndexOutOfBoundsException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isPositionIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= size;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 <code>index == size</code>，其实就是尾部插入，所以调用了 linkLast，这个刚刚尾部插入已经说过。</p>
<p>如果 <code>index &lt; size</code>，中间插入的时候，需要分两步：</p>
<ol>
<li><code>node(int index)</code> 方法获取到 index 位置的元素 succ</li>
<li><code>linkBefore(E e, Node&lt;E&gt; succ)</code> 将需要插入的元素 element 连接到 succ 后面</li>
</ol>
<p>node 方法是一个频繁被调用的方法，LinkedList 的很多操作都依赖于该方法查找到对应的元素。根据索引 index 获取元素时，因为双向链表的支持前后遍历，所以进行了位置判断，<code>index &lt; (size &gt;&gt; 1)</code>，与中间位置比较，靠前则前序遍历，否则后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">//前序遍历</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>遍历逻辑很简单，循环到index上一个节点（后序则是下一个）位置，获取next（后序使用prev）返回index位置对应的节点Node对象succ</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    succ.prev = newNode;<br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>linkBefore 和 linkLast 几乎完全一样，除了一个是添加到 last 节点后，一个是添加到 succ 节点后。</p>
<p>对于中间插入，如果 index 为 0 时，其实就是头部插入，这个时候比不用调用 node 方法去查找元素了，所以 LinkedList 也提供了一个 addFirst(E e) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    linkFirst(e);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        last = newNode;<br>    <span class="hljs-keyword">else</span><br>        f.prev = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><p>LinkedList 提供尾部批量插入和中间批量插入，但内部实现其实都是调用的 <code>addAll(int index, Collection&lt;? extends E&gt; c)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 范围校验</span><br>    checkPositionIndex(index);<br>    Object[] a = c.toArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// succ是index位置元素，pred是index的前一个元素</span><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-keyword">if</span> (index == size) &#123; <span class="hljs-comment">// 尾部插入</span><br>        succ = <span class="hljs-literal">null</span>;<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br>    <span class="hljs-comment">// 循环插入</span><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) o;<br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            pred.next = newNode;<br>        pred = newNode;<br>    &#125;<br>    <span class="hljs-comment">// 衔接处理</span><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-literal">null</span>) &#123;<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.next = succ;<br>        succ.prev = pred;<br>    <br>    size += numNew;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>addAll(int index, Collection&lt;? extends E&gt; c)</code> 方法初一看，好像有些复杂，但明白其原理后，就变得清晰多了。链表插入就如同接水管，先从某一个位置断开水管，然后用接口连接上需要接入的部分。这个方法里，关键的是两个 Node 对象 pred 和 succ，succ 是 index 位置元素，pred 是 index 的前一个元素（变动）</p>
<p>特殊情况 <code>index == size</code> 时，即尾部插入，所以 succ 就是 null 了，而 pred 则为尾部节点 last</p>
<p>然后就是循环赋值了，在循环中构造 node 节点，类似于 linkLast</p>
<p>最后的是衔接处理，如果尾部插入的话，那 pred 就是尾部节点了（循环赋值时有 <code>pred = newNode</code> 处理），所以只需要指定 <code>last = pred</code> 。而中间插入，指明 <code>pred.next = succ</code>、<code>succ.prev = pred</code> 即将 index 位置与新的前一个元素绑定到一起</p>
<h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; .....&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 此处直接调用了add方法</span><br>    <span class="hljs-keyword">return</span> add(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用linkLast方法</span><br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建新节点，prev节点指向当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 新节点作为新的last节点</span><br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 如果原last节点为null，表示该链表为空，则将节点同时作为first节点</span><br>      first = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原last节点的next节点</span><br>      l.next = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中可以很容易的看出，<code>offer</code> 方法直接调用了 <code>add</code> 方法，<code>add</code> 方法中调用了 <code>linkLast</code> 方法，并直接返回了true，表示该元素肯定可以插入成功。具体执行元素插入的逻辑在 <code>linkLast</code> 方法中完成，通过上面代码中的注释可以看出，<code>linkLast </code>方法主要功能是在链表尾端添加一个新节点</p>
<p><strong><code>offerFirst </code>和 <code>offerLast</code></strong></p>
<p>当了解了 <code>offer</code> 方法后，我们再看下 <code>offerFirst </code>和 <code>offerLast</code> 的实现。从下面代码中可以知道，<code>offerFirst</code> 和 <code>offerLast</code> 方法分别调用了 <code>addFirst</code> 和 <code>addLast</code> 方法，然后在 <code>addFirst</code> 和 <code>addLast</code> 方法中，又分别调用了 <code>linkFirst</code> 和 <code>linkLast</code> 方法</p>
<p><code>linkLast </code>方法上已经讲到，主要功能是在链表尾端添加一个新节点；而 <code>linkFirst</code> 方法，其主要功能是在链表首端添加一个新节点，具体逻辑与 <code>linkLast</code> 方法类似，本处不再赘述，可以参考下面代码中的注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; .....&#123;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    linkFirst(e);<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表头部，添加一个新元素，并作为新的first节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-comment">// 创建新节点，next节点指向当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    <span class="hljs-comment">// 新节点作为新的first节点</span><br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 如果原first节点为null，表示该链表为空，则将节点同时作为last节点</span><br>      last = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原first节点的prev节点</span><br>      f.prev = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 本处省略，详见上一代码块</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>LinkedList 除了提供通用的 get，因为其属性中含有 first 和 last 节点，也提供了 getFirst 和 getLast 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 getFirst 和 getLast，因为是成员变量，省去了查找的过程，直接返回其节点 item 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 范围校验</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// node方法获取节点</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而通过指针的获取，主要就是调用node方法找对index对应的节点</p>
<h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>对于 LinkedList 集合中元素的修改，需要先查找到该元素，然后更改其 Node 节点数据 item 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// 获取index对应位置的Node对象</span><br>    Node&lt;E&gt; x = node(index);<br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> x.item;<br>    x.item = element;<br>    <span class="hljs-keyword">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>LinkedList 提供了很多种删除元素的方法，但是内部实现逻辑基本都相同，即找到对应的 Node 节点，然后将指向该节点的指向替换</p>
<h5 id="根据索引移除"><a href="#根据索引移除" class="headerlink" title="根据索引移除"></a>根据索引移除</h5><p>我们先来看看根据索引的 <code>remove(int index)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 范围检查</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">// 解除节点指针连接</span><br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>删除时的范围检查就不说了，node方法也不再多提，删除的主要逻辑就是 <code>unlink(Node&lt;E&gt; x)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-comment">// 下一节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 前一节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br>    <span class="hljs-comment">// 前一节点prev存在则将prev的下一节点指向next，不存在则当前移除节点其实就是头结点，next就是新的first</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 下一节点next存在，则将next上一节点指向prev，不存在则说明当前移除的是未节点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 触发GC工作</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    <span class="hljs-comment">// 操作计数器自增</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整个 unlink 方法就是个标准的双向链表删除操作，三个节点 prev，x，next，删除 x 其实就是将 prev 指向 next，并 next 指向 prev，只是其中多了一些特殊的判断</p>
<p>看了按索引删除的 remove，再来看另外两个特例 removeFirst 和 removeLast</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-literal">null</span>;<br>    f.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>        last = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-literal">null</span>;<br>    size--;<br>    <span class="hljs-comment">// 操作计数器自增</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>unlinkFirst 就是个简化版的 unlink 方法，因为只用处理头结点，下一个节点 next 存在就将 next 作为新的first</p>
<p>同理 removeLast 也是类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> &#123;<br>    <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> l.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>    l.item = <span class="hljs-literal">null</span>;<br>    l.prev = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    last = prev;<br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>)<br>        first = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>        prev.next = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 LinkedList 还有个无参的 remove，这个是 Deque 接口定义的，实现也就是调用的 removeFirst</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="根据元素移除"><a href="#根据元素移除" class="headerlink" title="根据元素移除"></a>根据元素移除</h5><p>根据元素移除其实和根据索引移除没有太大差别，只不过找到对应节点的方式发生了变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 判断元素是否为null，因为LinkedList支持添加null</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，无论元素是否为 null，都是先找到该节点，然后调用了unlink 方法</p>
<p>因为支持双向遍历的特性，LinkedList 很人性的提供了前序删除和后序删除的方法，即 <code>removeFirstOccurrence</code> 与 <code>removeLastOccurrence</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> remove(o);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 后序遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 后序遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>removeLastOccurrence</code> 只是反序遍历了集合</p>
<h5 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h5><p>在 LinkedList 类中，并没有 removeAll 方法，因为他未对其进行重写，而是使用了父类 <code>AbstractCollection</code> 的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>    Objects.requireNonNull(c);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">modified</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 使用迭代器</span><br>    Iterator&lt;?&gt; it = iterator();<br>    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (c.contains(it.next())) &#123;<br>            it.remove();<br>            modified = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> modified;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>removeAll 的实现原理其实就是迭代删除，迭代器的获取方法 <code>iterator()</code> 在 <code>AbstractCollection</code> 类中只是个抽象方法，AbstractList 类有其实现，但 <code>AbstractSequentialList</code> 类中覆写该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> listIterator();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>iterator 方法会调用 listIterator()，这个方法实现在 AbstractList 类中，他调用了 <code>listIterator(int index)</code> 方法，但 LinkedList 重写了该方法，所以兜兜转转最终还是回到了 LinkedList 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    checkPositionIndex(index);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里 ListItr 对象是 LinkedList 的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>    <span class="hljs-comment">// 期待计数器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br></code></pre></td></tr></table></figure>

<p>ListItr 在初始化的时候，会将操作计数器 modCount 赋值给 <code>expectedModCount</code>，而之后的每次 remove 方法，都会校验 expectedModCount 与 modCount 是否相等，否则会抛出异常</p>
<p>ListItr 的 remove 方法，每次调用后，都将 <code>expectedModCount</code> 自增，已达到和 unlink 中 modCount++ 的同步，从而使得 <code>modCount == expectedModCount</code> 一直成立，这也是为什么我们循环删除 LinkedList 元素时需要使用其迭代器的 remove 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 校验modCount</span><br>    checkForComodification();<br>    <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>    Node&lt;E&gt; lastNext = lastReturned.next;<br>    <span class="hljs-comment">// unlink删除节点逻辑，该方法中有modCount++;</span><br>    unlink(lastReturned);<br>    <span class="hljs-keyword">if</span> (next == lastReturned)<br>        next = lastNext;<br>    <span class="hljs-keyword">else</span><br>        nextIndex--;<br>    lastReturned = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// expectedModCount自增</span><br>    expectedModCount++;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// expectedModCount与modCount必须相等</span><br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="PriorityQueue-的实现"><a href="#PriorityQueue-的实现" class="headerlink" title="PriorityQueue 的实现"></a>PriorityQueue 的实现</h3><p><code>PriorityQueue</code> 是Java集合框架中实现了 <code>Queue</code> 接口的一个特殊类，它是一个优先级队列。在优先级队列中，元素被赋予优先级，具有最高优先级的元素将首先被取出（取决于其排序顺序）。默认情况下，<code>PriorityQueue</code> 会对元素进行自然排序（如果元素实现了 <code>Comparable</code> 接口），也可以通过自定义比较器来指定排序规则</p>
<p><code>PriorityQueue</code> 内部使用堆数据结构来实现，这使得插入和移除元素的时间复杂度都是O(log n)，其中n是优先级队列的大小</p>
<p><strong><code>PriorityQueue</code> 的构造方法：</strong></p>
<ul>
<li><p><code>PriorityQueue()</code>: 创建一个空的优先级队列，默认初始容量为11</p>
</li>
<li><p><code>PriorityQueue(int initialCapacity)</code>: 创建一个空的优先级队列，指定初始容量</p>
</li>
<li><p><code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code>: 创建一个空的优先级队列，指定初始容量和自定义的比较器</p>
</li>
<li><p><code>PriorityQueue(Collection&lt;? extends E&gt; c)</code>: 创建一个包含指定集合c中元素的优先级队列，默认按照元素的自然顺序排序</p>
</li>
<li><p><code>PriorityQueue(PriorityQueue&lt;? extends E&gt; c)</code>: 创建一个与指定优先级队列c具有相同元素的新优先级队列</p>
</li>
</ul>
<p><strong><code>PriorityQueue</code> 主要方法：</strong></p>
<ul>
<li><p><code>boolean add(E e)</code> 或 <code>boolean offer(E e)</code>: 添加元素到队列中</p>
</li>
<li><p><code>E poll()</code>: 移除并返回队列中的头部元素，如果队列为空则返回null。</p>
</li>
<li><p><code>E remove()</code>: 移除并返回队列中的头部元素，如果队列为空则抛出<code>NoSuchElementException</code>异常</p>
</li>
<li><p><code>E peek()</code>: 返回队列中的头部元素但不移除它，如果队列为空则返回null</p>
</li>
<li><p><code>E element()</code>: 返回队列中的头部元素但不移除它，如果队列为空则抛出<code>NoSuchElementException</code>异常。</p>
</li>
<li><p><code>int size()</code>: 返回队列中的元素个数</p>
</li>
<li><p><code>boolean isEmpty()</code>: 检查队列是否为空</p>
</li>
<li><p><code>void clear()</code>: 清空队列中的所有元素</p>
</li>
</ul>
<h5 id="add-和-offer"><a href="#add-和-offer" class="headerlink" title="add() 和 offer()"></a>add() 和 offer()</h5><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p>
<p><img src="/posts/55978/939998-20160512205600890-346195840.png" srcset="/img/loading.gif" lazyload alt="PriorityQueue_offer.png"></p>
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//offer(E e)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<span class="hljs-comment">//不允许放入null元素</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//自动扩容</span><br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//队列原来为空，这是插入的第一个元素</span><br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        siftUp(i, e);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//siftUp()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//parentNo = (nodeNo-1)/2</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//调用比较器的比较方法</span><br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序</p>
<h5 id="element-和-peek"><a href="#element-和-peek" class="headerlink" title="element() 和 peek()"></a>element() 和 peek()</h5><p><code>element()</code> 和 <code>peek()</code> 的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong></p>
<p><img src="/posts/55978/939998-20160512205615171-1414392177.png" srcset="/img/loading.gif" lazyload alt="PriorityQueue_peek.png"></p>
<p>代码也就非常简洁:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//peek()</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="remove-和-poll"><a href="#remove-和-poll" class="headerlink" title="remove() 和 poll()"></a>remove() 和 poll()</h5><p><code>remove()</code> 和 <code>poll()</code> 方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p>
<p><img src="/posts/55978/939998-20160512205634609-402016454.png" srcset="/img/loading.gif" lazyload alt="PriorityQueue_poll.png"></p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) queue[s];<br>    queue[s] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素(也就是最小的那个元素)。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//siftDown()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>    	<span class="hljs-comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//leftNo = parentNo*2+1</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> queue[child];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<span class="hljs-comment">//然后用c取代原来的值</span><br>        k = child;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素(如果有多个相等，只删除一个)，该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述</p>
<p><img src="/posts/55978/939998-20160512205651859-11099237.png" srcset="/img/loading.gif" lazyload alt="PriorityQueue_remove2.png"></p>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//remove(Object o)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>	<span class="hljs-comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(o);<br>    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    <span class="hljs-keyword">if</span> (s == i) <span class="hljs-comment">//情况1</span><br>        queue[i] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">moved</span> <span class="hljs-operator">=</span> (E) queue[s];<br>        queue[s] = <span class="hljs-literal">null</span>;<br>        siftDown(i, moved);<span class="hljs-comment">//情况2</span><br>        ......<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashSet 由于是对 HashMap 的简单包装，所以将在下篇文章讲 HashMap 时在讨论</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Collection/" class="category-chain-item">Collection</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/Collection/" class="print-no-link">#Collection</a>
      
        <a href="/tags/List/" class="print-no-link">#List</a>
      
        <a href="/tags/Set/" class="print-no-link">#Set</a>
      
        <a href="/tags/Queue/" class="print-no-link">#Queue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 集合</div>
      <div>https://sugayoiya.github.io/posts/55978.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sugayoiya</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年6月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/48481.html" title="HashMap 原理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HashMap 原理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/20774.html" title="Github pages + Hexo个人博客搭建">
                        <span class="hidden-mobile">Github pages + Hexo个人博客搭建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"waline-mongo-gamma.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://unpkg.com/@waline/emojis@1.1.0/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
